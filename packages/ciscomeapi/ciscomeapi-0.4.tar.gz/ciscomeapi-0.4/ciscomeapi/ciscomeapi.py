# -*- coding: utf-8 -*-

"""
ciscomeapi
~~~~~~~~~~~~~~~~~~~

The main Cisco Mobility Express API module 
"""

import requests
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

from .exceptions import CiscoMobilityExpressAPIException, AuthenticationError
from . import _me_api


# Constants
GET = 'get'
POST = 'post'
PUT = 'put'
DELETE = 'delete'


class CiscoME:
    def __init__(self, host: str, username: str, password: str, ssl: bool=True, verify: bool=False):
        """Connect to the Mobility Express controller
        
        :param host: The hostname or IP address of the Mobility Express Controller
        :type host: str
        :param username: Mobility Express administrator username
        :type username: str
        :param password: Mobility Express administrator username
        :type password: str
        :param ssl: If True use https, otherwise http (default True)
        :type ssl: bool
        :param verify: If True, verify the SSL certificate (default False)  
        :type verify: bool
        :return: CiscoME object
        """

        if not host:
            raise CiscoMobilityExpressAPIException('host is a required parameter')

        protocol = 'https' if ssl else 'http'
        self.base_url = '{protocol}://{host}'.format(protocol=protocol, host=host)
        url = self.base_url + '/screens/dashboard.html'
        self.session = requests.Session()
        self.session.auth = (username, password)
        self.session.verify = verify
        
        response = self.session.get(url)
        if response.status_code == 401:
            # For some reason you need to connect twice
            response = self.session.get(url)
            if response.status_code == 401:
                raise AuthenticationError('Invalid username or password', session=self.session)
    
    def close(self):
        """Close the session to the Mobility Express controller
        """
        self.session.close()
    
    ###############################################################################################
    # Human crafted methods to front-end autogenerated APIs with more context and documentation
    ###############################################################################################

    def system_information(self) -> dict:
        """Returns system information about the controller (e.g. platform, version, etc.)
        
        :return: The system information
        """
        return _me_api._system_information(self, GET)

    
    def client_table(self, take: int=1000, columns: int=524287) -> dict:
        """Returns the table of client data

        :param take: The maximum number of items to return
        :type take: int
        :param columns: The binary value determines which columns are included in the output (19 bits). By default returns all columns. 
        :type columns: int
        :return: The client data
        """
        extra_params = {'take': take} if take else {}
        return _me_api._client_table(self, GET, _columns=str(columns), extra_params=extra_params)

    
    def aps(self, take: int=1000) -> dict:
        """Returns the list of access points

        :param take: The maximum number of items to return
        :type take: int
        :return: The access point data
        """
        extra_params = {'take': take} if take else {}
        return _me_api._aps(self, GET, extra_params=extra_params)


    def aps_data(self, take: int=1000) -> dict:
        """Returns the detailed information about access points

        :param take: The maximum number of items to return
        :type take: int
        :return: The access point data
        """
        extra_params = {'take': take} if take else {}
        return _me_api._apdata(self, GET, extra_params=extra_params)

    
    def client_connection_score(self) -> dict:
        """Returns the table of client connection scores grouped by range

        :return: The connection score data
        """
        return _me_api._client_connection_score(self, GET)

    
    def client_connection_speed(self) -> dict:
        """Returns the table of client connection speeds grouped by range

        :return: The connection speed data
        """
        return _me_api._client_connection_speed(self, GET)

    
    def blink_ap_led(self, macAddress: str) -> dict:
        """ Blink the  AP LED

        :param macAddress: The MAC address of the AP of the form "aa:bb:cc:dd:ee:ff"
        :type macAddress: str
        :return: errorCode response
        """
        data = {'macAddress': macAddress, 'action': 6}
        return _me_api._spartan_apTool(self, POST, json=data)

    
    def toggle_ap_led(self, macAddress: str) -> dict:
        """ Disable or enable the AP LED

        :param macAddress: The MAC address of the AP of the form "aa:bb:cc:dd:ee:ff"
        :type macAddress: str
        :return: errorCode response
        """
        data = {'macAddress': macAddress, 'action': 5}
        return _me_api._spartan_apTool(self, POST, json=data)

    
    def restart_ap(self, macAddress: str) -> dict:
        """ Restart (reload) an AP

        :param macAddress: The MAC address of the AP of the form "aa:bb:cc:dd:ee:ff"
        :type macAddress: str
        :return: errorCode response
        """
        data = {'macAddress': macAddress, 'action': 7}
        return _me_api._spartan_apTool(self, POST, json=data)


    ###############################################################################################


def print_table(my_dict: dict, col_list: list=None):
    """ 
    Pretty print a list of dictionaries as a dynamically sized table.
    
    :param my_dict: The dictionary or list of dictionaries to print
    :type my_dict: dict
    :param col_list: The list of columns to include that correspond to keys in the dictionaryies
    :type col_list: list
    """
    # Dervied from https://stackoverflow.com/a/40389411/314051
    # Author: Thierry Husson - Use it as you want but don't blame me.
    
    if not col_list: 
        col_list = list(my_dict[0].keys() if my_dict else [])
    my_list = [col_list] # 1st row = header
    for item in my_dict: 
        my_list.append([str(item[col] if item[col] is not None else '') for col in col_list])
    col_size = [max(map(len,col)) for col in zip(*my_list)]
    format_str = ' | '.join(["{{:<{}}}".format(i) for i in col_size])
    my_list.insert(1, ['-' * i for i in col_size]) # Seperating line
    for item in my_list: 
        print(format_str.format(*item))
