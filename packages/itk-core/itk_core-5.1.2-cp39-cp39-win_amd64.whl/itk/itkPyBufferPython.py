# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKBridgeNumPyPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkPyBufferPython
else:
    import _itkPyBufferPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkPyBufferPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkPyBufferPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkVectorImagePython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkFixedArrayPython
import itk.pyBasePython
import itk.itkPointPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.vnl_matrixPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkCovariantVectorPython
import itk.itkSymmetricSecondRankTensorPython
import itk.ITKCommonBasePython
import itk.itkImageRegionPython
import itk.itkSizePython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkRGBPixelPython
import itk.itkVariableLengthVectorPython


HAVE_NUMPY = True
try:
  import numpy as np
  class NDArrayITKBase(np.ndarray):
      """A numpy array that provides a view on the data associated with an optional itk "base" object."""

      def __new__(cls, input_array, itk_base=None):
          obj = np.asarray(input_array).view(cls)
          obj.itk_base = itk_base
          return obj

      def __array_finalize__(self, obj):
          if obj is None: return
          self.itk_base = getattr(obj, 'itk_base', None)

except ImportError:
  HAVE_NUMPY = False
try:
    import numpy as np
    from distributed.protocol import dask_serialize, dask_deserialize
    from typing import Dict, List, Tuple
except ImportError:
    pass
else:
    @dask_serialize.register(NDArrayITKBase)
    def serialize(ndarray_itk_base: NDArrayITKBase) -> Tuple[Dict, List[bytes]]:
        dumps = dask_serialize.dispatch(np.ndarray)
        return dumps(ndarray_itk_base)

    @dask_deserialize.register(NDArrayITKBase)
    def deserialize(header: Dict, frames: List[bytes]) -> NDArrayITKBase:
        loads = dask_deserialize.dispatch(np.ndarray)
        return NDArrayITKBase(loads(header, frames))

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')
# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "F":np.float32,
               "D":np.float64,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

class itkPyBufferICVD22(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD22 self) -> itkPyBufferICVD22
        __init__(itkPyBufferICVD22 self, itkPyBufferICVD22 arg0) -> itkPyBufferICVD22


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD22_swigregister(itkPyBufferICVD22)
itkPyBufferICVD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD22__GetArrayViewFromImage
itkPyBufferICVD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD22__GetImageViewFromArray

class itkPyBufferICVD23(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD23 self) -> itkPyBufferICVD23
        __init__(itkPyBufferICVD23 self, itkPyBufferICVD23 arg0) -> itkPyBufferICVD23


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD23_swigregister(itkPyBufferICVD23)
itkPyBufferICVD23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD23__GetArrayViewFromImage
itkPyBufferICVD23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD23__GetImageViewFromArray

class itkPyBufferICVD32(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD32 self) -> itkPyBufferICVD32
        __init__(itkPyBufferICVD32 self, itkPyBufferICVD32 arg0) -> itkPyBufferICVD32


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD32_swigregister(itkPyBufferICVD32)
itkPyBufferICVD32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD32__GetArrayViewFromImage
itkPyBufferICVD32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD32__GetImageViewFromArray

class itkPyBufferICVD33(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD33 self) -> itkPyBufferICVD33
        __init__(itkPyBufferICVD33 self, itkPyBufferICVD33 arg0) -> itkPyBufferICVD33


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD33_swigregister(itkPyBufferICVD33)
itkPyBufferICVD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD33__GetArrayViewFromImage
itkPyBufferICVD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD33__GetImageViewFromArray

class itkPyBufferICVD42(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD42 self) -> itkPyBufferICVD42
        __init__(itkPyBufferICVD42 self, itkPyBufferICVD42 arg0) -> itkPyBufferICVD42


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD42_swigregister(itkPyBufferICVD42)
itkPyBufferICVD42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD42__GetArrayViewFromImage
itkPyBufferICVD42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD42__GetImageViewFromArray

class itkPyBufferICVD43(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVD43 self) -> itkPyBufferICVD43
        __init__(itkPyBufferICVD43 self, itkPyBufferICVD43 arg0) -> itkPyBufferICVD43


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVD43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVD43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVD43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVD43_swigregister(itkPyBufferICVD43)
itkPyBufferICVD43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVD43__GetArrayViewFromImage
itkPyBufferICVD43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVD43__GetImageViewFromArray

class itkPyBufferICVF22(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF22 self) -> itkPyBufferICVF22
        __init__(itkPyBufferICVF22 self, itkPyBufferICVF22 arg0) -> itkPyBufferICVF22


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF22_swigregister(itkPyBufferICVF22)
itkPyBufferICVF22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF22__GetArrayViewFromImage
itkPyBufferICVF22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF22__GetImageViewFromArray

class itkPyBufferICVF23(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF23 self) -> itkPyBufferICVF23
        __init__(itkPyBufferICVF23 self, itkPyBufferICVF23 arg0) -> itkPyBufferICVF23


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF23_swigregister(itkPyBufferICVF23)
itkPyBufferICVF23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF23__GetArrayViewFromImage
itkPyBufferICVF23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF23__GetImageViewFromArray

class itkPyBufferICVF32(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF32 self) -> itkPyBufferICVF32
        __init__(itkPyBufferICVF32 self, itkPyBufferICVF32 arg0) -> itkPyBufferICVF32


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF32_swigregister(itkPyBufferICVF32)
itkPyBufferICVF32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF32__GetArrayViewFromImage
itkPyBufferICVF32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF32__GetImageViewFromArray

class itkPyBufferICVF33(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF33 self) -> itkPyBufferICVF33
        __init__(itkPyBufferICVF33 self, itkPyBufferICVF33 arg0) -> itkPyBufferICVF33


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF33_swigregister(itkPyBufferICVF33)
itkPyBufferICVF33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF33__GetArrayViewFromImage
itkPyBufferICVF33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF33__GetImageViewFromArray

class itkPyBufferICVF42(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF42 self) -> itkPyBufferICVF42
        __init__(itkPyBufferICVF42 self, itkPyBufferICVF42 arg0) -> itkPyBufferICVF42


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF42_swigregister(itkPyBufferICVF42)
itkPyBufferICVF42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF42__GetArrayViewFromImage
itkPyBufferICVF42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF42__GetImageViewFromArray

class itkPyBufferICVF43(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF43 self) -> itkPyBufferICVF43
        __init__(itkPyBufferICVF43 self, itkPyBufferICVF43 arg0) -> itkPyBufferICVF43


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferICVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferICVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferICVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferICVF43_swigregister(itkPyBufferICVF43)
itkPyBufferICVF43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferICVF43__GetArrayViewFromImage
itkPyBufferICVF43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferICVF43__GetImageViewFromArray

class itkPyBufferID2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferID2 self) -> itkPyBufferID2
        __init__(itkPyBufferID2 self, itkPyBufferID2 arg0) -> itkPyBufferID2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferID2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferID2_swigregister(itkPyBufferID2)
itkPyBufferID2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferID2__GetArrayViewFromImage
itkPyBufferID2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferID2__GetImageViewFromArray

class itkPyBufferID3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferID3 self) -> itkPyBufferID3
        __init__(itkPyBufferID3 self, itkPyBufferID3 arg0) -> itkPyBufferID3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferID3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferID3_swigregister(itkPyBufferID3)
itkPyBufferID3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferID3__GetArrayViewFromImage
itkPyBufferID3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferID3__GetImageViewFromArray

class itkPyBufferIF2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIF2 self) -> itkPyBufferIF2
        __init__(itkPyBufferIF2 self, itkPyBufferIF2 arg0) -> itkPyBufferIF2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIF2_swigregister(itkPyBufferIF2)
itkPyBufferIF2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIF2__GetArrayViewFromImage
itkPyBufferIF2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIF2__GetImageViewFromArray

class itkPyBufferIF3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIF3 self) -> itkPyBufferIF3
        __init__(itkPyBufferIF3 self, itkPyBufferIF3 arg0) -> itkPyBufferIF3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIF3_swigregister(itkPyBufferIF3)
itkPyBufferIF3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIF3__GetArrayViewFromImage
itkPyBufferIF3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIF3__GetImageViewFromArray

class itkPyBufferIRGBAUC2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIRGBAUC2 self) -> itkPyBufferIRGBAUC2
        __init__(itkPyBufferIRGBAUC2 self, itkPyBufferIRGBAUC2 arg0) -> itkPyBufferIRGBAUC2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIRGBAUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBAUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBAUC2_swigregister(itkPyBufferIRGBAUC2)
itkPyBufferIRGBAUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBAUC2__GetArrayViewFromImage
itkPyBufferIRGBAUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBAUC2__GetImageViewFromArray

class itkPyBufferIRGBAUC3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIRGBAUC3 self) -> itkPyBufferIRGBAUC3
        __init__(itkPyBufferIRGBAUC3 self, itkPyBufferIRGBAUC3 arg0) -> itkPyBufferIRGBAUC3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIRGBAUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBAUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBAUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBAUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBAUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIRGBAUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBAUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBAUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBAUC3_swigregister(itkPyBufferIRGBAUC3)
itkPyBufferIRGBAUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBAUC3__GetArrayViewFromImage
itkPyBufferIRGBAUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBAUC3__GetImageViewFromArray

class itkPyBufferIRGBUC2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIRGBUC2 self) -> itkPyBufferIRGBUC2
        __init__(itkPyBufferIRGBUC2 self, itkPyBufferIRGBUC2 arg0) -> itkPyBufferIRGBUC2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIRGBUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIRGBUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBUC2_swigregister(itkPyBufferIRGBUC2)
itkPyBufferIRGBUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBUC2__GetArrayViewFromImage
itkPyBufferIRGBUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBUC2__GetImageViewFromArray

class itkPyBufferIRGBUC3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIRGBUC3 self) -> itkPyBufferIRGBUC3
        __init__(itkPyBufferIRGBUC3 self, itkPyBufferIRGBUC3 arg0) -> itkPyBufferIRGBUC3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIRGBUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIRGBUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIRGBUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIRGBUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIRGBUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIRGBUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIRGBUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIRGBUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIRGBUC3_swigregister(itkPyBufferIRGBUC3)
itkPyBufferIRGBUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIRGBUC3__GetArrayViewFromImage
itkPyBufferIRGBUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIRGBUC3__GetImageViewFromArray

class itkPyBufferISS2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferISS2 self) -> itkPyBufferISS2
        __init__(itkPyBufferISS2 self, itkPyBufferISS2 arg0) -> itkPyBufferISS2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISS2_swigregister(itkPyBufferISS2)
itkPyBufferISS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISS2__GetArrayViewFromImage
itkPyBufferISS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISS2__GetImageViewFromArray

class itkPyBufferISS3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferISS3 self) -> itkPyBufferISS3
        __init__(itkPyBufferISS3 self, itkPyBufferISS3 arg0) -> itkPyBufferISS3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISS3_swigregister(itkPyBufferISS3)
itkPyBufferISS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISS3__GetArrayViewFromImage
itkPyBufferISS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISS3__GetImageViewFromArray

class itkPyBufferISSRTD22(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferISSRTD22 self) -> itkPyBufferISSRTD22
        __init__(itkPyBufferISSRTD22 self, itkPyBufferISSRTD22 arg0) -> itkPyBufferISSRTD22


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferISSRTD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferISSRTD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTD22_swigregister(itkPyBufferISSRTD22)
itkPyBufferISSRTD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTD22__GetArrayViewFromImage
itkPyBufferISSRTD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTD22__GetImageViewFromArray

class itkPyBufferISSRTD33(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferISSRTD33 self) -> itkPyBufferISSRTD33
        __init__(itkPyBufferISSRTD33 self, itkPyBufferISSRTD33 arg0) -> itkPyBufferISSRTD33


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferISSRTD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferISSRTD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferISSRTD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferISSRTD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferISSRTD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferISSRTD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferISSRTD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferISSRTD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferISSRTD33_swigregister(itkPyBufferISSRTD33)
itkPyBufferISSRTD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferISSRTD33__GetArrayViewFromImage
itkPyBufferISSRTD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferISSRTD33__GetImageViewFromArray

class itkPyBufferIUC2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUC2 self) -> itkPyBufferIUC2
        __init__(itkPyBufferIUC2 self, itkPyBufferIUC2 arg0) -> itkPyBufferIUC2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUC2_swigregister(itkPyBufferIUC2)
itkPyBufferIUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUC2__GetArrayViewFromImage
itkPyBufferIUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUC2__GetImageViewFromArray

class itkPyBufferIUC3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUC3 self) -> itkPyBufferIUC3
        __init__(itkPyBufferIUC3 self, itkPyBufferIUC3 arg0) -> itkPyBufferIUC3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUC3_swigregister(itkPyBufferIUC3)
itkPyBufferIUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUC3__GetArrayViewFromImage
itkPyBufferIUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUC3__GetImageViewFromArray

class itkPyBufferIUL2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUL2 self) -> itkPyBufferIUL2
        __init__(itkPyBufferIUL2 self, itkPyBufferIUL2 arg0) -> itkPyBufferIUL2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUL2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUL2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUL2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUL2_swigregister(itkPyBufferIUL2)
itkPyBufferIUL2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUL2__GetArrayViewFromImage
itkPyBufferIUL2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUL2__GetImageViewFromArray

class itkPyBufferIUL3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUL3 self) -> itkPyBufferIUL3
        __init__(itkPyBufferIUL3 self, itkPyBufferIUL3 arg0) -> itkPyBufferIUL3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUL3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUL3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUL3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUL3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUL3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUL3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUL3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUL3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUL3_swigregister(itkPyBufferIUL3)
itkPyBufferIUL3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUL3__GetArrayViewFromImage
itkPyBufferIUL3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUL3__GetImageViewFromArray

class itkPyBufferIUS2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUS2 self) -> itkPyBufferIUS2
        __init__(itkPyBufferIUS2 self, itkPyBufferIUS2 arg0) -> itkPyBufferIUS2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUS2_swigregister(itkPyBufferIUS2)
itkPyBufferIUS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUS2__GetArrayViewFromImage
itkPyBufferIUS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUS2__GetImageViewFromArray

class itkPyBufferIUS3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUS3 self) -> itkPyBufferIUS3
        __init__(itkPyBufferIUS3 self, itkPyBufferIUS3 arg0) -> itkPyBufferIUS3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIUS3_swigregister(itkPyBufferIUS3)
itkPyBufferIUS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIUS3__GetArrayViewFromImage
itkPyBufferIUS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIUS3__GetImageViewFromArray

class itkPyBufferIVD22(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD22 self) -> itkPyBufferIVD22
        __init__(itkPyBufferIVD22 self, itkPyBufferIVD22 arg0) -> itkPyBufferIVD22


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD22_swigregister(itkPyBufferIVD22)
itkPyBufferIVD22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD22__GetArrayViewFromImage
itkPyBufferIVD22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD22__GetImageViewFromArray

class itkPyBufferIVD23(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD23 self) -> itkPyBufferIVD23
        __init__(itkPyBufferIVD23 self, itkPyBufferIVD23 arg0) -> itkPyBufferIVD23


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD23_swigregister(itkPyBufferIVD23)
itkPyBufferIVD23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD23__GetArrayViewFromImage
itkPyBufferIVD23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD23__GetImageViewFromArray

class itkPyBufferIVD32(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD32 self) -> itkPyBufferIVD32
        __init__(itkPyBufferIVD32 self, itkPyBufferIVD32 arg0) -> itkPyBufferIVD32


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD32_swigregister(itkPyBufferIVD32)
itkPyBufferIVD32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD32__GetArrayViewFromImage
itkPyBufferIVD32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD32__GetImageViewFromArray

class itkPyBufferIVD33(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD33 self) -> itkPyBufferIVD33
        __init__(itkPyBufferIVD33 self, itkPyBufferIVD33 arg0) -> itkPyBufferIVD33


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD33_swigregister(itkPyBufferIVD33)
itkPyBufferIVD33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD33__GetArrayViewFromImage
itkPyBufferIVD33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD33__GetImageViewFromArray

class itkPyBufferIVD42(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD42 self) -> itkPyBufferIVD42
        __init__(itkPyBufferIVD42 self, itkPyBufferIVD42 arg0) -> itkPyBufferIVD42


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD42_swigregister(itkPyBufferIVD42)
itkPyBufferIVD42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD42__GetArrayViewFromImage
itkPyBufferIVD42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD42__GetImageViewFromArray

class itkPyBufferIVD43(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVD43 self) -> itkPyBufferIVD43
        __init__(itkPyBufferIVD43 self, itkPyBufferIVD43 arg0) -> itkPyBufferIVD43


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVD43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVD43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVD43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVD43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVD43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVD43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVD43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVD43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVD43_swigregister(itkPyBufferIVD43)
itkPyBufferIVD43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVD43__GetArrayViewFromImage
itkPyBufferIVD43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVD43__GetImageViewFromArray

class itkPyBufferIVF22(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF22 self) -> itkPyBufferIVF22
        __init__(itkPyBufferIVF22 self, itkPyBufferIVF22 arg0) -> itkPyBufferIVF22


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF22_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF22(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF22


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF22._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF22.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF22._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF22.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF22 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF22_swigregister(itkPyBufferIVF22)
itkPyBufferIVF22__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF22__GetArrayViewFromImage
itkPyBufferIVF22__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF22__GetImageViewFromArray

class itkPyBufferIVF23(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF23 self) -> itkPyBufferIVF23
        __init__(itkPyBufferIVF23 self, itkPyBufferIVF23 arg0) -> itkPyBufferIVF23


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF23_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF23(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF23


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF23._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF23.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF23._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF23.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF23 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF23_swigregister(itkPyBufferIVF23)
itkPyBufferIVF23__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF23__GetArrayViewFromImage
itkPyBufferIVF23__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF23__GetImageViewFromArray

class itkPyBufferIVF32(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF32 self) -> itkPyBufferIVF32
        __init__(itkPyBufferIVF32 self, itkPyBufferIVF32 arg0) -> itkPyBufferIVF32


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF32_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF32(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF32


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF32._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF32.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF32._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF32.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF32 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF32_swigregister(itkPyBufferIVF32)
itkPyBufferIVF32__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF32__GetArrayViewFromImage
itkPyBufferIVF32__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF32__GetImageViewFromArray

class itkPyBufferIVF33(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF33 self) -> itkPyBufferIVF33
        __init__(itkPyBufferIVF33 self, itkPyBufferIVF33 arg0) -> itkPyBufferIVF33


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF33_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF33(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF33


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF33._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF33.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF33._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF33.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF33 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF33_swigregister(itkPyBufferIVF33)
itkPyBufferIVF33__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF33__GetArrayViewFromImage
itkPyBufferIVF33__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF33__GetImageViewFromArray

class itkPyBufferIVF42(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF42 self) -> itkPyBufferIVF42
        __init__(itkPyBufferIVF42 self, itkPyBufferIVF42 arg0) -> itkPyBufferIVF42


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF42_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF42(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF42


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF42._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF42.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF42._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF42.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF42 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF42_swigregister(itkPyBufferIVF42)
itkPyBufferIVF42__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF42__GetArrayViewFromImage
itkPyBufferIVF42__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF42__GetImageViewFromArray

class itkPyBufferIVF43(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF43 self) -> itkPyBufferIVF43
        __init__(itkPyBufferIVF43 self, itkPyBufferIVF43 arg0) -> itkPyBufferIVF43


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferIVF43_swiginit(self, _itkPyBufferPython.new_itkPyBufferIVF43(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferIVF43


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF43._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF43.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF43._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF43.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF43 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferIVF43_swigregister(itkPyBufferIVF43)
itkPyBufferIVF43__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferIVF43__GetArrayViewFromImage
itkPyBufferIVF43__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferIVF43__GetImageViewFromArray

class itkPyBufferVID2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVID2 self) -> itkPyBufferVID2
        __init__(itkPyBufferVID2 self, itkPyBufferVID2 arg0) -> itkPyBufferVID2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVID2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVID2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVID2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVID2_swigregister(itkPyBufferVID2)
itkPyBufferVID2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVID2__GetArrayViewFromImage
itkPyBufferVID2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVID2__GetImageViewFromArray

class itkPyBufferVID3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVID3 self) -> itkPyBufferVID3
        __init__(itkPyBufferVID3 self, itkPyBufferVID3 arg0) -> itkPyBufferVID3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVID3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVID3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVID3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVID3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVID3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVID3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVID3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVID3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVID3_swigregister(itkPyBufferVID3)
itkPyBufferVID3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVID3__GetArrayViewFromImage
itkPyBufferVID3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVID3__GetImageViewFromArray

class itkPyBufferVIF2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIF2 self) -> itkPyBufferVIF2
        __init__(itkPyBufferVIF2 self, itkPyBufferVIF2 arg0) -> itkPyBufferVIF2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIF2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIF2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIF2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIF2_swigregister(itkPyBufferVIF2)
itkPyBufferVIF2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIF2__GetArrayViewFromImage
itkPyBufferVIF2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIF2__GetImageViewFromArray

class itkPyBufferVIF3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIF3 self) -> itkPyBufferVIF3
        __init__(itkPyBufferVIF3 self, itkPyBufferVIF3 arg0) -> itkPyBufferVIF3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIF3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIF3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIF3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIF3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIF3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIF3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIF3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIF3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIF3_swigregister(itkPyBufferVIF3)
itkPyBufferVIF3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIF3__GetArrayViewFromImage
itkPyBufferVIF3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIF3__GetImageViewFromArray

class itkPyBufferVISS2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVISS2 self) -> itkPyBufferVISS2
        __init__(itkPyBufferVISS2 self, itkPyBufferVISS2 arg0) -> itkPyBufferVISS2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVISS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVISS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVISS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVISS2_swigregister(itkPyBufferVISS2)
itkPyBufferVISS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVISS2__GetArrayViewFromImage
itkPyBufferVISS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVISS2__GetImageViewFromArray

class itkPyBufferVISS3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVISS3 self) -> itkPyBufferVISS3
        __init__(itkPyBufferVISS3 self, itkPyBufferVISS3 arg0) -> itkPyBufferVISS3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVISS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVISS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVISS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVISS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVISS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVISS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVISS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVISS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVISS3_swigregister(itkPyBufferVISS3)
itkPyBufferVISS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVISS3__GetArrayViewFromImage
itkPyBufferVISS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVISS3__GetImageViewFromArray

class itkPyBufferVIUC2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIUC2 self) -> itkPyBufferVIUC2
        __init__(itkPyBufferVIUC2 self, itkPyBufferVIUC2 arg0) -> itkPyBufferVIUC2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIUC2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIUC2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUC2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUC2_swigregister(itkPyBufferVIUC2)
itkPyBufferVIUC2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUC2__GetArrayViewFromImage
itkPyBufferVIUC2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUC2__GetImageViewFromArray

class itkPyBufferVIUC3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIUC3 self) -> itkPyBufferVIUC3
        __init__(itkPyBufferVIUC3 self, itkPyBufferVIUC3 arg0) -> itkPyBufferVIUC3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIUC3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUC3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUC3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUC3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUC3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIUC3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUC3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUC3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUC3_swigregister(itkPyBufferVIUC3)
itkPyBufferVIUC3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUC3__GetArrayViewFromImage
itkPyBufferVIUC3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUC3__GetImageViewFromArray

class itkPyBufferVIUS2(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIUS2 self) -> itkPyBufferVIUS2
        __init__(itkPyBufferVIUS2 self, itkPyBufferVIUS2 arg0) -> itkPyBufferVIUS2


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIUS2_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS2(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS2


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS2._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS2.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIUS2._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS2.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUS2 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUS2_swigregister(itkPyBufferVIUS2)
itkPyBufferVIUS2__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUS2__GetArrayViewFromImage
itkPyBufferVIUS2__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUS2__GetImageViewFromArray

class itkPyBufferVIUS3(object):
    r"""


    Helper class to get ITK image views into python arrays and back.

    This class will receive a C buffer and create the equivalent python
    array view. This permits passing image buffers into python arrays from
    the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferVIUS3 self) -> itkPyBufferVIUS3
        __init__(itkPyBufferVIUS3 self, itkPyBufferVIUS3 arg0) -> itkPyBufferVIUS3


        Helper class to get ITK image views into python arrays and back.

        This class will receive a C buffer and create the equivalent python
        array view. This permits passing image buffers into python arrays from
        the NumPy python package. 
        """
        _itkPyBufferPython.itkPyBufferVIUS3_swiginit(self, _itkPyBufferPython.new_itkPyBufferVIUS3(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyBufferVIUS3


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferVIUS3._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferVIUS3.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferVIUS3._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferVIUS3.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferVIUS3 in _itkPyBufferPython:
_itkPyBufferPython.itkPyBufferVIUS3_swigregister(itkPyBufferVIUS3)
itkPyBufferVIUS3__GetArrayViewFromImage = _itkPyBufferPython.itkPyBufferVIUS3__GetArrayViewFromImage
itkPyBufferVIUS3__GetImageViewFromArray = _itkPyBufferPython.itkPyBufferVIUS3__GetImageViewFromArray

class itkPyVnlD(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlD self) -> itkPyVnlD
        __init__(itkPyVnlD self, itkPyVnlD arg0) -> itkPyVnlD


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlD_swiginit(self, _itkPyBufferPython.new_itkPyVnlD(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlD


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlD._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlD._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlD.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlD._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlD in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlD_swigregister(itkPyVnlD)
itkPyVnlD__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlVector
itkPyVnlD__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlD__GetVnlVectorFromArray
itkPyVnlD__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlD__GetArrayViewFromVnlMatrix
itkPyVnlD__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlD__GetVnlMatrixFromArray

class itkPyVnlF(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlF self) -> itkPyVnlF
        __init__(itkPyVnlF self, itkPyVnlF arg0) -> itkPyVnlF


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlF_swiginit(self, _itkPyBufferPython.new_itkPyVnlF(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlF


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlF._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlF._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlF.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlF._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlF in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlF_swigregister(itkPyVnlF)
itkPyVnlF__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlVector
itkPyVnlF__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlF__GetVnlVectorFromArray
itkPyVnlF__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlF__GetArrayViewFromVnlMatrix
itkPyVnlF__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlF__GetVnlMatrixFromArray

class itkPyVnlSC(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlSC self) -> itkPyVnlSC
        __init__(itkPyVnlSC self, itkPyVnlSC arg0) -> itkPyVnlSC


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlSC_swiginit(self, _itkPyBufferPython.new_itkPyVnlSC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSC in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSC_swigregister(itkPyVnlSC)
itkPyVnlSC__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlVector
itkPyVnlSC__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSC__GetVnlVectorFromArray
itkPyVnlSC__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSC__GetArrayViewFromVnlMatrix
itkPyVnlSC__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSC__GetVnlMatrixFromArray

class itkPyVnlSI(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlSI self) -> itkPyVnlSI
        __init__(itkPyVnlSI self, itkPyVnlSI arg0) -> itkPyVnlSI


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlSI_swiginit(self, _itkPyBufferPython.new_itkPyVnlSI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSI in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSI_swigregister(itkPyVnlSI)
itkPyVnlSI__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlVector
itkPyVnlSI__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSI__GetVnlVectorFromArray
itkPyVnlSI__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSI__GetArrayViewFromVnlMatrix
itkPyVnlSI__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSI__GetVnlMatrixFromArray

class itkPyVnlSL(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlSL self) -> itkPyVnlSL
        __init__(itkPyVnlSL self, itkPyVnlSL arg0) -> itkPyVnlSL


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlSL_swiginit(self, _itkPyBufferPython.new_itkPyVnlSL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSL_swigregister(itkPyVnlSL)
itkPyVnlSL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlVector
itkPyVnlSL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSL__GetVnlVectorFromArray
itkPyVnlSL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSL__GetArrayViewFromVnlMatrix
itkPyVnlSL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSL__GetVnlMatrixFromArray

class itkPyVnlSS(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlSS self) -> itkPyVnlSS
        __init__(itkPyVnlSS self, itkPyVnlSS arg0) -> itkPyVnlSS


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlSS_swiginit(self, _itkPyBufferPython.new_itkPyVnlSS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlSS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlSS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "SS"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlSS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlSS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlSS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlSS in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlSS_swigregister(itkPyVnlSS)
itkPyVnlSS__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlVector
itkPyVnlSS__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlSS__GetVnlVectorFromArray
itkPyVnlSS__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlSS__GetArrayViewFromVnlMatrix
itkPyVnlSS__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlSS__GetVnlMatrixFromArray

class itkPyVnlUC(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlUC self) -> itkPyVnlUC
        __init__(itkPyVnlUC self, itkPyVnlUC arg0) -> itkPyVnlUC


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlUC_swiginit(self, _itkPyBufferPython.new_itkPyVnlUC(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUC


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUC._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUC._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUC.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUC._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUC in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUC_swigregister(itkPyVnlUC)
itkPyVnlUC__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlVector
itkPyVnlUC__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUC__GetVnlVectorFromArray
itkPyVnlUC__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUC__GetArrayViewFromVnlMatrix
itkPyVnlUC__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUC__GetVnlMatrixFromArray

class itkPyVnlUI(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlUI self) -> itkPyVnlUI
        __init__(itkPyVnlUI self, itkPyVnlUI arg0) -> itkPyVnlUI


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlUI_swiginit(self, _itkPyBufferPython.new_itkPyVnlUI(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUI


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUI._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UI"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUI._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUI.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUI._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUI in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUI_swigregister(itkPyVnlUI)
itkPyVnlUI__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlVector
itkPyVnlUI__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUI__GetVnlVectorFromArray
itkPyVnlUI__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUI__GetArrayViewFromVnlMatrix
itkPyVnlUI__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUI__GetVnlMatrixFromArray

class itkPyVnlUL(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlUL self) -> itkPyVnlUL
        __init__(itkPyVnlUL self, itkPyVnlUL arg0) -> itkPyVnlUL


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlUL_swiginit(self, _itkPyBufferPython.new_itkPyVnlUL(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUL


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUL._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "UL"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUL._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUL.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUL._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUL in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUL_swigregister(itkPyVnlUL)
itkPyVnlUL__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlVector
itkPyVnlUL__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUL__GetVnlVectorFromArray
itkPyVnlUL__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUL__GetArrayViewFromVnlMatrix
itkPyVnlUL__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUL__GetVnlMatrixFromArray

class itkPyVnlUS(object):
    r"""


    Helper class get views of VNL data buffers in python arrays and back.

    This class will either receive a VNL data structure and create the
    equivalent Python array view or will receive a Python array and create
    a copy of it in a VNL data structure. This permits passing VNL data
    structures into python arrays from the NumPy python package. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromVnlVector = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector)
    _GetVnlVectorFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray)
    _GetArrayViewFromVnlMatrix = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix)
    _GetVnlMatrixFromArray = _swig_new_static_method(_itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyVnlUS self) -> itkPyVnlUS
        __init__(itkPyVnlUS self, itkPyVnlUS arg0) -> itkPyVnlUS


        Helper class get views of VNL data buffers in python arrays and back.

        This class will either receive a VNL data structure and create the
        equivalent Python array view or will receive a Python array and create
        a copy of it in a VNL data structure. This permits passing VNL data
        structures into python arrays from the NumPy python package. 
        """
        _itkPyBufferPython.itkPyVnlUS_swiginit(self, _itkPyBufferPython.new_itkPyVnlUS(*args))
    __swig_destroy__ = _itkPyBufferPython.delete_itkPyVnlUS


    def GetArrayViewFromVnlVector(vnl_vector):
        """Get a NumPy array view of a VNL vector."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        itksize = vnl_vector.size()
        shape   = [itksize]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlVector(vnl_vector)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, vnl_vector)

        return itk_view

    GetArrayViewFromVnlVector = staticmethod(GetArrayViewFromVnlVector)

    def GetArrayFromVnlVector(vnl_vector):
        """Get a NumPy ndarray from VNL Vector.

        This is a deep copy of the VNL vector and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlVector(vnl_vector)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlVector = staticmethod(GetArrayFromVnlVector)

    def GetVnlVectorFromArray(ndarr):
        """Get a VNL vector from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.  It is not possible to have a view of a numpy array in a VNL vector since
        there is no VNL vector constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 1 , \
            "Only arrays of 1 dimension are supported."

        ndarr = np.ascontiguousarray(ndarr)
        vec = itkPyVnlUS._GetVnlVectorFromArray( ndarr, ndarr.shape)

        return vec

    GetVnlVectorFromArray = staticmethod(GetVnlVectorFromArray)

    def GetArrayViewFromVnlMatrix(vnl_matrix):
        """Get a NumPy array view of a VNL matrix."""

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        cols = vnl_matrix.columns()
        rows = vnl_matrix.rows()
        dim     = 2
        shape   = [rows,cols]

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyVnlUS._GetArrayViewFromVnlMatrix(vnl_matrix)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)

        itk_view = NDArrayITKBase(ndarr_view, vnl_matrix)

        return itk_view

    GetArrayViewFromVnlMatrix = staticmethod(GetArrayViewFromVnlMatrix)

    def GetArrayFromVnlMatrix(vnl_matrix):
        """Get a NumPy ndarray from VNL matrix.

        This is a deep copy of the VNL matrix and is completely safe and without potential side effects.
        """

        arrayView = itkPyVnlUS.GetArrayViewFromVnlMatrix(vnl_matrix)

    # perform deep copy of the buffer
        return np.array(arrayView, copy=True)

    GetArrayFromVnlMatrix = staticmethod(GetArrayFromVnlMatrix)


    def GetVnlMatrixFromArray(ndarr):
        """Get a VNL Matrix from a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects. It is not possible to have a view of a numpy array in a VNL matrix since there is no
        VNL matrix constructor that allows sharing data.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim == 2 , \
            "Only arrays of 2 dimensions are supported."

        ndarr = np.ascontiguousarray(ndarr)
        mat = itkPyVnlUS._GetVnlMatrixFromArray( ndarr, ndarr.shape)

        return mat

    GetVnlMatrixFromArray = staticmethod(GetVnlMatrixFromArray)



# Register itkPyVnlUS in _itkPyBufferPython:
_itkPyBufferPython.itkPyVnlUS_swigregister(itkPyVnlUS)
itkPyVnlUS__GetArrayViewFromVnlVector = _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlVector
itkPyVnlUS__GetVnlVectorFromArray = _itkPyBufferPython.itkPyVnlUS__GetVnlVectorFromArray
itkPyVnlUS__GetArrayViewFromVnlMatrix = _itkPyBufferPython.itkPyVnlUS__GetArrayViewFromVnlMatrix
itkPyVnlUS__GetVnlMatrixFromArray = _itkPyBufferPython.itkPyVnlUS__GetVnlMatrixFromArray



