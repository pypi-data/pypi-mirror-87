from numbers import Integral
from functools import partial

import astropy.units as u
import gwcs
import gwcs.coordinate_frames as cf
import numpy as np
from astropy.coordinates import SkyCoord
from astropy.modeling import models
from astropy.modeling.models import tabular_model
from astropy.time import Time
from astropy.wcs.wcsapi.wrappers.sliced_wcs import sanitize_slices

__all__ = ['LookupTableCoord']


class LookupTableCoord:
    """
    A class representing world coordinates described by a lookup table.

    This class takes an input in the form of a lookup table (can be many
    different array-like types) and holds the building blocks (transform and
    frame) to generate a `gwcs.WCS` object.

    This can be used as a way to generate gWCS objects based on lookup tables,
    however, it lacks some of the flexibility of doing this manually.

    Parameters
    ----------
    lookup_tables : `object`
        The lookup tables. If more than one lookup table is specified, it
        should represent one physical coordinate type, i.e "spatial". They must
        all be the same type, shape and unit.
    mesh: `bool`
        If `True` treat the inputs as coordinate vectors per axis. Has the
        equivalent effect of passing the inputs to `numpy.meshgrid` but without
        generating the arrays.
    names: iterable of `str`, optional
        The world coordinate names to be passed to the `gwcs` coordinate frame.
    physical_types: iterable of `str`, optional
        The world axis physical types, to be passed to the gWCS frames. This
        can be used to override the defaults generated by `gwcs`.

    Attributes
    ----------
    delayed_models: `list` of `.DelayedLookupTable`
        A list of all the lookup tables contained by this object.
    frames: `list` of `gwcs.coordinate_frames.CoordinateFrame`
        A list of all the gwcs coordinate frame objects corresponding to the
        lookup tables.

    Notes
    -----

    The constructor to this class expects a single coordinate to be passed,
    i.e. one coordinate frame (e.g. Celestial), although this coordinate could be built
    from multiple lookup tables.

    The implementation of this class, however, allows the representation of
    many coordinate frames in a single instance. This is primarily to allow the
    ``&`` operator to work between instances of this class, and therefore build
    up a multi-dimensional WCS object.

    If you wish to build a multi-dimensional `.LookupTableCoord` the correct
    approach is to construct two instances and then join them into a new
    combined instance with the ``&`` operator.
    """

    def __init__(self, *lookup_tables, mesh=True, names=None, physical_types=None):
        self.delayed_models = []
        self.frames = []

        if lookup_tables:
            lt0 = lookup_tables[0]
            if not all(isinstance(lt, type(lt0)) for lt in lookup_tables):
                raise TypeError("All lookup tables must be the same type")

            type_map = {
                u.Quantity: self._from_quantity,
                Time: self._from_time,
                SkyCoord: self._from_skycoord
            }
            delayed_model, frame = type_map[type(lt0)](lookup_tables,
                                                       mesh=mesh,
                                                       names=names,
                                                       physical_types=physical_types)
            self.delayed_models = [delayed_model]
            self.frames = [frame]

    def __str__(self):
        return f"frames={self.frames} delayed_models={self.delayed_models}"

    def __repr__(self):
        return f"{object.__repr__(self)}\n{self}"

    def __and__(self, other):
        if not isinstance(other, LookupTableCoord):
            raise TypeError(
                "Can only concatenate LookupTableCoord objects with other LookupTableCoord objects.")

        new_lutc = type(self)()
        new_lutc.delayed_models = self.delayed_models + other.delayed_models
        new_lutc.frames = self.frames + other.frames

        # We must now re-index the frames so that they align with the composite frame
        ind = 0
        for f in new_lutc.frames:
            new_ind = ind + f.naxes
            f._axes_order = tuple(range(ind, new_ind))
            ind = new_ind

        return new_lutc

    def __getitem__(self, item):
        """
        Apply a given slice to all the lookup tables stored in this object.

        If no lookup tables remain after slicing `None` is returned.
        """
        item = sanitize_slices(item, self.model.n_inputs)

        ind = 0
        new_dmodels = []
        new_frames = []
        for dmodel, frame in zip(self.delayed_models, self.frames):
            # We have to instantiate the actual model to know how many inputs
            # it has, as the lookup table to model conversion is an arbitrary
            # function.
            model = dmodel()
            n_axes = model.n_inputs

            # Extract the parts of the slice that correspond to this model
            sub_items = tuple(item[i] for i in range(ind, ind + n_axes))
            ind += n_axes

            # If all the slice elements are ints then we are dropping this model
            if not all(isinstance(it, Integral) for it in sub_items):
                new_dmodels.append(dmodel[sub_items])
                new_frames.append(frame)

        if not new_dmodels:
            return

        # Return a new instance with the smaller tables
        new_lutc = type(self)()
        new_lutc.delayed_models = new_dmodels
        new_lutc.frames = new_frames
        return new_lutc

    @property
    def model(self):
        model = self.delayed_models[0]()
        for m2 in self.delayed_models[1:]:
            model = model & m2()
        return model

    @property
    def frame(self):
        if len(self.frames) == 1:
            return self.frames[0]
        else:
            return cf.CompositeFrame(self.frames)

    @property
    def wcs(self):
        return gwcs.WCS(forward_transform=self.model,
                        input_frame=self._generate_generic_frame(self.model.n_inputs, u.pix),
                        output_frame=self.frame)

    @staticmethod
    def generate_tabular(lookup_table, interpolation='linear', points_unit=u.pix, **kwargs):
        """
        Generate a Tabular model class and instance.
        """
        if not isinstance(lookup_table, u.Quantity):
            raise TypeError("lookup_table must be a Quantity.")  # pragma: no cover

        ndim = lookup_table.ndim
        TabularND = tabular_model(ndim, name=f"Tabular{ndim}D")

        # The integer location is at the centre of the pixel.
        points = [(np.arange(size) - 0) * points_unit for size in lookup_table.shape]
        if len(points) == 1:
            points = points[0]

        kwargs = {
            'bounds_error': False,
            'fill_value': np.nan,
            'method': interpolation,
            **kwargs
        }

        t = TabularND(points, lookup_table, **kwargs)

        # TODO: Remove this when there is a new gWCS release
        # Work around https://github.com/spacetelescope/gwcs/pull/331
        t.bounding_box = None

        return t

    @classmethod
    def _generate_compound_model(cls, *lookup_tables, mesh=True):
        """
        Takes a set of quantities and returns a ND compound model.
        """
        model = cls.generate_tabular(lookup_tables[0])
        for lt in lookup_tables[1:]:
            model = model & cls.generate_tabular(lt)

        if mesh:
            return model

        # If we are not meshing the inputs duplicate the inputs across all models
        mapping = list(range(lookup_tables[0].ndim)) * len(lookup_tables)
        return models.Mapping(mapping) | model

    @staticmethod
    def _generate_generic_frame(naxes, unit, names=None, physical_types=None):
        """
        Generate a simple frame, where all axes have the same type and unit.
        """
        axes_order = tuple(range(naxes))

        name = None
        axes_type = "CUSTOM"

        if isinstance(unit, (u.Unit, u.IrreducibleUnit, u.CompositeUnit)):
            unit = tuple([unit] * naxes)

        if all([u.m.is_equivalent(un) for un in unit]):
            axes_type = "SPATIAL"

        if all([u.pix.is_equivalent(un) for un in unit]):
            name = "PixelFrame"
            axes_type = "PIXEL"

        axes_type = tuple([axes_type] * naxes)

        return cf.CoordinateFrame(naxes, axes_type, axes_order, unit=unit,
                                  axes_names=names, name=name, axis_physical_types=physical_types)

    def _from_time(self, lookup_tables, mesh=False, names=None, physical_types=None, **kwargs):
        if len(lookup_tables) > 1:
            raise ValueError("Can only parse one time lookup table.")

        time = lookup_tables[0]
        deltas = (time[1:] - time[0]).to(u.s)
        deltas = deltas.insert(0, 0 * u.s)

        def _generate_time_lookup(deltas):
            return self._model_from_quantity((deltas,))

        frame = cf.TemporalFrame(lookup_tables[0][0], unit=u.s, axes_names=names, name="TemporalFrame")
        return DelayedLookupTable(deltas, _generate_time_lookup, mesh), frame

    def _from_skycoord(self, lookup_tables, mesh=False, names=None, physical_types=None, **kwargs):
        if len(lookup_tables) > 1:
            raise ValueError("Can only parse one SkyCoord lookup table.")

        def _generate_skycoord_lookup(components):
            return self._model_from_quantity(components, mesh=mesh)

        sc = lookup_tables[0]
        components = tuple(getattr(sc.data, comp) for comp in sc.data.components)
        ref_frame = sc.frame.replicate_without_data()
        units = list(c.unit for c in components)

        if names and len(names) != 2:
            names = None

        # TODO: Currently this limits you to 2D due to gwcs#120
        frame = cf.CelestialFrame(reference_frame=ref_frame,
                                  unit=units,
                                  axes_names=names,
                                  axis_physical_types=physical_types,
                                  name="CelestialFrame")

        return DelayedLookupTable(components, _generate_skycoord_lookup, mesh), frame

    def _model_from_quantity(self, lookup_tables, mesh=False):
        if len(lookup_tables) > 1:
            return self._generate_compound_model(*lookup_tables, mesh=mesh)

        return self.generate_tabular(lookup_tables[0])

    def _from_quantity(self, lookup_tables, mesh=False, names=None, physical_types=None):
        if not all(lt.unit.is_equivalent(lookup_tables[0].unit) for lt in lookup_tables):
            raise u.UnitsError("All lookup tables must have equivalent units.")

        unit = u.Quantity(lookup_tables).unit

        frame = self._generate_generic_frame(len(lookup_tables), unit, names, physical_types)

        return DelayedLookupTable(lookup_tables, partial(self._model_from_quantity, mesh=mesh), mesh), frame


class DelayedLookupTable:
    """
    A wrapper to create a lookup table model on demand.
    """

    def __init__(self, lookup_table, model_function, mesh=True):
        self.lookup_table = lookup_table
        self.model_function = model_function
        self.mesh = mesh

    def __call__(self):
        return self.model_function(self.lookup_table)

    def __getitem__(self, item):
        if isinstance(self.lookup_table, tuple):
            if self.mesh:
                assert len(item) == len(self.lookup_table)
                newlt = tuple(lt[sub_item] for lt, sub_item in zip(self.lookup_table, item))
            else:
                newlt = tuple(lt[item] for lt in self.lookup_table)
        else:
            newlt = self.lookup_table[item]

        return type(self)(newlt, self.model_function)

    def __str__(self):
        return f"DelayedLookupTable(lookup_table={self.lookup_table}"

    def __repr__(self):
        return f"{object.__repr__(self)}\n{str(self)}"
