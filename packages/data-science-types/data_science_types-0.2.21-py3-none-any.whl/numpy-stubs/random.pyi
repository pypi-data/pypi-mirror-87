from typing import Iterable, List, Optional, Sequence, Tuple, TypeVar, Union, overload

from . import (
    _ArrayLike,
    _DType,
    _Float,
    _FloatLike,
    _Int,
    _IntLike,
    _ShapeType,
    float64,
    int64,
    ndarray,
)

_T = TypeVar("_T")
@overload
def binomial(n: _IntLike, p: _FloatLike) -> _Int: ...
@overload
def binomial(n: _IntLike, p: _FloatLike, size: _IntLike) -> ndarray[_Int]: ...
@overload
def binomial(n: _IntLike, p: _ArrayLike[_Float], size: ndarray[_Int] = ...) -> ndarray[_Int]: ...
@overload
def binomial(n: _ArrayLike[_Int], p: _FloatLike, size: ndarray[_Int] = ...) -> ndarray[_Int]: ...
@overload
def binomial(
    n: _ArrayLike[_Int], p: _ArrayLike[_Float], size: ndarray[_Int] = ...
) -> ndarray[_Int]: ...
@overload
def choice(a: _IntLike) -> _IntLike: ...
@overload
def choice(a: _Int, size: int) -> ndarray[_Int]: ...
@overload
def choice(a: int, size: int) -> ndarray[int64]: ...
@overload
def choice(a: _IntLike, size: _IntLike, replace: bool) -> ndarray[int64]: ...
@overload
def choice(
    a: List[_T], p: Union[List[_FloatLike], ndarray[_Float]] = ..., replace: bool = ...
) -> _T: ...
@overload
def choice(
    a: range, size: _IntLike, replace: bool = ..., p: Union[List[_FloatLike], ndarray[_Float]] = ...
) -> ndarray[int64]: ...
@overload
def choice(
    a: range, *, replace: bool = ..., p: Union[List[_FloatLike], ndarray[_Float]] = ...
) -> int64: ...
@overload
def choice(
    a: ndarray[_DType],
    size: _IntLike,
    replace: bool = ...,
    p: Union[List[_FloatLike], ndarray[_Float]] = ...,
) -> ndarray[_DType]: ...
@overload
def choice(
    a: ndarray[_DType], *, replace: bool = ..., p: Union[List[_FloatLike], ndarray[_Float]] = ...
) -> _DType: ...
def dirichlet(alpha: ndarray[_DType], size: _IntLike = ...) -> ndarray[_DType]: ...
@overload
def exponential(scale: _FloatLike) -> _Float: ...
@overload
def exponential(scale: _FloatLike, size: Sequence[_IntLike]) -> ndarray[float64]: ...
@overload
def exponential(scale: Sequence[_FloatLike], size: Sequence[_IntLike]) -> ndarray[float64]: ...
def geometric(p: float, size: _IntLike) -> ndarray[float64]: ...
def get_state() -> Tuple[str, ndarray[_Int], _IntLike, _IntLike, _FloatLike]: ...
def normal(loc: float, scale: float, size: Union[int, Tuple[int, ...]]) -> ndarray[float64]: ...
@overload
def permutation(size: int) -> ndarray[int64]: ...
@overload
def permutation(size: Iterable[_DType]) -> ndarray[_DType]: ...
def rand(*args: int) -> ndarray[_Float]: ...
def randn(*args: int) -> ndarray[_Float]: ...
@overload
def randint(low: int, high: int = ...) -> int64: ...
@overload
def randint(low: int, size: Tuple[int, ...], high: int = ...) -> ndarray[int64]: ...
@overload
def randint(low: int, size: int, high: int = ...) -> ndarray[int64]: ...
def seed(s: int) -> None: ...
def set_state(state: Tuple[str, ndarray[_Int], _IntLike, _IntLike, _FloatLike]) -> None: ...
def shuffle(x: ndarray) -> None: ...
@overload
def uniform() -> float64: ...
@overload
def uniform(size: _ShapeType) -> ndarray: ...
@overload
def uniform(low: float, high: float, size: _ShapeType) -> ndarray: ...

class RandomState:
    def __init__(self, seed: int = ...): ...
    def multivariate_normal(
        self,
        mean: ndarray[_DType] = ...,
        cov: ndarray[_DType] = ...,
        size: Optional[_ShapeType] = ...,
    ) -> ndarray[_DType]: ...
    def normal(
        self,
        loc: Union[float, ndarray[_DType]] = ...,
        scale: Union[float, ndarray[_DType]] = ...,
        size: Optional[_ShapeType] = ...,
    ) -> ndarray[_DType]: ...
    def permutation(self, size: int) -> ndarray[int64]: ...
    def shuffle(self, x: ndarray) -> None: ...
    def uniform(self, size: _ShapeType) -> ndarray: ...
    @overload
    def choice(self, a: _IntLike) -> _IntLike: ...
    @overload
    def choice(self, a: _Int, size: int) -> ndarray[_Int]: ...
    @overload
    def choice(self, a: int, size: int) -> ndarray[int64]: ...
    @overload
    def choice(self, a: _IntLike, size: _IntLike, replace: bool) -> ndarray[int64]: ...
    @overload
    def choice(
        self, a: List[_T], p: Union[List[_FloatLike], ndarray[_Float]] = ..., replace: bool = ...
    ) -> _T: ...
    @overload
    def choice(
        self,
        a: range,
        size: _IntLike,
        replace: bool = ...,
        p: Union[List[_FloatLike], ndarray[_Float]] = ...,
    ) -> ndarray[int64]: ...
    @overload
    def choice(
        self, a: range, *, replace: bool = ..., p: Union[List[_FloatLike], ndarray[_Float]] = ...
    ) -> int64: ...
    @overload
    def choice(
        self,
        a: ndarray[_DType],
        size: _IntLike,
        replace: bool = ...,
        p: Union[List[_FloatLike], ndarray[_Float]] = ...,
    ) -> ndarray[_DType]: ...
    @overload
    def choice(
        self,
        a: ndarray[_DType],
        *,
        replace: bool = ...,
        p: Union[List[_FloatLike], ndarray[_Float]] = ...,
    ) -> _DType: ...
