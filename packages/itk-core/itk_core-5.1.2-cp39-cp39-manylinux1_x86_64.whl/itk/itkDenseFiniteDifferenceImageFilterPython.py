# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKFiniteDifferencePython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkDenseFiniteDifferenceImageFilterPython
else:
    import _itkDenseFiniteDifferenceImageFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkDenseFiniteDifferenceImageFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkDenseFiniteDifferenceImageFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkImageRegionPython
import itk.itkIndexPython
import itk.itkSizePython
import itk.pyBasePython
import itk.itkOffsetPython
import itk.ITKCommonBasePython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkFixedArrayPython
import itk.itkCovariantVectorPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkRGBPixelPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkFiniteDifferenceImageFilterPython
import itk.itkInPlaceImageFilterAPython
import itk.itkImageToImageFilterAPython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython
import itk.itkImageSourcePython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterCommonPython
import itk.itkImageToImageFilterBPython
import itk.itkFiniteDifferenceFunctionPython
class itkDenseFiniteDifferenceImageFilterICVF22ICVF22(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF22ICVF22
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF22ICVF22 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_swigregister(itkDenseFiniteDifferenceImageFilterICVF22ICVF22)
itkDenseFiniteDifferenceImageFilterICVF22ICVF22_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF22ICVF22_cast

class itkDenseFiniteDifferenceImageFilterICVF23ICVF23(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF23ICVF23
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF23ICVF23 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_swigregister(itkDenseFiniteDifferenceImageFilterICVF23ICVF23)
itkDenseFiniteDifferenceImageFilterICVF23ICVF23_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF23ICVF23_cast

class itkDenseFiniteDifferenceImageFilterICVF32ICVF32(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF32ICVF32
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF32ICVF32 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_swigregister(itkDenseFiniteDifferenceImageFilterICVF32ICVF32)
itkDenseFiniteDifferenceImageFilterICVF32ICVF32_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF32ICVF32_cast

class itkDenseFiniteDifferenceImageFilterICVF33ICVF33(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF33ICVF33
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF33ICVF33 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_swigregister(itkDenseFiniteDifferenceImageFilterICVF33ICVF33)
itkDenseFiniteDifferenceImageFilterICVF33ICVF33_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF33ICVF33_cast

class itkDenseFiniteDifferenceImageFilterICVF42ICVF42(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF42ICVF42
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF42ICVF42 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_swigregister(itkDenseFiniteDifferenceImageFilterICVF42ICVF42)
itkDenseFiniteDifferenceImageFilterICVF42ICVF42_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF42ICVF42_cast

class itkDenseFiniteDifferenceImageFilterICVF43ICVF43(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterICVF43ICVF43
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_cast)

# Register itkDenseFiniteDifferenceImageFilterICVF43ICVF43 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_swigregister(itkDenseFiniteDifferenceImageFilterICVF43ICVF43)
itkDenseFiniteDifferenceImageFilterICVF43ICVF43_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterICVF43ICVF43_cast

class itkDenseFiniteDifferenceImageFilterID2ID2(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterID2ID2
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_cast)

# Register itkDenseFiniteDifferenceImageFilterID2ID2 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_swigregister(itkDenseFiniteDifferenceImageFilterID2ID2)
itkDenseFiniteDifferenceImageFilterID2ID2_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID2ID2_cast

class itkDenseFiniteDifferenceImageFilterID3ID3(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterID3ID3
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_cast)

# Register itkDenseFiniteDifferenceImageFilterID3ID3 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_swigregister(itkDenseFiniteDifferenceImageFilterID3ID3)
itkDenseFiniteDifferenceImageFilterID3ID3_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterID3ID3_cast

class itkDenseFiniteDifferenceImageFilterIF2IF2(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIF2IF2
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_cast)

# Register itkDenseFiniteDifferenceImageFilterIF2IF2 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_swigregister(itkDenseFiniteDifferenceImageFilterIF2IF2)
itkDenseFiniteDifferenceImageFilterIF2IF2_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF2IF2_cast

class itkDenseFiniteDifferenceImageFilterIF3IF3(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIF3IF3
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_cast)

# Register itkDenseFiniteDifferenceImageFilterIF3IF3 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_swigregister(itkDenseFiniteDifferenceImageFilterIF3IF3)
itkDenseFiniteDifferenceImageFilterIF3IF3_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIF3IF3_cast

class itkDenseFiniteDifferenceImageFilterIVF22IVF22(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF22IVF22
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF22IVF22 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_swigregister(itkDenseFiniteDifferenceImageFilterIVF22IVF22)
itkDenseFiniteDifferenceImageFilterIVF22IVF22_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF22IVF22_cast

class itkDenseFiniteDifferenceImageFilterIVF23IVF23(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF23IVF23
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF23IVF23 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_swigregister(itkDenseFiniteDifferenceImageFilterIVF23IVF23)
itkDenseFiniteDifferenceImageFilterIVF23IVF23_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF23IVF23_cast

class itkDenseFiniteDifferenceImageFilterIVF32IVF32(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF32IVF32
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF32IVF32 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_swigregister(itkDenseFiniteDifferenceImageFilterIVF32IVF32)
itkDenseFiniteDifferenceImageFilterIVF32IVF32_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF32IVF32_cast

class itkDenseFiniteDifferenceImageFilterIVF33IVF33(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF33IVF33
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF33IVF33 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_swigregister(itkDenseFiniteDifferenceImageFilterIVF33IVF33)
itkDenseFiniteDifferenceImageFilterIVF33IVF33_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF33IVF33_cast

class itkDenseFiniteDifferenceImageFilterIVF42IVF42(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF42IVF42
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF42IVF42 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_swigregister(itkDenseFiniteDifferenceImageFilterIVF42IVF42)
itkDenseFiniteDifferenceImageFilterIVF42IVF42_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF42IVF42_cast

class itkDenseFiniteDifferenceImageFilterIVF43IVF43(itk.itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43):
    r"""


    This filter implements a layer of the finite difference solver
    hierarchy that performs "dense" iteration, ie. iteration over all
    pixels in the input and output at each change calculation and update
    step. Dense iteration is in contrast to a "sparse" iteration over a
    subset of the pixels. See documentation for
    FiniteDifferenceImageFilter for an overview of the iterative finite
    difference algorithm:

    $u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t$

    The generic code for performing iterations and updates at each time
    step is inherited from the parent class. This class defines an update
    buffer for $ \\Delta $ and the methods CalculateChange() and
    ApplyUpdate(). These methods are designed to automatically thread
    their execution. $ \\Delta $ is defined as an image of identical
    size and type as the output image.

    As we descend through each layer in the hierarchy, we know more and
    more about the specific application of our filter. At this level, we
    have committed to iteration over each pixel in an image. We take
    advantage of that knowledge to multithread the iteration and update
    methods. Inputs and Outputs This is an image to image filter. The
    specific types of the images are not fixed at this level in the
    hierarchy. How to use this class This filter is only one layer in a
    branch the finite difference solver hierarchy. It does not define the
    function used in the CalculateChange() and it does not define the
    stopping criteria (Halt method). To use this class, subclass it to a
    specific instance that supplies a function and Halt() method.

    See:   FiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    OutputTimesDoubleCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_OutputTimesDoubleCheck
    
    OutputAdditiveOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_OutputAdditiveOperatorsCheck
    
    OutputAdditiveAndAssignOperatorsCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_OutputAdditiveAndAssignOperatorsCheck
    
    InputConvertibleToOutputCheck = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_InputConvertibleToOutputCheck
    
    __swig_destroy__ = _itkDenseFiniteDifferenceImageFilterPython.delete_itkDenseFiniteDifferenceImageFilterIVF43IVF43
    cast = _swig_new_static_method(_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_cast)

# Register itkDenseFiniteDifferenceImageFilterIVF43IVF43 in _itkDenseFiniteDifferenceImageFilterPython:
_itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_swigregister(itkDenseFiniteDifferenceImageFilterIVF43IVF43)
itkDenseFiniteDifferenceImageFilterIVF43IVF43_cast = _itkDenseFiniteDifferenceImageFilterPython.itkDenseFiniteDifferenceImageFilterIVF43IVF43_cast


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def dense_finite_difference_image_filter(*args, **kwargs):
    """Procedural interface for DenseFiniteDifferenceImageFilter"""
    import itk
    instance = itk.DenseFiniteDifferenceImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def dense_finite_difference_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.DenseFiniteDifferenceImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.DenseFiniteDifferenceImageFilter.values()[0]
    else:
        filter_object = itk.DenseFiniteDifferenceImageFilter

    dense_finite_difference_image_filter.__doc__ = filter_object.__doc__
    dense_finite_difference_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    dense_finite_difference_image_filter.__doc__ += "\n Available Keyword Arguments:\n"
    if isinstance(itk.DenseFiniteDifferenceImageFilter, itkTemplate.itkTemplate):
        dense_finite_difference_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        dense_finite_difference_image_filter.__doc__ += "\n"
        dense_finite_difference_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        dense_finite_difference_image_filter.__doc__ += "".join([
            "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
            for item in dir(filter_object)
            if item.startswith("Set")])



