# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKFiniteDifferencePython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkFiniteDifferenceImageFilterPython
else:
    import _itkFiniteDifferenceImageFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkFiniteDifferenceImageFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkFiniteDifferenceImageFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkFiniteDifferenceFunctionPython
import itk.ITKCommonBasePython
import itk.pyBasePython
import itk.itkVectorPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.vnl_matrixPython
import itk.itkFixedArrayPython
import itk.vnl_vector_refPython
import itk.itkCovariantVectorPython
import itk.itkSizePython
import itk.itkInPlaceImageFilterAPython
import itk.itkImageToImageFilterBPython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkPointPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkImageRegionPython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkRGBPixelPython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython
import itk.itkImageSourcePython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterCommonPython
import itk.itkImageToImageFilterAPython
class itkFiniteDifferenceImageFilterICVF22ICVF22(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF22ICVF22):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF22ICVF22
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_cast)

# Register itkFiniteDifferenceImageFilterICVF22ICVF22 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_swigregister(itkFiniteDifferenceImageFilterICVF22ICVF22)
itkFiniteDifferenceImageFilterICVF22ICVF22_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF22ICVF22_cast

class itkFiniteDifferenceImageFilterICVF23ICVF23(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF23ICVF23):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF23ICVF23
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_cast)

# Register itkFiniteDifferenceImageFilterICVF23ICVF23 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_swigregister(itkFiniteDifferenceImageFilterICVF23ICVF23)
itkFiniteDifferenceImageFilterICVF23ICVF23_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF23ICVF23_cast

class itkFiniteDifferenceImageFilterICVF32ICVF32(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF32ICVF32):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF32ICVF32
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_cast)

# Register itkFiniteDifferenceImageFilterICVF32ICVF32 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_swigregister(itkFiniteDifferenceImageFilterICVF32ICVF32)
itkFiniteDifferenceImageFilterICVF32ICVF32_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF32ICVF32_cast

class itkFiniteDifferenceImageFilterICVF33ICVF33(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF33ICVF33):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF33ICVF33
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_cast)

# Register itkFiniteDifferenceImageFilterICVF33ICVF33 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_swigregister(itkFiniteDifferenceImageFilterICVF33ICVF33)
itkFiniteDifferenceImageFilterICVF33ICVF33_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF33ICVF33_cast

class itkFiniteDifferenceImageFilterICVF42ICVF42(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF42ICVF42):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF42ICVF42
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_cast)

# Register itkFiniteDifferenceImageFilterICVF42ICVF42 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_swigregister(itkFiniteDifferenceImageFilterICVF42ICVF42)
itkFiniteDifferenceImageFilterICVF42ICVF42_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF42ICVF42_cast

class itkFiniteDifferenceImageFilterICVF43ICVF43(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterICVF43ICVF43):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterICVF43ICVF43
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_cast)

# Register itkFiniteDifferenceImageFilterICVF43ICVF43 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_swigregister(itkFiniteDifferenceImageFilterICVF43ICVF43)
itkFiniteDifferenceImageFilterICVF43ICVF43_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterICVF43ICVF43_cast

class itkFiniteDifferenceImageFilterID2ID2(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterID2ID2):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterID2ID2
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_cast)

# Register itkFiniteDifferenceImageFilterID2ID2 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_swigregister(itkFiniteDifferenceImageFilterID2ID2)
itkFiniteDifferenceImageFilterID2ID2_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID2ID2_cast

class itkFiniteDifferenceImageFilterID3ID3(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterID3ID3):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterID3ID3
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_cast)

# Register itkFiniteDifferenceImageFilterID3ID3 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_swigregister(itkFiniteDifferenceImageFilterID3ID3)
itkFiniteDifferenceImageFilterID3ID3_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterID3ID3_cast

class itkFiniteDifferenceImageFilterIF2IF2(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIF2IF2):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIF2IF2
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_cast)

# Register itkFiniteDifferenceImageFilterIF2IF2 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_swigregister(itkFiniteDifferenceImageFilterIF2IF2)
itkFiniteDifferenceImageFilterIF2IF2_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF2IF2_cast

class itkFiniteDifferenceImageFilterIF3IF3(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIF3IF3):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIF3IF3
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_cast)

# Register itkFiniteDifferenceImageFilterIF3IF3 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_swigregister(itkFiniteDifferenceImageFilterIF3IF3)
itkFiniteDifferenceImageFilterIF3IF3_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIF3IF3_cast

class itkFiniteDifferenceImageFilterIVF22IVF22(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF22IVF22):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF22IVF22
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_cast)

# Register itkFiniteDifferenceImageFilterIVF22IVF22 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_swigregister(itkFiniteDifferenceImageFilterIVF22IVF22)
itkFiniteDifferenceImageFilterIVF22IVF22_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF22IVF22_cast

class itkFiniteDifferenceImageFilterIVF23IVF23(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF23IVF23):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF23IVF23
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_cast)

# Register itkFiniteDifferenceImageFilterIVF23IVF23 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_swigregister(itkFiniteDifferenceImageFilterIVF23IVF23)
itkFiniteDifferenceImageFilterIVF23IVF23_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF23IVF23_cast

class itkFiniteDifferenceImageFilterIVF32IVF32(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF32IVF32):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF32IVF32
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_cast)

# Register itkFiniteDifferenceImageFilterIVF32IVF32 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_swigregister(itkFiniteDifferenceImageFilterIVF32IVF32)
itkFiniteDifferenceImageFilterIVF32IVF32_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF32IVF32_cast

class itkFiniteDifferenceImageFilterIVF33IVF33(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF33IVF33):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF33IVF33
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_cast)

# Register itkFiniteDifferenceImageFilterIVF33IVF33 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_swigregister(itkFiniteDifferenceImageFilterIVF33IVF33)
itkFiniteDifferenceImageFilterIVF33IVF33_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF33IVF33_cast

class itkFiniteDifferenceImageFilterIVF42IVF42(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF42IVF42):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF42IVF42
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_cast)

# Register itkFiniteDifferenceImageFilterIVF42IVF42 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_swigregister(itkFiniteDifferenceImageFilterIVF42IVF42)
itkFiniteDifferenceImageFilterIVF42IVF42_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF42IVF42_cast

class itkFiniteDifferenceImageFilterIVF43IVF43(itk.itkInPlaceImageFilterAPython.itkInPlaceImageFilterIVF43IVF43):
    r"""


    The Finite Difference Solver Hierarchy

    This is an overview of the Finite Difference Solver (FDS) framework.
    The FDS framework is a set of classes for creating filters to solve
    partial differential equations on images using an iterative, finite
    difference update scheme.

    The high-level algorithm implemented by the framework can be described
    by the following pseudocode.

    The following equation describes update $ n+1 $ at pixel $ i $ on
    discrete image $ u $ :  \\[
    u_{\\mathbf{i}}^{n+1}=u^n_{\\mathbf{i}}+\\Delta
    u^n_{\\mathbf{i}}\\Delta t \\]

    Component objects The FDS hierarchy is comprised of two component
    object types, variations of which are designed to be plugged together
    to create filters for different applications. At the process level are
    the "solver" objects, which are subclasses of
    FiniteDifferenceImageFilter. Solver objects are filters that take
    image inputs and produce image outputs. Solver objects require a
    FiniteDifferenceFunction object to perform the calculation at each
    image pixel during iteration. These specialized function objects are
    subclasses of FiniteDifferenceFunction. FiniteDifferenceFunction take
    a neighborhood of pixels as input (in the form of an
    itk::NeighborhoodIterator) and produce a scalar valued result.

    Filters for different applications are created by defining a function
    object to handle the numerical calculations and choosing (or creating)
    a solver object that reflects the requirements and constraints of the
    application.  For example, anisotropic diffusion filters are created
    by plugging anisotropic diffusion functions into the
    DenseFiniteDifferenceImageFilter.

    The separation between function object and solver object allows us to
    create, for example, sparse-field, dense-field, and narrow-band
    implementations of a level-set surface evolution filter can all be
    constructed by plugging the same function object into three different,
    specialized solvers.

    Creating new filters in this hierarchy The procedure for creating a
    filter within the FDS hierarchy is to identify all the virtual methods
    that need to be defined for your particular application. In the
    simplest case, a filter needs only to instantiate a specific function
    object and define some halting criteria. For more complicated
    applications, you may need to define a specialized type of iteration
    scheme or updating procedure in a higher-level solver object.

    Some simple examples are the specific subclasses of
    AnisotropicDiffusionImageFilter. The leaves of the anisotropic
    diffusion filter tree only define the function object they use for
    their particular flavor of diffusion. See
    CurvatureAnisotropicDiffusionImageFilter and
    GradientAnisotropicDiffusionImageFilter for details.
    FiniteDifferenceImageFilter This class defines the generic solver API
    at the top level of the FDS framework. FiniteDifferenceImageFilter is
    an abstract class that implements the generic, high-level algorithm
    (described above). Inputs and Outputs This filter is an ImageToImage
    filter. Depending on the specific subclass implementation, finite
    difference image filters may process a variety of image types. The
    input to the filter is the initial value of $ u $ and the output of
    the filter is the solution to the P.D.E. How to use this class
    GenerateData() relies on several virtual methods that must be defined
    by a subclass. Specifically:   AllocateUpdateBuffer()

    ApplyUpdate()

    CalculateChange()

    Halt(). To create a finite difference solver, implement a subclass to
    define these methods.

    Note that there is no fixed container type for the buffer used to hold
    the update $ \\Delta $. The container might be another image, or
    simply a list of values. AllocateUpdateBuffer is responsible for
    creating the $ \\Delta $ container. CalculateChange populates this
    buffer and ApplyUpdate adds the buffer values to the output image
    (solution). The boolean Halt() (or ThreadedHalt()) method returns a
    true value to stop iteration.

    See:   DenseFiniteDifferenceImageFilter 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetElapsedIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetElapsedIterations)
    GetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetDifferenceFunction)
    SetDifferenceFunction = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetDifferenceFunction)
    SetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetNumberOfIterations)
    GetNumberOfIterations = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetNumberOfIterations)
    SetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetUseImageSpacing)
    UseImageSpacingOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_UseImageSpacingOn)
    UseImageSpacingOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_UseImageSpacingOff)
    GetUseImageSpacing = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetUseImageSpacing)
    SetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetMaximumRMSError)
    GetMaximumRMSError = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetMaximumRMSError)
    SetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetRMSChange)
    GetRMSChange = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetRMSChange)
    SetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetManualReinitialization)
    GetManualReinitialization = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetManualReinitialization)
    ManualReinitializationOn = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_ManualReinitializationOn)
    ManualReinitializationOff = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_ManualReinitializationOff)
    SetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetIsInitialized)
    GetIsInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_GetIsInitialized)
    SetStateToUninitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetStateToUninitialized)
    SetStateToInitialized = _swig_new_instance_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_SetStateToInitialized)
    OutputPixelIsFloatingPointCheck = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_OutputPixelIsFloatingPointCheck
    
    __swig_destroy__ = _itkFiniteDifferenceImageFilterPython.delete_itkFiniteDifferenceImageFilterIVF43IVF43
    cast = _swig_new_static_method(_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_cast)

# Register itkFiniteDifferenceImageFilterIVF43IVF43 in _itkFiniteDifferenceImageFilterPython:
_itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_swigregister(itkFiniteDifferenceImageFilterIVF43IVF43)
itkFiniteDifferenceImageFilterIVF43IVF43_cast = _itkFiniteDifferenceImageFilterPython.itkFiniteDifferenceImageFilterIVF43IVF43_cast


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def finite_difference_image_filter(*args, **kwargs):
    """Procedural interface for FiniteDifferenceImageFilter"""
    import itk
    instance = itk.FiniteDifferenceImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def finite_difference_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.FiniteDifferenceImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.FiniteDifferenceImageFilter.values()[0]
    else:
        filter_object = itk.FiniteDifferenceImageFilter

    finite_difference_image_filter.__doc__ = filter_object.__doc__
    finite_difference_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    finite_difference_image_filter.__doc__ += "\n Available Keyword Arguments:\n"
    if isinstance(itk.FiniteDifferenceImageFilter, itkTemplate.itkTemplate):
        finite_difference_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        finite_difference_image_filter.__doc__ += "\n"
        finite_difference_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        finite_difference_image_filter.__doc__ += "".join([
            "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
            for item in dir(filter_object)
            if item.startswith("Set")])



