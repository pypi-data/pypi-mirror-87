import argparse
import datetime
import hashlib
import logging
import aiohttp
import asyncio  # pytype: disable=pyi-error
import requests
import urllib.parse
from functools import wraps
from typing import Any, Dict, Optional, Text

from sqlalchemy.orm import Session

from rasa.cli import utils as rasa_cli_utils
from rasa.constants import GLOBAL_USER_CONFIG_PATH
from rasa.utils import common as rasa_utils

from ragex.community.database import utils as db_utils
from ragex.community import config, utils, constants
from ragex.community.services.config_service import (
    ConfigService,
    ConfigKey,
    MissingConfigValue,
    InvalidConfigValue,
)
from ragex.community.constants import (
    CONFIG_METRICS_ENABLED,
    CONFIG_METRICS_USER,
    CONFIG_FILE_METRICS_KEY,
    CONFIG_METRICS_DATE,
    CONFIG_METRICS_WELCOME_SHOWN,
    RASA_PRODUCTION_ENVIRONMENT,
)

from ragex.community.version import __version__

logger = logging.getLogger(__name__)

# SEGMENT_ENDPOINT = "https://api.segment.io/v1/track"
SEGMENT_ENDPOINT = "http://itdev.ucesspartners.com"

METRICS_HTTP_TIMEOUT = 10  # Seconds
ENVIRONMENT_LIVE_TIMEOUT = 2  # Seconds

LOCAL_START_EVENT = "Local X Start"
SERVER_START_EVENT = "Server X Start"
METRICS_CONSENT_EVENT = "Metrics Consent"
MODEL_TRAINED_EVENT = "Model Trained"
MODEL_UPLOADED_EVENT = "Model Uploaded"
MODEL_PROMOTED_EVENT = "Model Promoted"
MESSAGE_RECEIVED_EVENT = "Message Received"
MESSAGE_ANNOTATED_EVENT = "Message Annotated"
MESSAGE_FLAGGED_EVENT = "Message Flagged"
STORY_CREATED_EVENT = "Story Created"
STATUS_EVENT = "Status"
REPOSITORY_CREATED_EVENT = "Repository Created"
GIT_CHANGES_PUSHED_EVENT = "Git Changes Pushed"
FEATURE_FLAG_UPDATED_EVENT = "Feature Flag Updated"

MESSAGE_ANNOTATED_CONVERSATIONS = "conversations"
MESSAGE_ANNOTATED_NEW_DATA = "annotate_new_data"
MESSAGE_ANNOTATED_INTERACTIVE_LEARNING = "interactive_learning"

STORY_CREATED_INTERACTIVE = "interactive"
STORY_CREATED_STORIES = "stories"


def are_metrics_enabled() -> bool:
    """Did the user consent to the metrics collection."""
    return config.metrics_collection_config.get(CONFIG_METRICS_ENABLED, False)


def metrics_id() -> Optional[Text]:
    """Random unique consistent id."""
    return config.metrics_collection_config.get(CONFIG_METRICS_USER, None)


def ensure_metrics_enabled(f):
    """Function decorator for metrics functions that only runs the decorated
    function if metrics are enabled, and if the metrics user ID is set. All
    exceptions generated by the decorated functions are catched and logged."""

    @wraps(f)
    def decorated(*args, **kwargs):
        try:
            if are_metrics_enabled() and metrics_id():
                f(*args, **kwargs)
        except Exception as e:
            logger.debug(f"Skipping metrics collection: {e}")

    return decorated


def segment_request_header(write_key: Text) -> Dict[Text, Any]:
    """Use a segment write key to create authentication headers for the segment API."""

    return {
        "Authorization": "Basic {}".format(utils.encode_base64(write_key + ":")),
        "Content-Type": "application/json",
    }


def segment_request_payload(
    distinct_id: Text,
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> Dict[Text, Any]:
    """Compose a valid payload for the segment API."""

    return {
        "userId": distinct_id,
        "event": event_name,
        "properties": properties or {},
        "context": context or {},
    }


async def _track_async(
    distinct_id: Text,
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """Sends the contents of an event to the /track Segment endpoint.
    Documentation: https://segment.com/docs/sources/server/http/

    Do not call this function from outside metrics.py! This function does not
    check if metrics are enabled or not.

    Args:
        distinct_id: Unique metrics ID.
        event_name: Name of the event.
        properties: Values to send along the event.
        context: Context information about the event.
    """

    async with aiohttp.ClientSession() as session:
        headers = segment_request_header(config.metrics_write_key)

        payload = segment_request_payload(distinct_id, event_name, properties, context)

        if utils.in_continuous_integration():
            logger.info("Skip sending metrics: running in a CI context.")
            return

        try:
            async with session.post(
                SEGMENT_ENDPOINT,
                raise_for_status=True,
                headers=headers,
                json=payload,
                timeout=METRICS_HTTP_TIMEOUT,
            ) as resp:
                data = (await resp.json()) or {}
                if not data.get("success"):
                    raise Exception(
                        f"Got an unsuccessful response from Segment: {data}"
                    )
        except Exception as e:
            logger.debug("An error ocurred when trying to send telemetry data.")
            logger.debug(f"Exception message: {e}")


def _track_internal(
    distinct_id: Text,
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """Tracks an event.

    If there's no event loop running on the current thread, `_track_internal`
    will block until the tracking HTTP request is sent. Otherwise, the task
    will be scheduled to run and the function will immediately return.

    Do not call this function from outside metrics.py! This function does not
    check if metrics are enabled or not.

    Args:
        distinct_id: Unique metrics ID.
        event_name: Name of the event.
        properties: Values to send along the event.
        context: Context information about the event.
    """

    coro = _track_async(distinct_id, event_name, properties, context)
    # get_event_loop() will create a new (unstarted) loop if the current
    # thread has no active one.
    loop = asyncio.get_event_loop()

    if loop.is_running():
        # We are being called after Sanic's loop has started.
        loop.create_task(coro)
    else:
        # We are being called before Sanic's loop has started, therefore run
        # the coroutune using run_until_complete() (this will start and stop
        # the event loop).
        loop.run_until_complete(coro)


@ensure_metrics_enabled
def track(
    event_name: Text,
    properties: Optional[Dict[Text, Any]] = None,
    context: Optional[Dict[Text, Any]] = None,
) -> None:
    """If enabled, track certain statistical metrics."""

    if properties:
        properties["metrics_id"] = metrics_id()

    _track_internal(metrics_id(), event_name, properties, context)


def track_metrics_consent(
    user_id: Text, allow_metrics: bool, auto_accept: bool = False
) -> None:
    """Track metric consent."""

    # Use _track_internal() instead of track() to bypass are_metrics_enabled() check
    try:
        _track_internal(
            user_id,
            METRICS_CONSENT_EVENT,
            {"allow_metrics_collection": allow_metrics, "auto_accept": auto_accept},
        )
    except Exception as e:
        logger.debug(f"Skipping metrics collection: {e}")


async def track_status_periodically() -> None:
    """Coroutine that tracks the current state of the project every fixed amount of
    seconds."""

    while True:
        logger.debug("Sending periodic metrics update.")
        track_project_status()
        await asyncio.sleep(config.metrics_status_event_interval)


@ensure_metrics_enabled
def track_project_status() -> None:
    """Tracks an event which describes the current state of the project."""

    with db_utils.session_scope() as session:
        status_event = _get_project_status_event(session)

    track(STATUS_EVENT, status_event)


def _is_rasa_environment_live(url: Text) -> bool:
    """Determine whether rasa environment at `url` is alive.

    Args:
        url: URL of the environment.

    Returns:
        `True` or `False` indicating if the environment is live or not.
    """

    try:
        response = requests.get(f"{url}/version", timeout=ENVIRONMENT_LIVE_TIMEOUT)
        return response.status_code == 200
    except requests.RequestException:
        return False


def _get_project_status_event(
    session: Session, project_id: Text = config.project_name
) -> Dict[Text, Any]:
    """Collect data used in `status` event.

    Args:
        session: Database session.
        project_id: The project ID.

    Returns:
        A dictionary containing statistics describing the current project's status.
    """

    from ragex.community.services.event_service import EventService
    from ragex.community.services.domain_service import DomainService
    from ragex.community.services.model_service import ModelService
    from ragex.community.services.data_service import DataService
    from ragex.community.services.story_service import StoryService
    from ragex.community.services.settings_service import SettingsService

    event_service = EventService(session)
    domain_service = DomainService(session)
    model_service = ModelService(config.rasa_model_dir, session)
    data_service = DataService(session)
    story_service = StoryService(session)
    settings_service = SettingsService(session)

    domain = domain_service.get_domain(project_id) or {}
    nlu_data = data_service.get_nlu_training_data_object(project_id=project_id)
    stories = story_service.fetch_stories()

    num_conversations = event_service.get_conversation_metadata_for_all_clients().count
    num_models = model_service.get_model_count()
    lookup_tables = data_service.get_lookup_tables(project_id, include_filenames=True)
    num_lookup_table_files = len({table["filename"] for table in lookup_tables})
    num_lookup_table_entries = sum(
        table.get("number_of_elements", 0) for table in lookup_tables
    )
    synonyms = data_service.get_entity_synonyms(project_id)
    num_synonyms = sum(len(entry["synonyms"]) for entry in synonyms)
    num_regexes = data_service.get_regex_features(project_id).count
    environments = settings_service.get_environments_config(project_id)["environments"][
        "rasa"
    ]
    environment_names = [
        (
            name
            if name in [RASA_PRODUCTION_ENVIRONMENT, "worker", "development"]
            else hashlib.sha256(name.encode("utf-8")).hexdigest()
        )
        for name in environments
    ]
    num_live_environments = len(
        [
            environment
            for environment in environments.values()
            if _is_rasa_environment_live(environment["url"])
        ]
    )

    return {
        # Use the SHA256 of the project ID in case its value contains
        # information about the user's use of Rasa X. On the analytics side,
        # having the original value or the hash makes no difference. This
        # reasoning is also applied on other values sent in this module.
        "project": hashlib.sha256(project_id.encode("utf-8")).hexdigest(),
        "local_mode": config.LOCAL_MODE,
        "rasa_x": __version__,
        "num_intent_examples": len(nlu_data.intent_examples),
        "num_entity_examples": len(nlu_data.entity_examples),
        "num_actions": len(domain.get("actions", [])),
        "num_templates": len(domain.get("templates", [])),
        "num_slots": len(domain.get("slots", [])),
        "num_forms": len(domain.get("forms", [])),
        "num_intents": len(domain.get("intents", [])),
        "num_entities": len(domain.get("entities", [])),
        "num_stories": len(stories),
        "num_conversations": num_conversations,
        "num_models": num_models,
        "num_lookup_table_files": num_lookup_table_files,
        "num_lookup_table_entries": num_lookup_table_entries,
        "num_synonyms": num_synonyms,
        "num_regexes": num_regexes,
        "num_environments": len(environments),
        "environment_names": environment_names,
        "num_live_environments": num_live_environments,
        "uptime_seconds": utils.get_uptime(),
    }


@ensure_metrics_enabled
def track_story_created(referrer: Optional[Text]) -> None:
    """Tracks an event when a new story is created."""

    if not referrer:
        return

    origin = None
    path = urllib.parse.urlparse(referrer).path

    if path.startswith("/interactive"):
        origin = STORY_CREATED_INTERACTIVE
    elif path.startswith("/stories"):
        origin = STORY_CREATED_STORIES

    if origin:
        track(STORY_CREATED_EVENT, {"story_created_from": origin})


@ensure_metrics_enabled
def track_message_annotated(origin: Text) -> None:
    """Tracks an event when a message is annotated."""

    track(MESSAGE_ANNOTATED_EVENT, {"message_annotated_from": origin})


@ensure_metrics_enabled
def track_message_annotated_from_referrer(referrer: Optional[Text] = None) -> None:
    """Tracks an event when a message is annotated, using a 'Referer' HTTP
    header value to determine the origin of the event."""

    if not referrer:
        return

    path = urllib.parse.urlparse(referrer).path

    if path.startswith("/conversations"):
        origin = MESSAGE_ANNOTATED_CONVERSATIONS
    elif path.startswith("/data"):
        origin = MESSAGE_ANNOTATED_NEW_DATA

    track_message_annotated(origin)


@ensure_metrics_enabled
def track_message_received(username: Text, channel: Optional[Text]) -> None:
    """Tracks an event when a message is received."""

    track(
        MESSAGE_RECEIVED_EVENT,
        {
            "username": hashlib.sha256(username.encode("utf-8")).hexdigest(),
            "channel": channel or constants.DEFAULT_CHANNEL_NAME,
        },
    )


def initialize_configuration_from_file(no_prompt: bool) -> None:
    """Read telemetry configuration from the user's Rasa config file in $HOME.

    Raises:
        Exception: if the function is called in server mode.

    Args:
        no_prompt: If `True`, do not prompt the user for input.
    """

    if not config.LOCAL_MODE:
        logger.error(
            "Attempted to read telemetry configuration file in $HOME while in server "
            "mode. Telemetry will not be enabled."
        )
        return

    import questionary

    try:
        config.metrics_collection_config = rasa_utils.read_global_config_value(
            CONFIG_FILE_METRICS_KEY, unavailable_ok=False
        )
        return
    except ValueError as e:
        logger.debug(f"Could not read telemetry settings from configuration file: {e}")

    allow_metrics = (
        questionary.confirm(
            "Rasa will track a minimal amount of anonymized usage information "
            "(like how often the 'train' button is used) to help us improve Rasa X. "
            "None of your training data or conversations will ever be sent to Rasa. "
            "Are you OK with Rasa collecting anonymized usage data?"
        )
        .skip_if(no_prompt, default=True)
        .ask()
    )

    if not no_prompt:
        rasa_cli_utils.print_success(
            f"Your decision has been stored into '{GLOBAL_USER_CONFIG_PATH}'."
        )
    else:
        rasa_cli_utils.print_info(
            "By adding the '--no_prompt' parameter you agreed to allow Rasa to track "
            "and send anonymized usage information."
        )

    settings = _metrics_settings(allow_metrics)

    rasa_utils.write_global_config_value(CONFIG_FILE_METRICS_KEY, settings)
    track_metrics_consent(settings[CONFIG_METRICS_USER], allow_metrics, no_prompt)
    config.metrics_collection_config = settings


def initialize_configuration_from_db(session: Session) -> None:
    """Read telemetry configuration from the database.

    Args:
        session: Database session to use.

    Raises:
        Exception: if the function is called in local mode.
    """

    if config.LOCAL_MODE:
        logger.error(
            "Attempted to read telemetry configuration from the database while in "
            "local mode. Telemetry will not be enabled."
        )
        return

    config_service = ConfigService(session)
    # Initialize the general configuration, just in case. If this has already
    # been done before then this call is a no-op.
    config_service.initialize_configuration()

    telemetry_enabled = False
    telemetry_uuid = None

    try:
        telemetry_enabled = config_service.get_value(
            ConfigKey.TELEMETRY_ENABLED, expected_type=bool
        )
        telemetry_uuid = config_service.get_value(
            ConfigKey.TELEMETRY_UUID, expected_type=str
        )
    except (MissingConfigValue, InvalidConfigValue) as e:
        logger.warning(f"Could not read telemetry configuration: {e}.")

    config.metrics_collection_config = _metrics_settings(
        enable_metrics=telemetry_enabled, metrics_user_id=telemetry_uuid
    )


def _metrics_settings(
    enable_metrics: bool,
    metrics_user_id: Optional[Text] = None,
    consent_date: Optional[datetime.datetime] = None,
) -> Dict[Text, Any]:
    import uuid

    return {
        CONFIG_METRICS_ENABLED: enable_metrics,
        CONFIG_METRICS_USER: metrics_user_id or uuid.uuid4().hex,
        CONFIG_METRICS_DATE: consent_date or datetime.datetime.now(),
        CONFIG_METRICS_WELCOME_SHOWN: False,
    }


@ensure_metrics_enabled
def track_repository_creation(target_branch: Text) -> None:
    """Tracks when a new Git repository was connected to Rasa X server.

    Args:
        target_branch: The target branch of this repository.
    """

    track(REPOSITORY_CREATED_EVENT, {"branch": target_branch})


@ensure_metrics_enabled
def track_git_changes_pushed(branch: Text) -> None:
    """Track when changes were pushed to the remote Git repository.

    Args:
        branch: Name of the branch the changes were pushed to.
    """

    track(GIT_CHANGES_PUSHED_EVENT, {"branch": branch})


@ensure_metrics_enabled
def track_feature_flag(feature_name: Text, enabled: bool) -> None:
    """Track when a feature flag was enabled / disabled.

    Args:
        feature_name: Name of the feature.
        enabled: `True` if the feature was enabled, otherwise `False`.
    """

    track(FEATURE_FLAG_UPDATED_EVENT, {"name": feature_name, "enabled": enabled})
