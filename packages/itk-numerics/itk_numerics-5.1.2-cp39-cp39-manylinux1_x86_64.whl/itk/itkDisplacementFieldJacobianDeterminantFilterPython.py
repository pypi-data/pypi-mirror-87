# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKDisplacementFieldPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkDisplacementFieldJacobianDeterminantFilterPython
else:
    import _itkDisplacementFieldJacobianDeterminantFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkDisplacementFieldJacobianDeterminantFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkDisplacementFieldJacobianDeterminantFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkImageToImageFilterBPython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkFixedArrayPython
import itk.pyBasePython
import itk.itkSizePython
import itk.itkCovariantVectorPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkRGBPixelPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.ITKCommonBasePython
import itk.itkImageRegionPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython
import itk.itkImageSourcePython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterCommonPython

def itkDisplacementFieldJacobianDeterminantFilterIVF22D_New():
    return itkDisplacementFieldJacobianDeterminantFilterIVF22D.New()

class itkDisplacementFieldJacobianDeterminantFilterIVF22D(itk.itkImageToImageFilterBPython.itkImageToImageFilterIVF22ID2):
    r"""


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].

    Overview This filter is based on itkVectorGradientMagnitudeImageFilter
    and supports the m_DerivativeWeights weights for partial derivatives.
    Note that the determinant of a zero vector field is also zero, whereas
    the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output) This filter has one required
    template parameter which defines the input image type. The pixel type
    of the input image is assumed to be a vector (e.g., itk::Vector,
    itk::RGBPixel, itk::FixedArray). The scalar type of the vector
    components must be castable to floating point. Instantiating with an
    will convert it to an image of Vector<float,3> for processing.  The
    second template parameter, TRealType, can be optionally specified to
    define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters The method SetUseImageSpacingOn will cause
    derivatives in the image to be scaled (inversely) with the pixel size
    of the input image, effectively taking derivatives in world
    coordinates (versus isotropic image space). SetUseImageSpacingOff
    turns this functionality off. Default is UseImageSpacingOn. The
    parameter UseImageSpacing can be set directly with the method
    SetUseImageSpacing(bool).  Weights can be applied to the derivatives
    directly using the SetDerivativeWeights method. Note that if
    UseImageSpacing is set to TRUE (ON), then these weights will be
    overridden by weights derived from the image spacing when the filter
    is updated. The argument to this method is a C array of TRealValue
    type.

    Constraints We use vnl_det for determinant computation, which only
    supports square matrices. So the vector dimension of the input image
    values must be equal to the image dimensions, which is trivially true
    for a deformation field that maps an n-dimensional space onto itself.
    Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.

    See:  Image

    See:  Neighborhood

    See:  NeighborhoodOperator

    See:  NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by

    Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D___New_orig__)
    Clone = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_Clone)
    GenerateInputRequestedRegion = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_GenerateInputRequestedRegion)
    SetUseImageSpacingOn = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_SetUseImageSpacingOn)
    SetUseImageSpacingOff = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_SetUseImageSpacingOff)
    SetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_SetUseImageSpacing)
    GetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_GetUseImageSpacing)
    SetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_SetDerivativeWeights)
    GetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_GetDerivativeWeights)
    __swig_destroy__ = _itkDisplacementFieldJacobianDeterminantFilterPython.delete_itkDisplacementFieldJacobianDeterminantFilterIVF22D
    cast = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_cast)

    def New(*args, **kargs):
        """New() -> itkDisplacementFieldJacobianDeterminantFilterIVF22D

        Create a new object of the class itkDisplacementFieldJacobianDeterminantFilterIVF22D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDisplacementFieldJacobianDeterminantFilterIVF22D.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDisplacementFieldJacobianDeterminantFilterIVF22D.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDisplacementFieldJacobianDeterminantFilterIVF22D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDisplacementFieldJacobianDeterminantFilterIVF22D in _itkDisplacementFieldJacobianDeterminantFilterPython:
_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_swigregister(itkDisplacementFieldJacobianDeterminantFilterIVF22D)
itkDisplacementFieldJacobianDeterminantFilterIVF22D___New_orig__ = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D___New_orig__
itkDisplacementFieldJacobianDeterminantFilterIVF22D_cast = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22D_cast


def itkDisplacementFieldJacobianDeterminantFilterIVF22F_New():
    return itkDisplacementFieldJacobianDeterminantFilterIVF22F.New()

class itkDisplacementFieldJacobianDeterminantFilterIVF22F(itk.itkImageToImageFilterBPython.itkImageToImageFilterIVF22IF2):
    r"""


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].

    Overview This filter is based on itkVectorGradientMagnitudeImageFilter
    and supports the m_DerivativeWeights weights for partial derivatives.
    Note that the determinant of a zero vector field is also zero, whereas
    the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output) This filter has one required
    template parameter which defines the input image type. The pixel type
    of the input image is assumed to be a vector (e.g., itk::Vector,
    itk::RGBPixel, itk::FixedArray). The scalar type of the vector
    components must be castable to floating point. Instantiating with an
    will convert it to an image of Vector<float,3> for processing.  The
    second template parameter, TRealType, can be optionally specified to
    define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters The method SetUseImageSpacingOn will cause
    derivatives in the image to be scaled (inversely) with the pixel size
    of the input image, effectively taking derivatives in world
    coordinates (versus isotropic image space). SetUseImageSpacingOff
    turns this functionality off. Default is UseImageSpacingOn. The
    parameter UseImageSpacing can be set directly with the method
    SetUseImageSpacing(bool).  Weights can be applied to the derivatives
    directly using the SetDerivativeWeights method. Note that if
    UseImageSpacing is set to TRUE (ON), then these weights will be
    overridden by weights derived from the image spacing when the filter
    is updated. The argument to this method is a C array of TRealValue
    type.

    Constraints We use vnl_det for determinant computation, which only
    supports square matrices. So the vector dimension of the input image
    values must be equal to the image dimensions, which is trivially true
    for a deformation field that maps an n-dimensional space onto itself.
    Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.

    See:  Image

    See:  Neighborhood

    See:  NeighborhoodOperator

    See:  NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by

    Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F___New_orig__)
    Clone = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_Clone)
    GenerateInputRequestedRegion = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_GenerateInputRequestedRegion)
    SetUseImageSpacingOn = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_SetUseImageSpacingOn)
    SetUseImageSpacingOff = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_SetUseImageSpacingOff)
    SetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_SetUseImageSpacing)
    GetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_GetUseImageSpacing)
    SetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_SetDerivativeWeights)
    GetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_GetDerivativeWeights)
    __swig_destroy__ = _itkDisplacementFieldJacobianDeterminantFilterPython.delete_itkDisplacementFieldJacobianDeterminantFilterIVF22F
    cast = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_cast)

    def New(*args, **kargs):
        """New() -> itkDisplacementFieldJacobianDeterminantFilterIVF22F

        Create a new object of the class itkDisplacementFieldJacobianDeterminantFilterIVF22F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDisplacementFieldJacobianDeterminantFilterIVF22F.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDisplacementFieldJacobianDeterminantFilterIVF22F.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDisplacementFieldJacobianDeterminantFilterIVF22F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDisplacementFieldJacobianDeterminantFilterIVF22F in _itkDisplacementFieldJacobianDeterminantFilterPython:
_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_swigregister(itkDisplacementFieldJacobianDeterminantFilterIVF22F)
itkDisplacementFieldJacobianDeterminantFilterIVF22F___New_orig__ = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F___New_orig__
itkDisplacementFieldJacobianDeterminantFilterIVF22F_cast = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF22F_cast


def itkDisplacementFieldJacobianDeterminantFilterIVF33D_New():
    return itkDisplacementFieldJacobianDeterminantFilterIVF33D.New()

class itkDisplacementFieldJacobianDeterminantFilterIVF33D(itk.itkImageToImageFilterBPython.itkImageToImageFilterIVF33ID3):
    r"""


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].

    Overview This filter is based on itkVectorGradientMagnitudeImageFilter
    and supports the m_DerivativeWeights weights for partial derivatives.
    Note that the determinant of a zero vector field is also zero, whereas
    the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output) This filter has one required
    template parameter which defines the input image type. The pixel type
    of the input image is assumed to be a vector (e.g., itk::Vector,
    itk::RGBPixel, itk::FixedArray). The scalar type of the vector
    components must be castable to floating point. Instantiating with an
    will convert it to an image of Vector<float,3> for processing.  The
    second template parameter, TRealType, can be optionally specified to
    define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters The method SetUseImageSpacingOn will cause
    derivatives in the image to be scaled (inversely) with the pixel size
    of the input image, effectively taking derivatives in world
    coordinates (versus isotropic image space). SetUseImageSpacingOff
    turns this functionality off. Default is UseImageSpacingOn. The
    parameter UseImageSpacing can be set directly with the method
    SetUseImageSpacing(bool).  Weights can be applied to the derivatives
    directly using the SetDerivativeWeights method. Note that if
    UseImageSpacing is set to TRUE (ON), then these weights will be
    overridden by weights derived from the image spacing when the filter
    is updated. The argument to this method is a C array of TRealValue
    type.

    Constraints We use vnl_det for determinant computation, which only
    supports square matrices. So the vector dimension of the input image
    values must be equal to the image dimensions, which is trivially true
    for a deformation field that maps an n-dimensional space onto itself.
    Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.

    See:  Image

    See:  Neighborhood

    See:  NeighborhoodOperator

    See:  NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by

    Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D___New_orig__)
    Clone = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_Clone)
    GenerateInputRequestedRegion = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_GenerateInputRequestedRegion)
    SetUseImageSpacingOn = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_SetUseImageSpacingOn)
    SetUseImageSpacingOff = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_SetUseImageSpacingOff)
    SetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_SetUseImageSpacing)
    GetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_GetUseImageSpacing)
    SetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_SetDerivativeWeights)
    GetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_GetDerivativeWeights)
    __swig_destroy__ = _itkDisplacementFieldJacobianDeterminantFilterPython.delete_itkDisplacementFieldJacobianDeterminantFilterIVF33D
    cast = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_cast)

    def New(*args, **kargs):
        """New() -> itkDisplacementFieldJacobianDeterminantFilterIVF33D

        Create a new object of the class itkDisplacementFieldJacobianDeterminantFilterIVF33D and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDisplacementFieldJacobianDeterminantFilterIVF33D.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDisplacementFieldJacobianDeterminantFilterIVF33D.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDisplacementFieldJacobianDeterminantFilterIVF33D.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDisplacementFieldJacobianDeterminantFilterIVF33D in _itkDisplacementFieldJacobianDeterminantFilterPython:
_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_swigregister(itkDisplacementFieldJacobianDeterminantFilterIVF33D)
itkDisplacementFieldJacobianDeterminantFilterIVF33D___New_orig__ = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D___New_orig__
itkDisplacementFieldJacobianDeterminantFilterIVF33D_cast = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33D_cast


def itkDisplacementFieldJacobianDeterminantFilterIVF33F_New():
    return itkDisplacementFieldJacobianDeterminantFilterIVF33F.New()

class itkDisplacementFieldJacobianDeterminantFilterIVF33F(itk.itkImageToImageFilterBPython.itkImageToImageFilterIVF33IF3):
    r"""


    Computes a scalar image from a vector image (e.g., deformation field)
    input, where each output scalar at each pixel is the Jacobian
    determinant of the vector field at that location. This calculation is
    correct in the case where the vector image is a "displacement" from
    the current location. The computation for the jacobian determinant is:
    det[ dT/dx ] = det[ I + du/dx ].

    Overview This filter is based on itkVectorGradientMagnitudeImageFilter
    and supports the m_DerivativeWeights weights for partial derivatives.
    Note that the determinant of a zero vector field is also zero, whereas
    the Jacobian determinant of the corresponding identity warp
    transformation is 1.0. In order to compute the effective deformation
    Jacobian determinant 1.0 must be added to the diagonal elements of
    Jacobian prior to taking the derivative. i.e. det([ (1.0+dx/dx) dx/dy
    dx/dz ; dy/dx (1.0+dy/dy) dy/dz; dz/dx dz/dy (1.0+dz/dz) ])

    Template Parameters (Input and Output) This filter has one required
    template parameter which defines the input image type. The pixel type
    of the input image is assumed to be a vector (e.g., itk::Vector,
    itk::RGBPixel, itk::FixedArray). The scalar type of the vector
    components must be castable to floating point. Instantiating with an
    will convert it to an image of Vector<float,3> for processing.  The
    second template parameter, TRealType, can be optionally specified to
    define the scalar numerical type used in calculations. This is the
    component type of the output image, which will be of
    itk::Vector<TRealType, N>, where N is the number of channels in the
    multiple component input image. The default type of TRealType is
    float. For extra precision, you may safely change this parameter to
    double.

    The third template parameter is the output image type. The third
    parameter will be automatically constructed from the first and second
    parameters, so it is not necessary (or advisable) to set this
    parameter explicitly. Given an M-channel input image with
    dimensionality N, and a numerical type specified as TRealType, the
    output image will be of type itk::Image<TRealType, N>.

    Filter Parameters The method SetUseImageSpacingOn will cause
    derivatives in the image to be scaled (inversely) with the pixel size
    of the input image, effectively taking derivatives in world
    coordinates (versus isotropic image space). SetUseImageSpacingOff
    turns this functionality off. Default is UseImageSpacingOn. The
    parameter UseImageSpacing can be set directly with the method
    SetUseImageSpacing(bool).  Weights can be applied to the derivatives
    directly using the SetDerivativeWeights method. Note that if
    UseImageSpacing is set to TRUE (ON), then these weights will be
    overridden by weights derived from the image spacing when the filter
    is updated. The argument to this method is a C array of TRealValue
    type.

    Constraints We use vnl_det for determinant computation, which only
    supports square matrices. So the vector dimension of the input image
    values must be equal to the image dimensions, which is trivially true
    for a deformation field that maps an n-dimensional space onto itself.
    Currently, dimensions up to and including 4 are supported. This
    limitation comes from the presence of vnl_det() functions for matrices
    of dimension up to 4x4.

    The template parameter TRealType must be floating point (float or
    double) or a user-defined "real" numerical type with arithmetic
    operations defined sufficient to compute derivatives.

    See:  Image

    See:  Neighborhood

    See:  NeighborhoodOperator

    See:  NeighborhoodIterator

    This class was adapted by

    Hans J. Johnson, The University of Iowa from code provided by

    Tom Vercauteren, INRIA & Mauna Kea Technologies

    Torsten Rohlfing, Neuroscience Program, SRI International. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F___New_orig__)
    Clone = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_Clone)
    GenerateInputRequestedRegion = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_GenerateInputRequestedRegion)
    SetUseImageSpacingOn = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_SetUseImageSpacingOn)
    SetUseImageSpacingOff = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_SetUseImageSpacingOff)
    SetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_SetUseImageSpacing)
    GetUseImageSpacing = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_GetUseImageSpacing)
    SetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_SetDerivativeWeights)
    GetDerivativeWeights = _swig_new_instance_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_GetDerivativeWeights)
    __swig_destroy__ = _itkDisplacementFieldJacobianDeterminantFilterPython.delete_itkDisplacementFieldJacobianDeterminantFilterIVF33F
    cast = _swig_new_static_method(_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_cast)

    def New(*args, **kargs):
        """New() -> itkDisplacementFieldJacobianDeterminantFilterIVF33F

        Create a new object of the class itkDisplacementFieldJacobianDeterminantFilterIVF33F and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDisplacementFieldJacobianDeterminantFilterIVF33F.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDisplacementFieldJacobianDeterminantFilterIVF33F.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDisplacementFieldJacobianDeterminantFilterIVF33F.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDisplacementFieldJacobianDeterminantFilterIVF33F in _itkDisplacementFieldJacobianDeterminantFilterPython:
_itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_swigregister(itkDisplacementFieldJacobianDeterminantFilterIVF33F)
itkDisplacementFieldJacobianDeterminantFilterIVF33F___New_orig__ = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F___New_orig__
itkDisplacementFieldJacobianDeterminantFilterIVF33F_cast = _itkDisplacementFieldJacobianDeterminantFilterPython.itkDisplacementFieldJacobianDeterminantFilterIVF33F_cast


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def displacement_field_jacobian_determinant_filter(*args, **kwargs):
    """Procedural interface for DisplacementFieldJacobianDeterminantFilter"""
    import itk
    instance = itk.DisplacementFieldJacobianDeterminantFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def displacement_field_jacobian_determinant_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.DisplacementFieldJacobianDeterminantFilter, itkTemplate.itkTemplate):
        filter_object = itk.DisplacementFieldJacobianDeterminantFilter.values()[0]
    else:
        filter_object = itk.DisplacementFieldJacobianDeterminantFilter

    displacement_field_jacobian_determinant_filter.__doc__ = filter_object.__doc__
    displacement_field_jacobian_determinant_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    displacement_field_jacobian_determinant_filter.__doc__ += "\n Available Keyword Arguments:\n"
    if isinstance(itk.DisplacementFieldJacobianDeterminantFilter, itkTemplate.itkTemplate):
        displacement_field_jacobian_determinant_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        displacement_field_jacobian_determinant_filter.__doc__ += "\n"
        displacement_field_jacobian_determinant_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        displacement_field_jacobian_determinant_filter.__doc__ += "".join([
            "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
            for item in dir(filter_object)
            if item.startswith("Set")])



