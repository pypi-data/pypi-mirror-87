# Copyright 2020 Karlsruhe Institute of Technology
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from flask import current_app

from .models import Chunk
from .models import File
from kadi.ext.db import db
from kadi.lib.db import update_object
from kadi.lib.exceptions import KadiChecksumMismatchError
from kadi.lib.revisions.core import create_revision
from kadi.lib.storage.core import create_filepath
from kadi.lib.storage.local import LocalStorage
from kadi.lib.utils import is_iterable


def delete_upload(upload):
    """Delete an existing upload.

    This will mark the upload for deletion, i.e. the upload's state will be set to
    ``"inactive"``.

    :param upload: The upload to delete.
    """
    upload.state = "inactive"


def remove_uploads(uploads):
    """Remove multiple uploads from local storage.

    Note that this function may issue one or more database commits.

    :param uploads: A single :class:`.Upload` or an iterable of uploads.
    """
    storage = LocalStorage()

    if not is_iterable(uploads):
        uploads = [uploads]

    for upload in uploads:
        upload.state = "inactive"
        db.session.commit()

        filepath = create_filepath(str(upload.id))
        storage.delete(filepath)

        # Remove the chunks of the upload.
        for chunk in upload.chunks:
            chunk_filepath = f"{filepath}-{chunk.index}"
            storage.delete(chunk_filepath)

            db.session.delete(chunk)

        storage.remove_empty_parent_dirs(filepath, num_dirs=3)

        db.session.delete(upload)
        db.session.commit()


def save_chunk(*, upload, file_object, index, size, checksum=None):
    """Save a chunk of an upload.

    Each chunk uses the UUID of the given upload (see :attr:`.Upload.id`) combined with
    its index as base name in the form of ``"<uuid>-<index>"``. The complete path of the
    file will then be generated by prepending ``"STORAGE_PATH"`` as configured in the
    application's configuration.

    Note that this function may issue one or more database commits.

    :param upload: The :class:`.Upload` the chunk belongs to.
    :param file_object: A file-like object representing the actual uploaded file.
    :param index: The index of the chunk.
    :param size: The size of the chunk in bytes.
    :param checksum: (optional) The MD5 checksum of the chunk. If given it will be used
        to verify the checksum after saving the chunk.
    :raises KadiFilesizeExceededError: If the chunk exceeds the chunk size configured in
        ``UPLOAD_CHUNK_SIZE`` in the application's configuration.
    :raises KadiFilesizeMismatchError: If the file size does not match the provided
        size.
    :raises KadiChecksumMismatchError: If the calculated checksum does not match the
        provided one.
    """
    chunk = Chunk.update_or_create(upload=upload, index=index, size=size)
    db.session.commit()

    filename = f"{upload.id}-{index}"
    filepath = create_filepath(filename)

    storage = LocalStorage(max_size=current_app.config["UPLOAD_CHUNK_SIZE"])

    try:
        storage.save(filepath, file_object)
        storage.validate_size(filepath, size)

        if checksum is not None:
            storage.verify_checksum(filepath, checksum)

        chunk.state = "active"

    except Exception:
        chunk.state = "inactive"
        raise

    finally:
        # Update the upload's timestamp so it does not expire.
        upload.update_timestamp()
        db.session.commit()


def merge_chunks(upload, task=None):
    """Merge the chunks of an upload.

    Note that this function may issue one or more database commits.

    :param upload: The :class:`.Upload` the chunks belong to.
    :param task: (optional) A :class:`.Task` object that can be provided if this
        function is executed in a task. In that case, the progress of the given task
        will be updated.
    :raises KadiFilesizeExceededError: If the file exceeds the file size configured in
        ``MAX_UPLOAD_SIZE`` in the application's configuration.
    :raises KadiFilesizeMismatchError: If the actual file size does not match the size
        of the file object.
    :raises KadiChecksumMismatchError: If the actual checksum does not match the
        checksum of the file object.
    """

    # If the upload replaces a file we mark it as inactive so it cannot be changed
    # while the replace operation is running.
    if upload.file is not None:
        upload.file.state = "inactive"

    storage = LocalStorage(max_size=current_app.config["MAX_UPLOAD_SIZE"])
    upload_path = create_filepath(str(upload.id))

    try:
        # Merge the uploaded chunks.
        chunks = upload.active_chunks.order_by(Chunk.index.asc())
        for index, chunk in enumerate(chunks):
            chunk_filepath = f"{upload_path}-{chunk.index}"
            storage.save(upload_path, chunk_filepath, append=True)

            if task is not None:
                task.update_progress((index + 1) / upload.chunk_count * 100)
                db.session.commit()

        storage.validate_size(upload_path, upload.size)

        # Check if a checksum was provided to verify, otherwise get the missing checksum
        # now.
        checksum = upload.checksum
        if checksum is not None:
            storage.verify_checksum(upload_path, checksum)
        else:
            checksum = storage.get_checksum(upload_path)

        # Replace the given mimetype with the magic mimetype if it was not given and
        # cannot be guessed from the filename, i.e. it is set to
        # "application/octet-stream".
        mimetype = upload.mimetype
        magic_mimetype = storage.get_mimetype(upload_path)
        if mimetype == "application/octet-stream":
            mimetype = magic_mimetype

        # The upload does not replace an existing file.
        if upload.file is None:
            file = File.create(
                record=upload.record,
                creator=upload.creator,
                name=upload.name,
                size=upload.size,
                checksum=checksum,
                magic_mimetype=magic_mimetype,
                mimetype=mimetype,
            )
            # Commit here already, so the file can be referenced and deleted later if
            # something went wrong.
            db.session.commit()

        # The upload replaces an existing file.
        else:
            file = upload.file
            update_object(
                file,
                size=upload.size,
                checksum=checksum,
                mimetype=mimetype,
                magic_mimetype=magic_mimetype,
            )

        # Move the merged upload to the correct location.
        filepath = create_filepath(str(file.id))
        storage.move(upload_path, filepath)

        # Update the record's timestamp as well, even if the file content did not change
        # (to stay consistent with the file's updated timestamp).
        file.record.update_timestamp()

        file.state = "active"
        upload.state = "inactive"

        # Note that the creator of the upload will be used for the revision. The
        # original creator of the file will stay the same.
        create_revision(file, user=upload.creator)
        db.session.commit()

        return file

    except Exception:
        db.session.rollback()

        # If something went wrong when replacing a file, try to check if the old file is
        # still intact and delete it if necessary.
        if upload.file is not None:
            try:
                filepath = create_filepath(str(upload.file.id))
                storage.verify_checksum(filepath, upload.file.checksum)
                file.state = "active"

            except KadiChecksumMismatchError:
                from .files import delete_file

                delete_file(upload.file, revision_user=upload.creator)

        upload.state = "inactive"
        db.session.commit()
        raise
