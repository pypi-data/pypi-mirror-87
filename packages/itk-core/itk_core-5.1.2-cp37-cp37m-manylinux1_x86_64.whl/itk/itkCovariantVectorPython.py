# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKCommonPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkCovariantVectorPython
else:
    import _itkCovariantVectorPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkCovariantVectorPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkCovariantVectorPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.vnl_vector_refPython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.itkFixedArrayPython
import itk.itkVectorPython
class itkCovariantVectorD2(itk.itkFixedArrayPython.itkFixedArrayD2):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD2_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorD2

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorD2 self) -> itkCovariantVectorD2
        __init__(itkCovariantVectorD2 self, itkCovariantVectorD2 arg0) -> itkCovariantVectorD2
        __init__(itkCovariantVectorD2 self, double const & r) -> itkCovariantVectorD2
        __init__(itkCovariantVectorD2 self, double const * r) -> itkCovariantVectorD2


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorD2_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorD2(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD2_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD2___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD2___repr__)

# Register itkCovariantVectorD2 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorD2_swigregister(itkCovariantVectorD2)
itkCovariantVectorD2_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorD2_GetCovariantVectorDimension
itkCovariantVectorD2_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorD2_GetNumberOfComponents
itkCovariantVectorD2___len__ = _itkCovariantVectorPython.itkCovariantVectorD2___len__

class itkCovariantVectorD3(itk.itkFixedArrayPython.itkFixedArrayD3):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD3_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorD3

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorD3 self) -> itkCovariantVectorD3
        __init__(itkCovariantVectorD3 self, itkCovariantVectorD3 arg0) -> itkCovariantVectorD3
        __init__(itkCovariantVectorD3 self, double const & r) -> itkCovariantVectorD3
        __init__(itkCovariantVectorD3 self, double const * r) -> itkCovariantVectorD3


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorD3_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorD3(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD3_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD3___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD3___repr__)

# Register itkCovariantVectorD3 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorD3_swigregister(itkCovariantVectorD3)
itkCovariantVectorD3_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorD3_GetCovariantVectorDimension
itkCovariantVectorD3_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorD3_GetNumberOfComponents
itkCovariantVectorD3___len__ = _itkCovariantVectorPython.itkCovariantVectorD3___len__

class itkCovariantVectorD4(itk.itkFixedArrayPython.itkFixedArrayD4):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD4_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorD4

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorD4 self) -> itkCovariantVectorD4
        __init__(itkCovariantVectorD4 self, itkCovariantVectorD4 arg0) -> itkCovariantVectorD4
        __init__(itkCovariantVectorD4 self, double const & r) -> itkCovariantVectorD4
        __init__(itkCovariantVectorD4 self, double const * r) -> itkCovariantVectorD4


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorD4_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorD4(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD4_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD4___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD4___repr__)

# Register itkCovariantVectorD4 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorD4_swigregister(itkCovariantVectorD4)
itkCovariantVectorD4_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorD4_GetCovariantVectorDimension
itkCovariantVectorD4_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorD4_GetNumberOfComponents
itkCovariantVectorD4___len__ = _itkCovariantVectorPython.itkCovariantVectorD4___len__

class itkCovariantVectorD5(itk.itkFixedArrayPython.itkFixedArrayD5):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD5_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorD5

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorD5 self) -> itkCovariantVectorD5
        __init__(itkCovariantVectorD5 self, itkCovariantVectorD5 arg0) -> itkCovariantVectorD5
        __init__(itkCovariantVectorD5 self, double const & r) -> itkCovariantVectorD5
        __init__(itkCovariantVectorD5 self, double const * r) -> itkCovariantVectorD5


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorD5_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorD5(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD5_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorD5___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorD5___repr__)

# Register itkCovariantVectorD5 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorD5_swigregister(itkCovariantVectorD5)
itkCovariantVectorD5_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorD5_GetCovariantVectorDimension
itkCovariantVectorD5_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorD5_GetNumberOfComponents
itkCovariantVectorD5___len__ = _itkCovariantVectorPython.itkCovariantVectorD5___len__

class itkCovariantVectorF2(itk.itkFixedArrayPython.itkFixedArrayF2):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF2_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorF2

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorF2 self) -> itkCovariantVectorF2
        __init__(itkCovariantVectorF2 self, itkCovariantVectorF2 arg0) -> itkCovariantVectorF2
        __init__(itkCovariantVectorF2 self, float const & r) -> itkCovariantVectorF2
        __init__(itkCovariantVectorF2 self, float const * r) -> itkCovariantVectorF2


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorF2_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorF2(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF2_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF2___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF2___repr__)

# Register itkCovariantVectorF2 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorF2_swigregister(itkCovariantVectorF2)
itkCovariantVectorF2_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorF2_GetCovariantVectorDimension
itkCovariantVectorF2_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorF2_GetNumberOfComponents
itkCovariantVectorF2___len__ = _itkCovariantVectorPython.itkCovariantVectorF2___len__

class itkCovariantVectorF3(itk.itkFixedArrayPython.itkFixedArrayF3):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF3_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorF3

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorF3 self) -> itkCovariantVectorF3
        __init__(itkCovariantVectorF3 self, itkCovariantVectorF3 arg0) -> itkCovariantVectorF3
        __init__(itkCovariantVectorF3 self, float const & r) -> itkCovariantVectorF3
        __init__(itkCovariantVectorF3 self, float const * r) -> itkCovariantVectorF3


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorF3_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorF3(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF3_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF3___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF3___repr__)

# Register itkCovariantVectorF3 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorF3_swigregister(itkCovariantVectorF3)
itkCovariantVectorF3_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorF3_GetCovariantVectorDimension
itkCovariantVectorF3_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorF3_GetNumberOfComponents
itkCovariantVectorF3___len__ = _itkCovariantVectorPython.itkCovariantVectorF3___len__

class itkCovariantVectorF4(itk.itkFixedArrayPython.itkFixedArrayF4):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF4_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorF4

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorF4 self) -> itkCovariantVectorF4
        __init__(itkCovariantVectorF4 self, itkCovariantVectorF4 arg0) -> itkCovariantVectorF4
        __init__(itkCovariantVectorF4 self, float const & r) -> itkCovariantVectorF4
        __init__(itkCovariantVectorF4 self, float const * r) -> itkCovariantVectorF4


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorF4_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorF4(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF4_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF4___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF4___repr__)

# Register itkCovariantVectorF4 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorF4_swigregister(itkCovariantVectorF4)
itkCovariantVectorF4_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorF4_GetCovariantVectorDimension
itkCovariantVectorF4_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorF4_GetNumberOfComponents
itkCovariantVectorF4___len__ = _itkCovariantVectorPython.itkCovariantVectorF4___len__

class itkCovariantVectorF5(itk.itkFixedArrayPython.itkFixedArrayF5):
    r"""


    A templated class holding a n-Dimensional covariant vector.

    CovariantVector is a templated class that holds a single vector (i.e.,
    an array of values). CovariantVector can be used as the data type held
    at each pixel in an Image or at each vertex of an Mesh. The template
    parameter T can be any data type that behaves like a primitive (or
    atomic) data type (int, short, float, complex). The NVectorDimension
    defines the number of components in the vector array.

    CovariantVector is not a dynamically extendible array like
    std::vector. It is intended to be used like a mathematical vector.

    If you wish a simpler pixel types, you can use Scalar, which
    represents a single data value at a pixel. There is also the more
    complex type ScalarCovariantVector, which supports (for a given pixel)
    a single scalar value plus an array of vector values. (The scalar and
    vectors can be of different data type.)

    CovariantVector is the type that should be used for representing
    normals to surfaces and gradients of functions. AffineTransform
    transform covariant vectors different than vectors.

    See:   Image

    See:  Mesh

    See:   Point

    See:   Vector

    See:   Matrix 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    GetCovariantVectorDimension = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF5_GetCovariantVectorDimension)
    SetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5_SetVnlVector)
    GetVnlVector = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5_GetVnlVector)
    __swig_destroy__ = _itkCovariantVectorPython.delete_itkCovariantVectorF5

    def __init__(self, *args):
        r"""
        __init__(itkCovariantVectorF5 self) -> itkCovariantVectorF5
        __init__(itkCovariantVectorF5 self, itkCovariantVectorF5 arg0) -> itkCovariantVectorF5
        __init__(itkCovariantVectorF5 self, float const & r) -> itkCovariantVectorF5
        __init__(itkCovariantVectorF5 self, float const * r) -> itkCovariantVectorF5


        A templated class holding a n-Dimensional covariant vector.

        CovariantVector is a templated class that holds a single vector (i.e.,
        an array of values). CovariantVector can be used as the data type held
        at each pixel in an Image or at each vertex of an Mesh. The template
        parameter T can be any data type that behaves like a primitive (or
        atomic) data type (int, short, float, complex). The NVectorDimension
        defines the number of components in the vector array.

        CovariantVector is not a dynamically extendible array like
        std::vector. It is intended to be used like a mathematical vector.

        If you wish a simpler pixel types, you can use Scalar, which
        represents a single data value at a pixel. There is also the more
        complex type ScalarCovariantVector, which supports (for a given pixel)
        a single scalar value plus an array of vector values. (The scalar and
        vectors can be of different data type.)

        CovariantVector is the type that should be used for representing
        normals to surfaces and gradients of functions. AffineTransform
        transform covariant vectors different than vectors.

        See:   Image

        See:  Mesh

        See:   Point

        See:   Vector

        See:   Matrix 
        """
        _itkCovariantVectorPython.itkCovariantVectorF5_swiginit(self, _itkCovariantVectorPython.new_itkCovariantVectorF5(*args))
    __iadd__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___iadd__)
    __isub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___isub__)
    __neg__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___neg__)
    __add__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___add__)
    __sub__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___sub__)
    __mul__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___mul__)
    GetNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5_GetNorm)
    GetNumberOfComponents = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF5_GetNumberOfComponents)
    Normalize = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5_Normalize)
    GetSquaredNorm = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5_GetSquaredNorm)
    __getitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___getitem__)
    __setitem__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___setitem__)
    __len__ = _swig_new_static_method(_itkCovariantVectorPython.itkCovariantVectorF5___len__)
    __repr__ = _swig_new_instance_method(_itkCovariantVectorPython.itkCovariantVectorF5___repr__)

# Register itkCovariantVectorF5 in _itkCovariantVectorPython:
_itkCovariantVectorPython.itkCovariantVectorF5_swigregister(itkCovariantVectorF5)
itkCovariantVectorF5_GetCovariantVectorDimension = _itkCovariantVectorPython.itkCovariantVectorF5_GetCovariantVectorDimension
itkCovariantVectorF5_GetNumberOfComponents = _itkCovariantVectorPython.itkCovariantVectorF5_GetNumberOfComponents
itkCovariantVectorF5___len__ = _itkCovariantVectorPython.itkCovariantVectorF5___len__



