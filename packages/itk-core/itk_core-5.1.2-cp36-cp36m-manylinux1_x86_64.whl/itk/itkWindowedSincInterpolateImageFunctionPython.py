# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKImageFunctionPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkWindowedSincInterpolateImageFunctionPython
else:
    import _itkWindowedSincInterpolateImageFunctionPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkWindowedSincInterpolateImageFunctionPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkWindowedSincInterpolateImageFunctionPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.ITKCommonBasePython
import itk.pyBasePython
import itk.itkContinuousIndexPython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkSizePython
import itk.itkPointPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.vnl_matrixPython
import itk.vnl_vector_refPython
import itk.itkFixedArrayPython
import itk.itkVectorPython
import itk.itkInterpolateImageFunctionPython
import itk.itkImageFunctionBasePython
import itk.itkRGBAPixelPython
import itk.itkFunctionBasePython
import itk.itkArrayPython
import itk.itkCovariantVectorPython
import itk.itkImagePython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkImageRegionPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkRGBPixelPython
class itkCosineWindowFunction2(object):
    r"""Proxy of C++ itkCosineWindowFunction2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkCosineWindowFunction2

    def __init__(self, *args):
        r"""
        __init__(itkCosineWindowFunction2 self) -> itkCosineWindowFunction2
        __init__(itkCosineWindowFunction2 self, itkCosineWindowFunction2 arg0) -> itkCosineWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkCosineWindowFunction2(*args))

# Register itkCosineWindowFunction2 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction2_swigregister(itkCosineWindowFunction2)

class itkCosineWindowFunction3(object):
    r"""Proxy of C++ itkCosineWindowFunction3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkCosineWindowFunction3

    def __init__(self, *args):
        r"""
        __init__(itkCosineWindowFunction3 self) -> itkCosineWindowFunction3
        __init__(itkCosineWindowFunction3 self, itkCosineWindowFunction3 arg0) -> itkCosineWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkCosineWindowFunction3(*args))

# Register itkCosineWindowFunction3 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkCosineWindowFunction3_swigregister(itkCosineWindowFunction3)

class itkHammingWindowFunction2(object):
    r"""Proxy of C++ itkHammingWindowFunction2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkHammingWindowFunction2

    def __init__(self, *args):
        r"""
        __init__(itkHammingWindowFunction2 self) -> itkHammingWindowFunction2
        __init__(itkHammingWindowFunction2 self, itkHammingWindowFunction2 arg0) -> itkHammingWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkHammingWindowFunction2(*args))

# Register itkHammingWindowFunction2 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction2_swigregister(itkHammingWindowFunction2)

class itkHammingWindowFunction3(object):
    r"""Proxy of C++ itkHammingWindowFunction3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkHammingWindowFunction3

    def __init__(self, *args):
        r"""
        __init__(itkHammingWindowFunction3 self) -> itkHammingWindowFunction3
        __init__(itkHammingWindowFunction3 self, itkHammingWindowFunction3 arg0) -> itkHammingWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkHammingWindowFunction3(*args))

# Register itkHammingWindowFunction3 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkHammingWindowFunction3_swigregister(itkHammingWindowFunction3)

class itkLanczosWindowFunction2(object):
    r"""Proxy of C++ itkLanczosWindowFunction2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkLanczosWindowFunction2

    def __init__(self, *args):
        r"""
        __init__(itkLanczosWindowFunction2 self) -> itkLanczosWindowFunction2
        __init__(itkLanczosWindowFunction2 self, itkLanczosWindowFunction2 arg0) -> itkLanczosWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkLanczosWindowFunction2(*args))

# Register itkLanczosWindowFunction2 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction2_swigregister(itkLanczosWindowFunction2)

class itkLanczosWindowFunction3(object):
    r"""Proxy of C++ itkLanczosWindowFunction3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkLanczosWindowFunction3

    def __init__(self, *args):
        r"""
        __init__(itkLanczosWindowFunction3 self) -> itkLanczosWindowFunction3
        __init__(itkLanczosWindowFunction3 self, itkLanczosWindowFunction3 arg0) -> itkLanczosWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkLanczosWindowFunction3(*args))

# Register itkLanczosWindowFunction3 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkLanczosWindowFunction3_swigregister(itkLanczosWindowFunction3)

class itkWelchWindowFunction2(object):
    r"""Proxy of C++ itkWelchWindowFunction2 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWelchWindowFunction2

    def __init__(self, *args):
        r"""
        __init__(itkWelchWindowFunction2 self) -> itkWelchWindowFunction2
        __init__(itkWelchWindowFunction2 self, itkWelchWindowFunction2 arg0) -> itkWelchWindowFunction2
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkWelchWindowFunction2(*args))

# Register itkWelchWindowFunction2 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction2_swigregister(itkWelchWindowFunction2)

class itkWelchWindowFunction3(object):
    r"""Proxy of C++ itkWelchWindowFunction3 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    __call__ = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3___call__)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWelchWindowFunction3

    def __init__(self, *args):
        r"""
        __init__(itkWelchWindowFunction3 self) -> itkWelchWindowFunction3
        __init__(itkWelchWindowFunction3 self, itkWelchWindowFunction3 arg0) -> itkWelchWindowFunction3
        """
        _itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3_swiginit(self, _itkWindowedSincInterpolateImageFunctionPython.new_itkWelchWindowFunction3(*args))

# Register itkWelchWindowFunction3 in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWelchWindowFunction3_swigregister(itkWelchWindowFunction3)


def itkWindowedSincInterpolateImageFunctionID22Cosine_New():
    return itkWindowedSincInterpolateImageFunctionID22Cosine.New()

class itkWindowedSincInterpolateImageFunctionID22Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID22Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID22Cosine)
itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionID22Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Cosine_cast


def itkWindowedSincInterpolateImageFunctionID22Hamming_New():
    return itkWindowedSincInterpolateImageFunctionID22Hamming.New()

class itkWindowedSincInterpolateImageFunctionID22Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID22Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID22Hamming)
itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionID22Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Hamming_cast


def itkWindowedSincInterpolateImageFunctionID22Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionID22Lanczos.New()

class itkWindowedSincInterpolateImageFunctionID22Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID22Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID22Lanczos)
itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionID22Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Lanczos_cast


def itkWindowedSincInterpolateImageFunctionID22Welch_New():
    return itkWindowedSincInterpolateImageFunctionID22Welch.New()

class itkWindowedSincInterpolateImageFunctionID22Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID22Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID22Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID22Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID22Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_swigregister(itkWindowedSincInterpolateImageFunctionID22Welch)
itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch___New_orig__
itkWindowedSincInterpolateImageFunctionID22Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID22Welch_cast


def itkWindowedSincInterpolateImageFunctionID23Cosine_New():
    return itkWindowedSincInterpolateImageFunctionID23Cosine.New()

class itkWindowedSincInterpolateImageFunctionID23Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID23Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID23Cosine)
itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionID23Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Cosine_cast


def itkWindowedSincInterpolateImageFunctionID23Hamming_New():
    return itkWindowedSincInterpolateImageFunctionID23Hamming.New()

class itkWindowedSincInterpolateImageFunctionID23Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID23Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID23Hamming)
itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionID23Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Hamming_cast


def itkWindowedSincInterpolateImageFunctionID23Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionID23Lanczos.New()

class itkWindowedSincInterpolateImageFunctionID23Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID23Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID23Lanczos)
itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionID23Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Lanczos_cast


def itkWindowedSincInterpolateImageFunctionID23Welch_New():
    return itkWindowedSincInterpolateImageFunctionID23Welch.New()

class itkWindowedSincInterpolateImageFunctionID23Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID23Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID23Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID23Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID23Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_swigregister(itkWindowedSincInterpolateImageFunctionID23Welch)
itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch___New_orig__
itkWindowedSincInterpolateImageFunctionID23Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID23Welch_cast


def itkWindowedSincInterpolateImageFunctionID32Cosine_New():
    return itkWindowedSincInterpolateImageFunctionID32Cosine.New()

class itkWindowedSincInterpolateImageFunctionID32Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID32Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID32Cosine)
itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionID32Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Cosine_cast


def itkWindowedSincInterpolateImageFunctionID32Hamming_New():
    return itkWindowedSincInterpolateImageFunctionID32Hamming.New()

class itkWindowedSincInterpolateImageFunctionID32Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID32Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID32Hamming)
itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionID32Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Hamming_cast


def itkWindowedSincInterpolateImageFunctionID32Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionID32Lanczos.New()

class itkWindowedSincInterpolateImageFunctionID32Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID32Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID32Lanczos)
itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionID32Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Lanczos_cast


def itkWindowedSincInterpolateImageFunctionID32Welch_New():
    return itkWindowedSincInterpolateImageFunctionID32Welch.New()

class itkWindowedSincInterpolateImageFunctionID32Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID32Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID32Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID32Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID32Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_swigregister(itkWindowedSincInterpolateImageFunctionID32Welch)
itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch___New_orig__
itkWindowedSincInterpolateImageFunctionID32Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID32Welch_cast


def itkWindowedSincInterpolateImageFunctionID33Cosine_New():
    return itkWindowedSincInterpolateImageFunctionID33Cosine.New()

class itkWindowedSincInterpolateImageFunctionID33Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID33Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionID33Cosine)
itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionID33Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Cosine_cast


def itkWindowedSincInterpolateImageFunctionID33Hamming_New():
    return itkWindowedSincInterpolateImageFunctionID33Hamming.New()

class itkWindowedSincInterpolateImageFunctionID33Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID33Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionID33Hamming)
itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionID33Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Hamming_cast


def itkWindowedSincInterpolateImageFunctionID33Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionID33Lanczos.New()

class itkWindowedSincInterpolateImageFunctionID33Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID33Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionID33Lanczos)
itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionID33Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Lanczos_cast


def itkWindowedSincInterpolateImageFunctionID33Welch_New():
    return itkWindowedSincInterpolateImageFunctionID33Welch.New()

class itkWindowedSincInterpolateImageFunctionID33Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionID3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionID33Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionID33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionID33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionID33Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionID33Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionID33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionID33Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_swigregister(itkWindowedSincInterpolateImageFunctionID33Welch)
itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch___New_orig__
itkWindowedSincInterpolateImageFunctionID33Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionID33Welch_cast


def itkWindowedSincInterpolateImageFunctionIF22Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIF22Cosine.New()

class itkWindowedSincInterpolateImageFunctionIF22Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF22Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF22Cosine)
itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIF22Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Cosine_cast


def itkWindowedSincInterpolateImageFunctionIF22Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIF22Hamming.New()

class itkWindowedSincInterpolateImageFunctionIF22Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF22Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF22Hamming)
itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIF22Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Hamming_cast


def itkWindowedSincInterpolateImageFunctionIF22Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIF22Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIF22Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF22Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF22Lanczos)
itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIF22Welch_New():
    return itkWindowedSincInterpolateImageFunctionIF22Welch.New()

class itkWindowedSincInterpolateImageFunctionIF22Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF22Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF22Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF22Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF22Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF22Welch)
itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIF22Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF22Welch_cast


def itkWindowedSincInterpolateImageFunctionIF23Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIF23Cosine.New()

class itkWindowedSincInterpolateImageFunctionIF23Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF23Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF23Cosine)
itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIF23Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Cosine_cast


def itkWindowedSincInterpolateImageFunctionIF23Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIF23Hamming.New()

class itkWindowedSincInterpolateImageFunctionIF23Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF23Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF23Hamming)
itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIF23Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Hamming_cast


def itkWindowedSincInterpolateImageFunctionIF23Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIF23Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIF23Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF23Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF23Lanczos)
itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIF23Welch_New():
    return itkWindowedSincInterpolateImageFunctionIF23Welch.New()

class itkWindowedSincInterpolateImageFunctionIF23Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF23Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF23Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF23Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF23Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF23Welch)
itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIF23Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF23Welch_cast


def itkWindowedSincInterpolateImageFunctionIF32Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIF32Cosine.New()

class itkWindowedSincInterpolateImageFunctionIF32Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF32Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF32Cosine)
itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIF32Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Cosine_cast


def itkWindowedSincInterpolateImageFunctionIF32Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIF32Hamming.New()

class itkWindowedSincInterpolateImageFunctionIF32Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF32Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF32Hamming)
itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIF32Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Hamming_cast


def itkWindowedSincInterpolateImageFunctionIF32Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIF32Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIF32Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF32Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF32Lanczos)
itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIF32Welch_New():
    return itkWindowedSincInterpolateImageFunctionIF32Welch.New()

class itkWindowedSincInterpolateImageFunctionIF32Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF32Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF32Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF32Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF32Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF32Welch)
itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIF32Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF32Welch_cast


def itkWindowedSincInterpolateImageFunctionIF33Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIF33Cosine.New()

class itkWindowedSincInterpolateImageFunctionIF33Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF33Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIF33Cosine)
itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIF33Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Cosine_cast


def itkWindowedSincInterpolateImageFunctionIF33Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIF33Hamming.New()

class itkWindowedSincInterpolateImageFunctionIF33Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF33Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIF33Hamming)
itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIF33Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Hamming_cast


def itkWindowedSincInterpolateImageFunctionIF33Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIF33Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIF33Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF33Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIF33Lanczos)
itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIF33Welch_New():
    return itkWindowedSincInterpolateImageFunctionIF33Welch.New()

class itkWindowedSincInterpolateImageFunctionIF33Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIF3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIF33Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIF33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIF33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIF33Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIF33Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIF33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIF33Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIF33Welch)
itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIF33Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIF33Welch_cast


def itkWindowedSincInterpolateImageFunctionISS22Cosine_New():
    return itkWindowedSincInterpolateImageFunctionISS22Cosine.New()

class itkWindowedSincInterpolateImageFunctionISS22Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS22Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS22Cosine)
itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionISS22Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Cosine_cast


def itkWindowedSincInterpolateImageFunctionISS22Hamming_New():
    return itkWindowedSincInterpolateImageFunctionISS22Hamming.New()

class itkWindowedSincInterpolateImageFunctionISS22Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS22Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS22Hamming)
itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionISS22Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Hamming_cast


def itkWindowedSincInterpolateImageFunctionISS22Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionISS22Lanczos.New()

class itkWindowedSincInterpolateImageFunctionISS22Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS22Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS22Lanczos)
itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Lanczos_cast


def itkWindowedSincInterpolateImageFunctionISS22Welch_New():
    return itkWindowedSincInterpolateImageFunctionISS22Welch.New()

class itkWindowedSincInterpolateImageFunctionISS22Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS22Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS22Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS22Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS22Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS22Welch)
itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch___New_orig__
itkWindowedSincInterpolateImageFunctionISS22Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS22Welch_cast


def itkWindowedSincInterpolateImageFunctionISS23Cosine_New():
    return itkWindowedSincInterpolateImageFunctionISS23Cosine.New()

class itkWindowedSincInterpolateImageFunctionISS23Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS23Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS23Cosine)
itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionISS23Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Cosine_cast


def itkWindowedSincInterpolateImageFunctionISS23Hamming_New():
    return itkWindowedSincInterpolateImageFunctionISS23Hamming.New()

class itkWindowedSincInterpolateImageFunctionISS23Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS23Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS23Hamming)
itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionISS23Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Hamming_cast


def itkWindowedSincInterpolateImageFunctionISS23Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionISS23Lanczos.New()

class itkWindowedSincInterpolateImageFunctionISS23Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS23Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS23Lanczos)
itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Lanczos_cast


def itkWindowedSincInterpolateImageFunctionISS23Welch_New():
    return itkWindowedSincInterpolateImageFunctionISS23Welch.New()

class itkWindowedSincInterpolateImageFunctionISS23Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS23Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS23Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS23Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS23Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS23Welch)
itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch___New_orig__
itkWindowedSincInterpolateImageFunctionISS23Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS23Welch_cast


def itkWindowedSincInterpolateImageFunctionISS32Cosine_New():
    return itkWindowedSincInterpolateImageFunctionISS32Cosine.New()

class itkWindowedSincInterpolateImageFunctionISS32Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS32Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS32Cosine)
itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionISS32Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Cosine_cast


def itkWindowedSincInterpolateImageFunctionISS32Hamming_New():
    return itkWindowedSincInterpolateImageFunctionISS32Hamming.New()

class itkWindowedSincInterpolateImageFunctionISS32Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS32Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS32Hamming)
itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionISS32Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Hamming_cast


def itkWindowedSincInterpolateImageFunctionISS32Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionISS32Lanczos.New()

class itkWindowedSincInterpolateImageFunctionISS32Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS32Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS32Lanczos)
itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Lanczos_cast


def itkWindowedSincInterpolateImageFunctionISS32Welch_New():
    return itkWindowedSincInterpolateImageFunctionISS32Welch.New()

class itkWindowedSincInterpolateImageFunctionISS32Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS32Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS32Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS32Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS32Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS32Welch)
itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch___New_orig__
itkWindowedSincInterpolateImageFunctionISS32Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS32Welch_cast


def itkWindowedSincInterpolateImageFunctionISS33Cosine_New():
    return itkWindowedSincInterpolateImageFunctionISS33Cosine.New()

class itkWindowedSincInterpolateImageFunctionISS33Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS33Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionISS33Cosine)
itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionISS33Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Cosine_cast


def itkWindowedSincInterpolateImageFunctionISS33Hamming_New():
    return itkWindowedSincInterpolateImageFunctionISS33Hamming.New()

class itkWindowedSincInterpolateImageFunctionISS33Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS33Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionISS33Hamming)
itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionISS33Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Hamming_cast


def itkWindowedSincInterpolateImageFunctionISS33Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionISS33Lanczos.New()

class itkWindowedSincInterpolateImageFunctionISS33Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS33Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionISS33Lanczos)
itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Lanczos_cast


def itkWindowedSincInterpolateImageFunctionISS33Welch_New():
    return itkWindowedSincInterpolateImageFunctionISS33Welch.New()

class itkWindowedSincInterpolateImageFunctionISS33Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionISS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionISS33Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionISS33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionISS33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionISS33Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionISS33Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionISS33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionISS33Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_swigregister(itkWindowedSincInterpolateImageFunctionISS33Welch)
itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch___New_orig__
itkWindowedSincInterpolateImageFunctionISS33Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionISS33Welch_cast


def itkWindowedSincInterpolateImageFunctionIUC22Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUC22Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUC22Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC22Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Cosine)
itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUC22Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUC22Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUC22Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC22Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Hamming)
itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUC22Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUC22Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC22Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Lanczos)
itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUC22Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUC22Welch.New()

class itkWindowedSincInterpolateImageFunctionIUC22Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC22Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC22Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC22Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC22Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC22Welch)
itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUC22Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC22Welch_cast


def itkWindowedSincInterpolateImageFunctionIUC23Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUC23Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUC23Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC23Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Cosine)
itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUC23Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUC23Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUC23Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC23Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Hamming)
itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUC23Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUC23Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC23Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Lanczos)
itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUC23Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUC23Welch.New()

class itkWindowedSincInterpolateImageFunctionIUC23Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC23Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC23Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC23Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC23Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC23Welch)
itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUC23Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC23Welch_cast


def itkWindowedSincInterpolateImageFunctionIUC32Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUC32Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUC32Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC32Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Cosine)
itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUC32Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUC32Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUC32Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC32Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Hamming)
itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUC32Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUC32Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC32Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Lanczos)
itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUC32Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUC32Welch.New()

class itkWindowedSincInterpolateImageFunctionIUC32Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC32Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC32Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC32Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC32Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC32Welch)
itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUC32Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC32Welch_cast


def itkWindowedSincInterpolateImageFunctionIUC33Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUC33Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUC33Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC33Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Cosine)
itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUC33Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUC33Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUC33Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC33Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Hamming)
itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUC33Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUC33Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC33Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Lanczos)
itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUC33Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUC33Welch.New()

class itkWindowedSincInterpolateImageFunctionIUC33Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUC3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUC33Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUC33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUC33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUC33Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUC33Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUC33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUC33Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUC33Welch)
itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUC33Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUC33Welch_cast


def itkWindowedSincInterpolateImageFunctionIUS22Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUS22Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUS22Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS22Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Cosine)
itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUS22Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUS22Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUS22Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS22Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Hamming)
itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUS22Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUS22Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS22Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Lanczos)
itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUS22Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUS22Welch.New()

class itkWindowedSincInterpolateImageFunctionIUS22Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS22Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS22Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS22Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS22Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS22Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS22Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS22Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS22Welch)
itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUS22Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS22Welch_cast


def itkWindowedSincInterpolateImageFunctionIUS23Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUS23Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUS23Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS23Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Cosine)
itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUS23Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUS23Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUS23Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS23Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Hamming)
itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUS23Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUS23Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS23Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Lanczos)
itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUS23Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUS23Welch.New()

class itkWindowedSincInterpolateImageFunctionIUS23Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS2D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS23Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS23Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS23Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS23Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS23Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS23Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS23Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS23Welch)
itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUS23Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS23Welch_cast


def itkWindowedSincInterpolateImageFunctionIUS32Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUS32Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUS32Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS32Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Cosine)
itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUS32Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUS32Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUS32Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS32Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Hamming)
itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUS32Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUS32Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS32Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Lanczos)
itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUS32Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUS32Welch.New()

class itkWindowedSincInterpolateImageFunctionIUS32Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS32Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS32Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS32Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS32Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS32Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS32Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS32Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS32Welch)
itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUS32Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS32Welch_cast


def itkWindowedSincInterpolateImageFunctionIUS33Cosine_New():
    return itkWindowedSincInterpolateImageFunctionIUS33Cosine.New()

class itkWindowedSincInterpolateImageFunctionIUS33Cosine(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Cosine
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Cosine

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Cosine and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Cosine.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Cosine.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Cosine.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS33Cosine in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Cosine)
itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine___New_orig__
itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Cosine_cast


def itkWindowedSincInterpolateImageFunctionIUS33Hamming_New():
    return itkWindowedSincInterpolateImageFunctionIUS33Hamming.New()

class itkWindowedSincInterpolateImageFunctionIUS33Hamming(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Hamming
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Hamming

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Hamming and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Hamming.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Hamming.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Hamming.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS33Hamming in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Hamming)
itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming___New_orig__
itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Hamming_cast


def itkWindowedSincInterpolateImageFunctionIUS33Lanczos_New():
    return itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New()

class itkWindowedSincInterpolateImageFunctionIUS33Lanczos(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Lanczos
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Lanczos

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Lanczos and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Lanczos.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Lanczos.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS33Lanczos in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Lanczos)
itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos___New_orig__
itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Lanczos_cast


def itkWindowedSincInterpolateImageFunctionIUS33Welch_New():
    return itkWindowedSincInterpolateImageFunctionIUS33Welch.New()

class itkWindowedSincInterpolateImageFunctionIUS33Welch(itk.itkInterpolateImageFunctionPython.itkInterpolateImageFunctionIUS3D):
    r"""


    Use the windowed sinc function to interpolate.

    Paul A. Yushkevich THEORY  This function is intended to provide an
    interpolation function that has minimum aliasing artifacts, in
    contrast to linear interpolation. According to sampling theory, the
    infinite-support sinc filter, whose Fourier transform is the box
    filter, is optimal for resampling a function. In practice, the
    infinite support sinc filter is approximated using a limited support
    'windowed' sinc filter.

    This function is based on the following publication:

    Erik H. W. Meijering, Wiro J. Niessen, Josien P. W. Pluim, Max A.
    Viergever: Quantitative Comparison of Sinc-Approximating Kernels for
    Medical Image Interpolation. MICCAI 1999, pp. 210-217

    In this work, several 'windows' are estimated. In two dimensions, the
    interpolation at a position (x,y) is given by the following
    expression:

    \\[ I(x,y) = \\sum_{i = \\lfloor x \\rfloor + 1 -
    m}^{\\lfloor x \\rfloor + m} \\sum_{j = \\lfloor y \\rfloor
    + 1 - m}^{\\lfloor y \\rfloor + m} I_{i,j} K(x-i) K(y-j), \\]

    where m is the 'radius' of the window, (3,4 are reasonable numbers),
    and K(t) is the kernel function, composed of the sinc function and one
    of several possible window functions:

    \\[ K(t) = w(t) \\textrm{sinc}(t) = w(t) \\frac{\\sin(\\pi
    t)}{\\pi t} \\]

    Several window functions are provided here in the itk::Function
    namespace. The conclusions of the referenced paper suggest to use the
    Welch, Cosine, Kaiser, and Lanczos windows for m = 4,5. These are
    based on error in rotating medical images w.r.t. the linear
    interpolation method. In some cases the results achieve a 20-fold
    improvement in accuracy. USING THIS FILTER  Use this filter the way
    you would use any ImageInterpolationFunction, so for instance, you can
    plug it into the ResampleImageFilter class. In order to initialize the
    filter you must choose several template parameters.

    The first (TInputImage) is the image type, that's standard.

    The second (VRadius) is the radius of the kernel, i.e., the $ m $ from
    the formula above.

    The third (TWindowFunction) is the window function object, which you
    can choose from about five different functions defined in this header.
    The default is the Hamming window, which is commonly used but not
    optimal according to the cited paper.

    The fourth (TBoundaryCondition) is the boundary condition class used
    to determine the values of pixels that fall off the image boundary.
    This class has the same meaning here as in the NeighborhoodItetator
    classes.

    The fifth (TCoordRep) is again standard for interpolating functions,
    and should be float or double. CAVEATS  There are a few improvements
    that an enthusiastic ITK developer could make to this filter. One
    issue is with the way that the kernel is applied. The computational
    expense comes from two sources: computing the kernel weights K(t) and
    multiplying the pixels in the window by the kernel weights. The first
    is done more or less efficiently in $ 2 m d $ operations (where d is
    the dimensionality of the image). The second can be done better.
    Presently, each pixel $ I(i,j,k) $ is multiplied by the weights $
    K(x-i), K(y-j), K(z-k) $ and added to the running total. This results
    in $ d (2m)^d $ multiplication operations. However, by keeping
    intermediate sums, it would be possible to do the operation in $ O (
    (2m)^d ) $ operations. This would require some creative coding. In
    addition, in the case when one of the coordinates is integer, the
    computation could be reduced by an order of magnitude.

    See:   LinearInterpolateImageFunction ResampleImageFilter

    See:   Function::HammingWindowFunction

    See:   Function::CosineWindowFunction

    See:   Function::WelchWindowFunction

    See:   Function::LanczosWindowFunction

    See:   Function::BlackmanWindowFunction 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__)
    Clone = _swig_new_instance_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_Clone)
    __swig_destroy__ = _itkWindowedSincInterpolateImageFunctionPython.delete_itkWindowedSincInterpolateImageFunctionIUS33Welch
    cast = _swig_new_static_method(_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_cast)

    def New(*args, **kargs):
        """New() -> itkWindowedSincInterpolateImageFunctionIUS33Welch

        Create a new object of the class itkWindowedSincInterpolateImageFunctionIUS33Welch and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkWindowedSincInterpolateImageFunctionIUS33Welch.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkWindowedSincInterpolateImageFunctionIUS33Welch.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkWindowedSincInterpolateImageFunctionIUS33Welch.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkWindowedSincInterpolateImageFunctionIUS33Welch in _itkWindowedSincInterpolateImageFunctionPython:
_itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_swigregister(itkWindowedSincInterpolateImageFunctionIUS33Welch)
itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__ = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch___New_orig__
itkWindowedSincInterpolateImageFunctionIUS33Welch_cast = _itkWindowedSincInterpolateImageFunctionPython.itkWindowedSincInterpolateImageFunctionIUS33Welch_cast



