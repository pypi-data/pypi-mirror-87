# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKConvolutionPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkMaskedFFTNormalizedCorrelationImageFilterPython
else:
    import _itkMaskedFFTNormalizedCorrelationImageFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkMaskedFFTNormalizedCorrelationImageFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkMaskedFFTNormalizedCorrelationImageFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.ITKCommonBasePython
import itk.pyBasePython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkFixedArrayPython
import itk.itkSizePython
import itk.itkCovariantVectorPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkRGBPixelPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkImageRegionPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkImageToImageFilterAPython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython
import itk.itkImageSourcePython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterCommonPython

def itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterID2ID2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterID2ID2(itk.itkImageToImageFilterAPython.itkImageToImageFilterID2ID2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterID2ID2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterID2ID2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterID2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterID2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterID2ID2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterID2ID2)
itkMaskedFFTNormalizedCorrelationImageFilterID2ID2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterID2IF2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterID2IF2(itk.itkImageToImageFilterAPython.itkImageToImageFilterID2IF2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterID2IF2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterID2IF2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterID2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterID2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterID2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterID2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterID2IF2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterID2IF2)
itkMaskedFFTNormalizedCorrelationImageFilterID2IF2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterID3ID3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterID3ID3(itk.itkImageToImageFilterAPython.itkImageToImageFilterID3ID3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterID3ID3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterID3ID3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterID3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterID3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterID3ID3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterID3ID3)
itkMaskedFFTNormalizedCorrelationImageFilterID3ID3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterID3IF3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterID3IF3(itk.itkImageToImageFilterAPython.itkImageToImageFilterID3IF3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterID3IF3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterID3IF3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterID3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterID3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterID3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterID3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterID3IF3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterID3IF3)
itkMaskedFFTNormalizedCorrelationImageFilterID3IF3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIF2ID2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2)
itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIF2IF2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2)
itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIF3ID3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3)
itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIF3IF3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3)
itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2(itk.itkImageToImageFilterAPython.itkImageToImageFilterISS2ID2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2)
itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2(itk.itkImageToImageFilterAPython.itkImageToImageFilterISS2IF2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2)
itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3(itk.itkImageToImageFilterAPython.itkImageToImageFilterISS3ID3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3)
itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3(itk.itkImageToImageFilterAPython.itkImageToImageFilterISS3IF3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3)
itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUC2ID2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2)
itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUC2IF2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2)
itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUC3ID3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3)
itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUC3IF3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3)
itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUS2ID2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2)
itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUS2IF2):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2)
itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUS3ID3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3)
itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3_cast


def itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_New():
    return itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3.New()

class itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3(itk.itkImageToImageFilterAPython.itkImageToImageFilterIUS3IF3):
    r"""


    Calculate masked normalized cross correlation using FFTs.

    This filter calculates the masked normalized cross correlation (NCC)
    of two images under masks using FFTs instead of spatial correlation.
    It is much faster than spatial correlation for reasonably large
    structuring elements. This filter is not equivalent to simply masking
    the images first and then correlating them; the latter approach yields
    incorrect results because the zeros in the images still affect the
    metric in the correlation process. This filter implements the masked
    NCC correctly so that the masked-out regions are completely ignored.
    The fundamental difference is described in detail in the references
    below. If the masks are set to images of all ones, the result of this
    filter is the same as standard NCC.

    Inputs: Two images are required as inputs, fixedImage and movingImage,
    and two are optional, fixedMask and movingMask. In the context of
    correlation, inputs are often defined as: "image" and "template".
    In this filter, the fixedImage plays the role of the image, and the
    movingImage plays the role of the template. However, this filter is
    capable of correlating any two images and is not restricted to small
    movingImages (templates). In the fixedMask and movingMask, non-zero
    positive values indicate locations of useful information in the
    corresponding image, whereas zero and negative values indicate
    locations that should be masked out (ignored). Internally, the masks
    are converted to have values of only 0 and 1. For each optional mask
    that is not set, the filter internally creates an image of ones, which
    is equivalent to not masking the image. Thus, if both masks are not
    set, the result will be equivalent to unmasked NCC. movingMask can
    either not be set or can be set to an image of ones.

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify the minimum number of voxels of the two masks that
    must overlap; any location in the correlation map that results from
    fewer than this number of voxels will be set to zero. Larger values
    zero-out pixels on a larger border around the correlation image. Thus,
    larger values remove less stable computations but also limit the
    capture range. If RequiredNumberOfOverlappingPixels is set to 0, the
    default, no zeroing will take place.

    The RequiredFractionOfOverlappingPixels enables the user to specify a
    fraction of the maximum number of overlapping pixels that need to
    overlap; any location in the correlation map that results from fewer
    than the product of this fraction and the internally computed maximum
    number of overlapping pixels will be set to zero. The value ranges
    between 0.0 and 1.0. This is very useful when the user does does not
    know beforehand the maximum number of pixels of the masks that will
    overlap. how the correlation of the masks will interact and what the
    maximum overlap will be. It is also useful when the mask shapes or
    sizes change because it is relative to the internally computed maximum
    of the overlap. Larger values zero-out pixels on a larger border
    around the correlation image. Thus, larger values remove less stable
    computations but also limit the capture range. Experiments have shown
    that a value between 0.1 and 0.6 works well for images with
    significant overlap and between 0.05 and 0.1 for images with little
    overlap (such as in stitching applications). If
    RequiredFractionOfOverlappingPixels is set to 0, the default, no
    zeroing will take place.

    The user can either specify RequiredNumberOfOverlappingPixels or
    RequiredFractionOfOverlappingPixels (or both or none). Internally, the
    number of required pixels resulting from both of these methods is
    calculated and the one that gives the largest number of pixels is
    chosen. Since these both default to 0, if a user only sets one, the
    other is ignored.

    Image size: fixedImage and movingImage need not be the same size, but
    fixedMask must be the same size as fixedImage, and movingMask must be
    the same size as movingImage. Furthermore, whereas some algorithms
    require that the "template" be smaller than the "image" because of
    errors in the regions where the two are not fully overlapping, this
    filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the masked
    NCC of the two images and its values range from -1.0 to 1.0. The size
    of this NCC image is, by definition, size(fixedImage) +
    size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com  With
    Mask Images For Input Images} 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_Clone)
    SetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetFixedImage)
    GetFixedImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetFixedImage)
    SetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetMovingImage)
    GetMovingImage = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetMovingImage)
    SetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetFixedImageMask)
    GetFixedImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetFixedImageMask)
    SetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetMovingImageMask)
    GetMovingImageMask = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetMovingImageMask)
    SetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetRequiredNumberOfOverlappingPixels)
    GetRequiredNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetRequiredNumberOfOverlappingPixels)
    GetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetRequiredFractionOfOverlappingPixels)
    SetRequiredFractionOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_SetRequiredFractionOfOverlappingPixels)
    GetMaximumNumberOfOverlappingPixels = _swig_new_instance_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_GetMaximumNumberOfOverlappingPixels)
    OutputPixelTypeIsFloatingPointCheck = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_OutputPixelTypeIsFloatingPointCheck
    
    __swig_destroy__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.delete_itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3
    cast = _swig_new_static_method(_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3

        Create a new object of the class itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3 in _itkMaskedFFTNormalizedCorrelationImageFilterPython:
_itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_swigregister(itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3)
itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__ = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__
itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_cast = _itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3_cast


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def masked_fft_normalized_correlation_image_filter(*args, **kwargs):
    """Procedural interface for MaskedFFTNormalizedCorrelationImageFilter"""
    import itk
    instance = itk.MaskedFFTNormalizedCorrelationImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def masked_fft_normalized_correlation_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.MaskedFFTNormalizedCorrelationImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.MaskedFFTNormalizedCorrelationImageFilter.values()[0]
    else:
        filter_object = itk.MaskedFFTNormalizedCorrelationImageFilter

    masked_fft_normalized_correlation_image_filter.__doc__ = filter_object.__doc__
    masked_fft_normalized_correlation_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    masked_fft_normalized_correlation_image_filter.__doc__ += "\n Available Keyword Arguments:\n"
    if isinstance(itk.MaskedFFTNormalizedCorrelationImageFilter, itkTemplate.itkTemplate):
        masked_fft_normalized_correlation_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        masked_fft_normalized_correlation_image_filter.__doc__ += "\n"
        masked_fft_normalized_correlation_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        masked_fft_normalized_correlation_image_filter.__doc__ += "".join([
            "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
            for item in dir(filter_object)
            if item.startswith("Set")])



