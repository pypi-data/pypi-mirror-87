# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKTransformPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkAffineTransformPython
else:
    import _itkAffineTransformPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkAffineTransformPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkAffineTransformPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkMatrixPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.vnl_matrixPython
import itk.itkPointPython
import itk.itkVectorPython
import itk.itkFixedArrayPython
import itk.vnl_vector_refPython
import itk.vnl_matrix_fixedPython
import itk.itkCovariantVectorPython
import itk.itkMatrixOffsetTransformBasePython
import itk.itkOptimizerParametersPython
import itk.itkArrayPython
import itk.ITKCommonBasePython
import itk.itkTransformBasePython
import itk.itkArray2DPython
import itk.itkVariableLengthVectorPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkDiffusionTensor3DPython

def itkAffineTransformD2_New():
    return itkAffineTransformD2.New()

class itkAffineTransformD2(itk.itkMatrixOffsetTransformBasePython.itkMatrixOffsetTransformBaseD22):
    r"""


    Affine transformation of a vector space (e.g. space coordinates)

    This class allows the definition and manipulation of affine
    transformations of an n-dimensional affine space (and its associated
    vector space) onto itself. One common use is to define and manipulate
    Euclidean coordinate transformations in two and three dimensions, but
    other uses are possible as well.

    An affine transformation is defined mathematically as a linear
    transformation plus a constant offset. If A is a constant n x n matrix
    and b is a constant n-vector, then y = Ax+b defines an affine
    transformation from the n-vector x to the n-vector y.

    The difference between two points is a vector and transforms linearly,
    using the matrix only. That is, (y1-y2) = A*(x1-x2).

    The AffineTransform class determines whether to transform an object as
    a point or a vector by examining its type. An object of type Point
    transforms as a point; an object of type Vector transforms as a
    vector.

    One common use of affine transformations is to define coordinate
    conversions in two- and three-dimensional space. In this application,
    x is a two- or three-dimensional vector containing the "source"
    coordinates of a point, y is a vector containing the "target"
    coordinates, the matrix A defines the scaling and rotation of the
    coordinate systems from the source to the target, and b defines the
    translation of the origin from the source to the target. More
    generally, A can also define anisotropic scaling and shearing
    transformations. Any good textbook on computer graphics will discuss
    coordinate transformations in more detail. Several of the methods in
    this class are designed for this purpose and use the language
    appropriate to coordinate conversions.

    Any two affine transformations may be composed and the result is
    another affine transformation. However, the order is important. Given
    two affine transformations T1 and T2, we will say that "precomposing
    T1 with T2" yields the transformation which applies T1 to the source,
    and then applies T2 to that result to obtain the target. Conversely,
    we will say that "postcomposing T1 with T2" yields the
    transformation which applies T2 to the source, and then applies T1 to
    that result to obtain the target. (Whether T1 or T2 comes first
    lexicographically depends on whether you choose to write mappings from
    right-to-left or vice versa; we avoid the whole problem by referring
    to the order of application rather than the textual order.)

    There are two template parameters for this class:

    TParametersValueType The type to be used for scalar numeric values.
    Either float or double.

    NDimensions The number of dimensions of the vector space.

    This class provides several methods for setting the matrix and vector
    defining the transform. To support the registration framework, the
    transform parameters can also be set as an Array<double> of size
    (NDimension + 1) * NDimension using method SetParameters(). The first
    (NDimension x NDimension) parameters defines the matrix in row-major
    order (where the column index varies the fastest). The last NDimension
    parameters defines the translation in each dimensions.

    This class also supports the specification of a center of rotation
    (center) and a translation that is applied with respect to that
    centered rotation. By default the center of rotation is set to the
    origin. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkAffineTransformPython.itkAffineTransformD2___New_orig__)
    Clone = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Clone)
    Translate = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Translate)
    Scale = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Scale)
    Rotate = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Rotate)
    Rotate2D = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Rotate2D)
    Rotate3D = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Rotate3D)
    Shear = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Shear)
    GetInverse = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_GetInverse)
    Metric = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD2_Metric)
    __swig_destroy__ = _itkAffineTransformPython.delete_itkAffineTransformD2
    cast = _swig_new_static_method(_itkAffineTransformPython.itkAffineTransformD2_cast)

    def New(*args, **kargs):
        """New() -> itkAffineTransformD2

        Create a new object of the class itkAffineTransformD2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAffineTransformD2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkAffineTransformD2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkAffineTransformD2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkAffineTransformD2 in _itkAffineTransformPython:
_itkAffineTransformPython.itkAffineTransformD2_swigregister(itkAffineTransformD2)
itkAffineTransformD2___New_orig__ = _itkAffineTransformPython.itkAffineTransformD2___New_orig__
itkAffineTransformD2_cast = _itkAffineTransformPython.itkAffineTransformD2_cast


def itkAffineTransformD3_New():
    return itkAffineTransformD3.New()

class itkAffineTransformD3(itk.itkMatrixOffsetTransformBasePython.itkMatrixOffsetTransformBaseD33):
    r"""


    Affine transformation of a vector space (e.g. space coordinates)

    This class allows the definition and manipulation of affine
    transformations of an n-dimensional affine space (and its associated
    vector space) onto itself. One common use is to define and manipulate
    Euclidean coordinate transformations in two and three dimensions, but
    other uses are possible as well.

    An affine transformation is defined mathematically as a linear
    transformation plus a constant offset. If A is a constant n x n matrix
    and b is a constant n-vector, then y = Ax+b defines an affine
    transformation from the n-vector x to the n-vector y.

    The difference between two points is a vector and transforms linearly,
    using the matrix only. That is, (y1-y2) = A*(x1-x2).

    The AffineTransform class determines whether to transform an object as
    a point or a vector by examining its type. An object of type Point
    transforms as a point; an object of type Vector transforms as a
    vector.

    One common use of affine transformations is to define coordinate
    conversions in two- and three-dimensional space. In this application,
    x is a two- or three-dimensional vector containing the "source"
    coordinates of a point, y is a vector containing the "target"
    coordinates, the matrix A defines the scaling and rotation of the
    coordinate systems from the source to the target, and b defines the
    translation of the origin from the source to the target. More
    generally, A can also define anisotropic scaling and shearing
    transformations. Any good textbook on computer graphics will discuss
    coordinate transformations in more detail. Several of the methods in
    this class are designed for this purpose and use the language
    appropriate to coordinate conversions.

    Any two affine transformations may be composed and the result is
    another affine transformation. However, the order is important. Given
    two affine transformations T1 and T2, we will say that "precomposing
    T1 with T2" yields the transformation which applies T1 to the source,
    and then applies T2 to that result to obtain the target. Conversely,
    we will say that "postcomposing T1 with T2" yields the
    transformation which applies T2 to the source, and then applies T1 to
    that result to obtain the target. (Whether T1 or T2 comes first
    lexicographically depends on whether you choose to write mappings from
    right-to-left or vice versa; we avoid the whole problem by referring
    to the order of application rather than the textual order.)

    There are two template parameters for this class:

    TParametersValueType The type to be used for scalar numeric values.
    Either float or double.

    NDimensions The number of dimensions of the vector space.

    This class provides several methods for setting the matrix and vector
    defining the transform. To support the registration framework, the
    transform parameters can also be set as an Array<double> of size
    (NDimension + 1) * NDimension using method SetParameters(). The first
    (NDimension x NDimension) parameters defines the matrix in row-major
    order (where the column index varies the fastest). The last NDimension
    parameters defines the translation in each dimensions.

    This class also supports the specification of a center of rotation
    (center) and a translation that is applied with respect to that
    centered rotation. By default the center of rotation is set to the
    origin. 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkAffineTransformPython.itkAffineTransformD3___New_orig__)
    Clone = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Clone)
    Translate = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Translate)
    Scale = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Scale)
    Rotate = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Rotate)
    Rotate2D = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Rotate2D)
    Rotate3D = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Rotate3D)
    Shear = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Shear)
    GetInverse = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_GetInverse)
    Metric = _swig_new_instance_method(_itkAffineTransformPython.itkAffineTransformD3_Metric)
    __swig_destroy__ = _itkAffineTransformPython.delete_itkAffineTransformD3
    cast = _swig_new_static_method(_itkAffineTransformPython.itkAffineTransformD3_cast)

    def New(*args, **kargs):
        """New() -> itkAffineTransformD3

        Create a new object of the class itkAffineTransformD3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkAffineTransformD3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkAffineTransformD3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkAffineTransformD3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkAffineTransformD3 in _itkAffineTransformPython:
_itkAffineTransformPython.itkAffineTransformD3_swigregister(itkAffineTransformD3)
itkAffineTransformD3___New_orig__ = _itkAffineTransformPython.itkAffineTransformD3___New_orig__
itkAffineTransformD3_cast = _itkAffineTransformPython.itkAffineTransformD3_cast



