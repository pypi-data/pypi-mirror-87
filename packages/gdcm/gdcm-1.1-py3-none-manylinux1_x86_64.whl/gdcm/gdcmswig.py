# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

"""A DICOM library"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_gdcmswig')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_gdcmswig')
    _gdcmswig = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_gdcmswig', [dirname(__file__)])
        except ImportError:
            import _gdcmswig
            return _gdcmswig
        try:
            _mod = imp.load_module('_gdcmswig', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _gdcmswig = swig_import_helper()
    del swig_import_helper
else:
    import _gdcmswig
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

try:
    import weakref
    weakref_proxy = weakref.proxy
except __builtin__.Exception:
    weakref_proxy = lambda x: x


class SwigPyIterator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwigPyIterator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwigPyIterator, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_SwigPyIterator
    __del__ = lambda self: None

    def value(self) -> "PyObject *":
        return _gdcmswig.SwigPyIterator_value(self)

    def incr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _gdcmswig.SwigPyIterator_incr(self, n)

    def decr(self, n: 'size_t'=1) -> "swig::SwigPyIterator *":
        return _gdcmswig.SwigPyIterator_decr(self, n)

    def distance(self, x: 'SwigPyIterator') -> "ptrdiff_t":
        return _gdcmswig.SwigPyIterator_distance(self, x)

    def equal(self, x: 'SwigPyIterator') -> "bool":
        return _gdcmswig.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _gdcmswig.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _gdcmswig.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _gdcmswig.SwigPyIterator_previous(self)

    def advance(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _gdcmswig.SwigPyIterator_advance(self, n)

    def __eq__(self, x: 'SwigPyIterator') -> "bool":
        return _gdcmswig.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: 'SwigPyIterator') -> "bool":
        return _gdcmswig.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _gdcmswig.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator &":
        return _gdcmswig.SwigPyIterator___isub__(self, n)

    def __add__(self, n: 'ptrdiff_t') -> "swig::SwigPyIterator *":
        return _gdcmswig.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _gdcmswig.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self
SwigPyIterator_swigregister = _gdcmswig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

PUB_DICT_PATH = _gdcmswig.PUB_DICT_PATH
GDCM_SOURCE_DIR = _gdcmswig.GDCM_SOURCE_DIR
GDCM_EXECUTABLE_OUTPUT_PATH = _gdcmswig.GDCM_EXECUTABLE_OUTPUT_PATH
GDCM_LIBRARY_OUTPUT_PATH = _gdcmswig.GDCM_LIBRARY_OUTPUT_PATH
OPENJPEG_VERSION_MAJOR = _gdcmswig.OPENJPEG_VERSION_MAJOR
GDCM_CMAKE_INSTALL_PREFIX = _gdcmswig.GDCM_CMAKE_INSTALL_PREFIX
GDCM_INSTALL_INCLUDE_DIR = _gdcmswig.GDCM_INSTALL_INCLUDE_DIR
GDCM_INSTALL_DATA_DIR = _gdcmswig.GDCM_INSTALL_DATA_DIR
GDCM_PVRG_JPEG_EXECUTABLE = _gdcmswig.GDCM_PVRG_JPEG_EXECUTABLE
GDCM_KAKADU_EXPAND_EXECUTABLE = _gdcmswig.GDCM_KAKADU_EXPAND_EXECUTABLE
GDCM_MAJOR_VERSION = _gdcmswig.GDCM_MAJOR_VERSION
GDCM_MINOR_VERSION = _gdcmswig.GDCM_MINOR_VERSION
GDCM_BUILD_VERSION = _gdcmswig.GDCM_BUILD_VERSION
GDCM_VERSION = _gdcmswig.GDCM_VERSION
GDCM_API_VERSION = _gdcmswig.GDCM_API_VERSION
class SwapCode(_object):
    """


    SwapCode representation.

    C++ includes: gdcmSwapCode.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SwapCode, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SwapCode, name)
    __repr__ = _swig_repr
    Unknown = _gdcmswig.SwapCode_Unknown
    LittleEndian = _gdcmswig.SwapCode_LittleEndian
    BigEndian = _gdcmswig.SwapCode_BigEndian
    BadLittleEndian = _gdcmswig.SwapCode_BadLittleEndian
    BadBigEndian = _gdcmswig.SwapCode_BadBigEndian

    def __init__(self, *args):
        """gdcm::SwapCode::SwapCode(SwapCodeType sc=Unknown) """
        this = _gdcmswig.new_SwapCode(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        GetSwapCodeString = staticmethod(_gdcmswig.SwapCode_GetSwapCodeString)
    else:
        GetSwapCodeString = _gdcmswig.SwapCode_GetSwapCodeString
    __swig_destroy__ = _gdcmswig.delete_SwapCode
    __del__ = lambda self: None
SwapCode_swigregister = _gdcmswig.SwapCode_swigregister
SwapCode_swigregister(SwapCode)

def SwapCode_GetSwapCodeString(sc: 'SwapCode') -> "char const *":
    return _gdcmswig.SwapCode_GetSwapCodeString(sc)
SwapCode_GetSwapCodeString = _gdcmswig.SwapCode_GetSwapCodeString

class Event(_object):
    """


    superclass for callback/observer methods

    See:   Command Subject

    C++ includes: gdcmEvent.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Event, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Event, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Event
    __del__ = lambda self: None

    def MakeObject(self) -> "gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.Event_MakeObject(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        virtual void
        gdcm::Event::Print(std::ostream &os) const

        Print Event information. This method can be overridden by specific
        Event subtypes. The default is to print out the type of the event. 
        """
        return _gdcmswig.Event_Print(self, os)


    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.Event_GetEventName(self)


    def CheckEvent(self, arg2: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.Event_CheckEvent(self, arg2)

Event_swigregister = _gdcmswig.Event_swigregister
Event_swigregister(Event)

class NoEvent(Event):
    """


    Define some common GDCM events

    C++ includes: gdcmEvent.h 
    """

    __swig_setmethods__ = {}
    for _s in [Event]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NoEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NoEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_NoEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.NoEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.NoEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.NoEvent_MakeObject(self)

NoEvent_swigregister = _gdcmswig.NoEvent_swigregister
NoEvent_swigregister(NoEvent)

class AnyEvent(Event):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [Event]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnyEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [Event]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnyEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_AnyEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.AnyEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.AnyEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.AnyEvent_MakeObject(self)

AnyEvent_swigregister = _gdcmswig.AnyEvent_swigregister
AnyEvent_swigregister(AnyEvent)

class StartEvent(AnyEvent):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StartEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StartEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_StartEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.StartEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.StartEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.StartEvent_MakeObject(self)

StartEvent_swigregister = _gdcmswig.StartEvent_swigregister
StartEvent_swigregister(StartEvent)

class EndEvent(AnyEvent):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, EndEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, EndEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_EndEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.EndEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.EndEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.EndEvent_MakeObject(self)

EndEvent_swigregister = _gdcmswig.EndEvent_swigregister
EndEvent_swigregister(EndEvent)

class ExitEvent(AnyEvent):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ExitEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ExitEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_ExitEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.ExitEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.ExitEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.ExitEvent_MakeObject(self)

ExitEvent_swigregister = _gdcmswig.ExitEvent_swigregister
ExitEvent_swigregister(ExitEvent)

class AbortEvent(AnyEvent):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AbortEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AbortEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_AbortEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.AbortEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.AbortEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.AbortEvent_MakeObject(self)

AbortEvent_swigregister = _gdcmswig.AbortEvent_swigregister
AbortEvent_swigregister(AbortEvent)

class ModifiedEvent(AnyEvent):
    """
    C++ includes: gdcmEvent.h

    """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModifiedEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ModifiedEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_ModifiedEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.ModifiedEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.ModifiedEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.ModifiedEvent_MakeObject(self)

ModifiedEvent_swigregister = _gdcmswig.ModifiedEvent_swigregister
ModifiedEvent_swigregister(ModifiedEvent)

class InitializeEvent(AnyEvent):
    """
    C++ includes:
    gdcmEvent.h 
    """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, InitializeEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, InitializeEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_InitializeEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.InitializeEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.InitializeEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.InitializeEvent_MakeObject(self)

InitializeEvent_swigregister = _gdcmswig.InitializeEvent_swigregister
InitializeEvent_swigregister(InitializeEvent)

class IterationEvent(AnyEvent):
    """
    C++ includes: gdcmEvent.h

    """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IterationEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IterationEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_IterationEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.IterationEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.IterationEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.IterationEvent_MakeObject(self)

IterationEvent_swigregister = _gdcmswig.IterationEvent_swigregister
IterationEvent_swigregister(IterationEvent)

class UserEvent(AnyEvent):
    """C++ includes: gdcmEvent.h """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, UserEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, UserEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_UserEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual const char*
        gdcm::Event::GetEventName(void) const =0

        Return the StringName associated with the event. 
        """
        return _gdcmswig.UserEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::Event::CheckEvent(const Event *) const =0

        Check if given event matches or derives from this event. 
        """
        return _gdcmswig.UserEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual Event*
        gdcm::Event::MakeObject() const =0

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.UserEvent_MakeObject(self)

UserEvent_swigregister = _gdcmswig.UserEvent_swigregister
UserEvent_swigregister(UserEvent)

class PixelFormat(_object):
    """


    PixelFormat.

    By default the Pixel Type will be instanciated with the following
    parameters: SamplesPerPixel : 1

    BitsAllocated : 8

    BitsStored : 8

    HighBit : 7

    PixelRepresentation : 0

    Fundamentally PixelFormat is very close to what DICOM allows. It will
    be very hard to extend this class for the upcoming DICOM standard
    where Floating 32 and 64bits will be allowed.

    It is also very hard for this class to fully support 64bits integer
    type (see GetMin / GetMax signature restricted to 64bits signed).

    C++ includes: gdcmPixelFormat.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixelFormat, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PixelFormat, name)
    __repr__ = _swig_repr
    UINT8 = _gdcmswig.PixelFormat_UINT8
    INT8 = _gdcmswig.PixelFormat_INT8
    UINT12 = _gdcmswig.PixelFormat_UINT12
    INT12 = _gdcmswig.PixelFormat_INT12
    UINT16 = _gdcmswig.PixelFormat_UINT16
    INT16 = _gdcmswig.PixelFormat_INT16
    UINT32 = _gdcmswig.PixelFormat_UINT32
    INT32 = _gdcmswig.PixelFormat_INT32
    UINT64 = _gdcmswig.PixelFormat_UINT64
    INT64 = _gdcmswig.PixelFormat_INT64
    FLOAT16 = _gdcmswig.PixelFormat_FLOAT16
    FLOAT32 = _gdcmswig.PixelFormat_FLOAT32
    FLOAT64 = _gdcmswig.PixelFormat_FLOAT64
    SINGLEBIT = _gdcmswig.PixelFormat_SINGLEBIT
    UNKNOWN = _gdcmswig.PixelFormat_UNKNOWN

    def __init__(self, *args):
        """gdcm::PixelFormat::PixelFormat(ScalarType st) """
        this = _gdcmswig.new_PixelFormat(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetSamplesPerPixel(self) -> "unsigned short":
        """
        unsigned short gdcm::PixelFormat::GetSamplesPerPixel() const

        Samples Per Pixel see (0028,0002) US Samples Per Pixel DICOM - only
        allows 1, 3 and 4 as valid value. Other value are undefined behavior.

        """
        return _gdcmswig.PixelFormat_GetSamplesPerPixel(self)


    def SetSamplesPerPixel(self, spp: 'unsigned short') -> "void":
        """
        void
        gdcm::PixelFormat::SetSamplesPerPixel(unsigned short spp) 
        """
        return _gdcmswig.PixelFormat_SetSamplesPerPixel(self, spp)


    def GetBitsAllocated(self) -> "unsigned short":
        """
        unsigned
        short gdcm::PixelFormat::GetBitsAllocated() const

        BitsAllocated see Tag (0028,0100) US Bits Allocated. 
        """
        return _gdcmswig.PixelFormat_GetBitsAllocated(self)


    def SetBitsAllocated(self, ba: 'unsigned short') -> "void":
        """
        void
        gdcm::PixelFormat::SetBitsAllocated(unsigned short ba) 
        """
        return _gdcmswig.PixelFormat_SetBitsAllocated(self, ba)


    def GetBitsStored(self) -> "unsigned short":
        """
        unsigned
        short gdcm::PixelFormat::GetBitsStored() const

        BitsStored see Tag (0028,0101) US Bits Stored. 
        """
        return _gdcmswig.PixelFormat_GetBitsStored(self)


    def SetBitsStored(self, bs: 'unsigned short') -> "void":
        """
        void
        gdcm::PixelFormat::SetBitsStored(unsigned short bs) 
        """
        return _gdcmswig.PixelFormat_SetBitsStored(self, bs)


    def GetHighBit(self) -> "unsigned short":
        """
        unsigned short
        gdcm::PixelFormat::GetHighBit() const

        HighBit see Tag (0028,0102) US High Bit. 
        """
        return _gdcmswig.PixelFormat_GetHighBit(self)


    def SetHighBit(self, hb: 'unsigned short') -> "void":
        """
        void
        gdcm::PixelFormat::SetHighBit(unsigned short hb) 
        """
        return _gdcmswig.PixelFormat_SetHighBit(self, hb)


    def GetPixelRepresentation(self) -> "unsigned short":
        """
        unsigned short gdcm::PixelFormat::GetPixelRepresentation() const

        PixelRepresentation: 0 or 1, see Tag (0028,0103) US Pixel
        Representation. 
        """
        return _gdcmswig.PixelFormat_GetPixelRepresentation(self)


    def SetPixelRepresentation(self, pr: 'unsigned short') -> "void":
        """void gdcm::PixelFormat::SetPixelRepresentation(unsigned short pr) """
        return _gdcmswig.PixelFormat_SetPixelRepresentation(self, pr)


    def GetScalarType(self) -> "gdcm::PixelFormat::ScalarType":
        """
        ScalarType
        gdcm::PixelFormat::GetScalarType() const

        ScalarType does not take into account the sample per pixel. 
        """
        return _gdcmswig.PixelFormat_GetScalarType(self)


    def SetScalarType(self, st: 'gdcm::PixelFormat::ScalarType') -> "void":
        """
        void
        gdcm::PixelFormat::SetScalarType(ScalarType st)

        Set PixelFormat based only on the ScalarType WARNING:  : You need to
        call SetScalarType before SetSamplesPerPixel 
        """
        return _gdcmswig.PixelFormat_SetScalarType(self, st)


    def GetScalarTypeAsString(self) -> "char const *":
        """const char* gdcm::PixelFormat::GetScalarTypeAsString() const """
        return _gdcmswig.PixelFormat_GetScalarTypeAsString(self)


    def GetPixelSize(self) -> "uint8_t":
        """
        uint8_t
        gdcm::PixelFormat::GetPixelSize() const

        return the size of the pixel This is the number of words it would take
        to store one pixel WARNING:  the return value takes into account the
        SamplesPerPixel

        WARNING:  in the rare case when BitsAllocated == 12, the function
        assume word padding and value returned will be identical as if
        BitsAllocated == 16 
        """
        return _gdcmswig.PixelFormat_GetPixelSize(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::PixelFormat::Print(std::ostream &os) const

        Print. 
        """
        return _gdcmswig.PixelFormat_Print(self, os)


    def GetMin(self) -> "int64_t":
        """
        int64_t
        gdcm::PixelFormat::GetMin() const

        return the min possible of the pixel 
        """
        return _gdcmswig.PixelFormat_GetMin(self)


    def GetMax(self) -> "int64_t":
        """
        int64_t
        gdcm::PixelFormat::GetMax() const

        return the max possible of the pixel 
        """
        return _gdcmswig.PixelFormat_GetMax(self)


    def IsValid(self) -> "bool":
        """
        bool
        gdcm::PixelFormat::IsValid() const

        return IsValid 
        """
        return _gdcmswig.PixelFormat_IsValid(self)


    def __eq__(self, *args) -> "bool":
        return _gdcmswig.PixelFormat___eq__(self, *args)

    def __ne__(self, *args) -> "bool":
        return _gdcmswig.PixelFormat___ne__(self, *args)

    def IsCompatible(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::PixelFormat::IsCompatible(const TransferSyntax &ts) const 
        """
        return _gdcmswig.PixelFormat_IsCompatible(self, ts)


    def __str__(self) -> "char const *":
        return _gdcmswig.PixelFormat___str__(self)
    __swig_destroy__ = _gdcmswig.delete_PixelFormat
    __del__ = lambda self: None
PixelFormat_swigregister = _gdcmswig.PixelFormat_swigregister
PixelFormat_swigregister(PixelFormat)

class MediaStorage(_object):
    """


    MediaStorage.

    FIXME There should not be any notion of Image and/or PDF at that point
    Only the codec can answer yes I support this Media Storage or not...
    For instance an ImageCodec will answer yes to most of them while a
    PDFCodec will answer only for the Encapsulated PDF

    See:   UIDs

    C++ includes: gdcmMediaStorage.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MediaStorage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MediaStorage, name)
    __repr__ = _swig_repr
    MediaStorageDirectoryStorage = _gdcmswig.MediaStorage_MediaStorageDirectoryStorage
    ComputedRadiographyImageStorage = _gdcmswig.MediaStorage_ComputedRadiographyImageStorage
    DigitalXRayImageStorageForPresentation = _gdcmswig.MediaStorage_DigitalXRayImageStorageForPresentation
    DigitalXRayImageStorageForProcessing = _gdcmswig.MediaStorage_DigitalXRayImageStorageForProcessing
    DigitalMammographyImageStorageForPresentation = _gdcmswig.MediaStorage_DigitalMammographyImageStorageForPresentation
    DigitalMammographyImageStorageForProcessing = _gdcmswig.MediaStorage_DigitalMammographyImageStorageForProcessing
    DigitalIntraoralXrayImageStorageForPresentation = _gdcmswig.MediaStorage_DigitalIntraoralXrayImageStorageForPresentation
    DigitalIntraoralXRayImageStorageForProcessing = _gdcmswig.MediaStorage_DigitalIntraoralXRayImageStorageForProcessing
    CTImageStorage = _gdcmswig.MediaStorage_CTImageStorage
    EnhancedCTImageStorage = _gdcmswig.MediaStorage_EnhancedCTImageStorage
    UltrasoundImageStorageRetired = _gdcmswig.MediaStorage_UltrasoundImageStorageRetired
    UltrasoundImageStorage = _gdcmswig.MediaStorage_UltrasoundImageStorage
    UltrasoundMultiFrameImageStorageRetired = _gdcmswig.MediaStorage_UltrasoundMultiFrameImageStorageRetired
    UltrasoundMultiFrameImageStorage = _gdcmswig.MediaStorage_UltrasoundMultiFrameImageStorage
    MRImageStorage = _gdcmswig.MediaStorage_MRImageStorage
    EnhancedMRImageStorage = _gdcmswig.MediaStorage_EnhancedMRImageStorage
    MRSpectroscopyStorage = _gdcmswig.MediaStorage_MRSpectroscopyStorage
    NuclearMedicineImageStorageRetired = _gdcmswig.MediaStorage_NuclearMedicineImageStorageRetired
    SecondaryCaptureImageStorage = _gdcmswig.MediaStorage_SecondaryCaptureImageStorage
    MultiframeSingleBitSecondaryCaptureImageStorage = _gdcmswig.MediaStorage_MultiframeSingleBitSecondaryCaptureImageStorage
    MultiframeGrayscaleByteSecondaryCaptureImageStorage = _gdcmswig.MediaStorage_MultiframeGrayscaleByteSecondaryCaptureImageStorage
    MultiframeGrayscaleWordSecondaryCaptureImageStorage = _gdcmswig.MediaStorage_MultiframeGrayscaleWordSecondaryCaptureImageStorage
    MultiframeTrueColorSecondaryCaptureImageStorage = _gdcmswig.MediaStorage_MultiframeTrueColorSecondaryCaptureImageStorage
    StandaloneOverlayStorage = _gdcmswig.MediaStorage_StandaloneOverlayStorage
    StandaloneCurveStorage = _gdcmswig.MediaStorage_StandaloneCurveStorage
    LeadECGWaveformStorage = _gdcmswig.MediaStorage_LeadECGWaveformStorage
    GeneralECGWaveformStorage = _gdcmswig.MediaStorage_GeneralECGWaveformStorage
    AmbulatoryECGWaveformStorage = _gdcmswig.MediaStorage_AmbulatoryECGWaveformStorage
    HemodynamicWaveformStorage = _gdcmswig.MediaStorage_HemodynamicWaveformStorage
    CardiacElectrophysiologyWaveformStorage = _gdcmswig.MediaStorage_CardiacElectrophysiologyWaveformStorage
    BasicVoiceAudioWaveformStorage = _gdcmswig.MediaStorage_BasicVoiceAudioWaveformStorage
    StandaloneModalityLUTStorage = _gdcmswig.MediaStorage_StandaloneModalityLUTStorage
    StandaloneVOILUTStorage = _gdcmswig.MediaStorage_StandaloneVOILUTStorage
    GrayscaleSoftcopyPresentationStateStorageSOPClass = _gdcmswig.MediaStorage_GrayscaleSoftcopyPresentationStateStorageSOPClass
    XRayAngiographicImageStorage = _gdcmswig.MediaStorage_XRayAngiographicImageStorage
    XRayRadiofluoroscopingImageStorage = _gdcmswig.MediaStorage_XRayRadiofluoroscopingImageStorage
    XRayAngiographicBiPlaneImageStorageRetired = _gdcmswig.MediaStorage_XRayAngiographicBiPlaneImageStorageRetired
    NuclearMedicineImageStorage = _gdcmswig.MediaStorage_NuclearMedicineImageStorage
    RawDataStorage = _gdcmswig.MediaStorage_RawDataStorage
    SpacialRegistrationStorage = _gdcmswig.MediaStorage_SpacialRegistrationStorage
    SpacialFiducialsStorage = _gdcmswig.MediaStorage_SpacialFiducialsStorage
    PETImageStorage = _gdcmswig.MediaStorage_PETImageStorage
    RTImageStorage = _gdcmswig.MediaStorage_RTImageStorage
    RTDoseStorage = _gdcmswig.MediaStorage_RTDoseStorage
    RTStructureSetStorage = _gdcmswig.MediaStorage_RTStructureSetStorage
    RTPlanStorage = _gdcmswig.MediaStorage_RTPlanStorage
    CSANonImageStorage = _gdcmswig.MediaStorage_CSANonImageStorage
    Philips3D = _gdcmswig.MediaStorage_Philips3D
    EnhancedSR = _gdcmswig.MediaStorage_EnhancedSR
    BasicTextSR = _gdcmswig.MediaStorage_BasicTextSR
    HardcopyGrayscaleImageStorage = _gdcmswig.MediaStorage_HardcopyGrayscaleImageStorage
    ComprehensiveSR = _gdcmswig.MediaStorage_ComprehensiveSR
    DetachedStudyManagementSOPClass = _gdcmswig.MediaStorage_DetachedStudyManagementSOPClass
    EncapsulatedPDFStorage = _gdcmswig.MediaStorage_EncapsulatedPDFStorage
    EncapsulatedCDAStorage = _gdcmswig.MediaStorage_EncapsulatedCDAStorage
    StudyComponentManagementSOPClass = _gdcmswig.MediaStorage_StudyComponentManagementSOPClass
    DetachedVisitManagementSOPClass = _gdcmswig.MediaStorage_DetachedVisitManagementSOPClass
    DetachedPatientManagementSOPClass = _gdcmswig.MediaStorage_DetachedPatientManagementSOPClass
    VideoEndoscopicImageStorage = _gdcmswig.MediaStorage_VideoEndoscopicImageStorage
    GeneralElectricMagneticResonanceImageStorage = _gdcmswig.MediaStorage_GeneralElectricMagneticResonanceImageStorage
    GEPrivate3DModelStorage = _gdcmswig.MediaStorage_GEPrivate3DModelStorage
    ToshibaPrivateDataStorage = _gdcmswig.MediaStorage_ToshibaPrivateDataStorage
    MammographyCADSR = _gdcmswig.MediaStorage_MammographyCADSR
    KeyObjectSelectionDocument = _gdcmswig.MediaStorage_KeyObjectSelectionDocument
    HangingProtocolStorage = _gdcmswig.MediaStorage_HangingProtocolStorage
    ModalityPerformedProcedureStepSOPClass = _gdcmswig.MediaStorage_ModalityPerformedProcedureStepSOPClass
    PhilipsPrivateMRSyntheticImageStorage = _gdcmswig.MediaStorage_PhilipsPrivateMRSyntheticImageStorage
    VLPhotographicImageStorage = _gdcmswig.MediaStorage_VLPhotographicImageStorage
    SegmentationStorage = _gdcmswig.MediaStorage_SegmentationStorage
    RTIonPlanStorage = _gdcmswig.MediaStorage_RTIonPlanStorage
    XRay3DAngiographicImageStorage = _gdcmswig.MediaStorage_XRay3DAngiographicImageStorage
    EnhancedXAImageStorage = _gdcmswig.MediaStorage_EnhancedXAImageStorage
    RTIonBeamsTreatmentRecordStorage = _gdcmswig.MediaStorage_RTIonBeamsTreatmentRecordStorage
    SurfaceSegmentationStorage = _gdcmswig.MediaStorage_SurfaceSegmentationStorage
    VLWholeSlideMicroscopyImageStorage = _gdcmswig.MediaStorage_VLWholeSlideMicroscopyImageStorage
    RTTreatmentSummaryRecordStorage = _gdcmswig.MediaStorage_RTTreatmentSummaryRecordStorage
    EnhancedUSVolumeStorage = _gdcmswig.MediaStorage_EnhancedUSVolumeStorage
    XRayRadiationDoseSR = _gdcmswig.MediaStorage_XRayRadiationDoseSR
    VLEndoscopicImageStorage = _gdcmswig.MediaStorage_VLEndoscopicImageStorage
    BreastTomosynthesisImageStorage = _gdcmswig.MediaStorage_BreastTomosynthesisImageStorage
    FujiPrivateCRImageStorage = _gdcmswig.MediaStorage_FujiPrivateCRImageStorage
    OphthalmicPhotography8BitImageStorage = _gdcmswig.MediaStorage_OphthalmicPhotography8BitImageStorage
    OphthalmicTomographyImageStorage = _gdcmswig.MediaStorage_OphthalmicTomographyImageStorage
    VLMicroscopicImageStorage = _gdcmswig.MediaStorage_VLMicroscopicImageStorage
    EnhancedPETImageStorage = _gdcmswig.MediaStorage_EnhancedPETImageStorage
    VideoPhotographicImageStorage = _gdcmswig.MediaStorage_VideoPhotographicImageStorage
    XRay3DCraniofacialImageStorage = _gdcmswig.MediaStorage_XRay3DCraniofacialImageStorage
    IVOCTForPresentation = _gdcmswig.MediaStorage_IVOCTForPresentation
    IVOCTForProcessing = _gdcmswig.MediaStorage_IVOCTForProcessing
    LegacyConvertedEnhancedCTImageStorage = _gdcmswig.MediaStorage_LegacyConvertedEnhancedCTImageStorage
    LegacyConvertedEnhancedMRImageStorage = _gdcmswig.MediaStorage_LegacyConvertedEnhancedMRImageStorage
    LegacyConvertedEnhancedPETImageStorage = _gdcmswig.MediaStorage_LegacyConvertedEnhancedPETImageStorage
    MS_END = _gdcmswig.MediaStorage_MS_END
    NoObject = _gdcmswig.MediaStorage_NoObject
    Video = _gdcmswig.MediaStorage_Video
    Waveform = _gdcmswig.MediaStorage_Waveform
    Audio = _gdcmswig.MediaStorage_Audio
    PDF = _gdcmswig.MediaStorage_PDF
    URI = _gdcmswig.MediaStorage_URI
    Segmentation = _gdcmswig.MediaStorage_Segmentation
    ObjectEnd = _gdcmswig.MediaStorage_ObjectEnd
    if _newclass:
        GetMSString = staticmethod(_gdcmswig.MediaStorage_GetMSString)
    else:
        GetMSString = _gdcmswig.MediaStorage_GetMSString

    def GetString(self) -> "char const *":
        """
        const char*
        gdcm::MediaStorage::GetString() const

        Return the Media String of the object. 
        """
        return _gdcmswig.MediaStorage_GetString(self)

    if _newclass:
        GetMSType = staticmethod(_gdcmswig.MediaStorage_GetMSType)
    else:
        GetMSType = _gdcmswig.MediaStorage_GetMSType

    def __init__(self, *args):
        """gdcm::MediaStorage::MediaStorage(MSType type=MS_END) """
        this = _gdcmswig.new_MediaStorage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        IsImage = staticmethod(_gdcmswig.MediaStorage_IsImage)
    else:
        IsImage = _gdcmswig.MediaStorage_IsImage

    def GetModality(self) -> "char const *":
        """
        const char*
        gdcm::MediaStorage::GetModality() const 
        """
        return _gdcmswig.MediaStorage_GetModality(self)


    def GetModalityDimension(self) -> "unsigned int":
        """unsigned int gdcm::MediaStorage::GetModalityDimension() const """
        return _gdcmswig.MediaStorage_GetModalityDimension(self)

    if _newclass:
        GetNumberOfMSType = staticmethod(_gdcmswig.MediaStorage_GetNumberOfMSType)
    else:
        GetNumberOfMSType = _gdcmswig.MediaStorage_GetNumberOfMSType
    if _newclass:
        GetNumberOfMSString = staticmethod(_gdcmswig.MediaStorage_GetNumberOfMSString)
    else:
        GetNumberOfMSString = _gdcmswig.MediaStorage_GetNumberOfMSString
    if _newclass:
        GetNumberOfModality = staticmethod(_gdcmswig.MediaStorage_GetNumberOfModality)
    else:
        GetNumberOfModality = _gdcmswig.MediaStorage_GetNumberOfModality

    def SetFromFile(self, file: 'File') -> "bool":
        """
        bool
        gdcm::MediaStorage::SetFromFile(File const &file)

        Attempt to set the MediaStorage from a file: WARNING: When no
        MediaStorage & Modality are found BUT a PixelData element is found
        then MediaStorage is set to the default SecondaryCaptureImageStorage
        (return value is false in this case) 
        """
        return _gdcmswig.MediaStorage_SetFromFile(self, file)


    def SetFromDataSet(self, ds: 'DataSet') -> "bool":
        """
        bool
        gdcm::MediaStorage::SetFromDataSet(DataSet const &ds)

        Advanced user only (functions should be protected level...) Those
        function are lower level than SetFromFile 
        """
        return _gdcmswig.MediaStorage_SetFromDataSet(self, ds)


    def SetFromHeader(self, fmi: 'FileMetaInformation') -> "bool":
        """
        bool
        gdcm::MediaStorage::SetFromHeader(FileMetaInformation const &fmi) 
        """
        return _gdcmswig.MediaStorage_SetFromHeader(self, fmi)


    def SetFromModality(self, ds: 'DataSet') -> "bool":
        """
        bool
        gdcm::MediaStorage::SetFromModality(DataSet const &ds) 
        """
        return _gdcmswig.MediaStorage_SetFromModality(self, ds)


    def GuessFromModality(self, modality: 'char const *', dimension: 'unsigned int'=2) -> "void":
        """
        void
        gdcm::MediaStorage::GuessFromModality(const char *modality, unsigned
        int dimension=2) 
        """
        return _gdcmswig.MediaStorage_GuessFromModality(self, modality, dimension)


    def IsUndefined(self) -> "bool":
        """
        bool
        gdcm::MediaStorage::IsUndefined() const 
        """
        return _gdcmswig.MediaStorage_IsUndefined(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.MediaStorage___str__(self)
    __swig_destroy__ = _gdcmswig.delete_MediaStorage
    __del__ = lambda self: None
MediaStorage_swigregister = _gdcmswig.MediaStorage_swigregister
MediaStorage_swigregister(MediaStorage)

def MediaStorage_GetMSString(ts: 'gdcm::MediaStorage::MSType') -> "char const *":
    return _gdcmswig.MediaStorage_GetMSString(ts)
MediaStorage_GetMSString = _gdcmswig.MediaStorage_GetMSString

def MediaStorage_GetMSType(str: 'char const *') -> "gdcm::MediaStorage::MSType":
    return _gdcmswig.MediaStorage_GetMSType(str)
MediaStorage_GetMSType = _gdcmswig.MediaStorage_GetMSType

def MediaStorage_IsImage(ts: 'gdcm::MediaStorage::MSType') -> "bool":
    return _gdcmswig.MediaStorage_IsImage(ts)
MediaStorage_IsImage = _gdcmswig.MediaStorage_IsImage

def MediaStorage_GetNumberOfMSType() -> "unsigned int":
    return _gdcmswig.MediaStorage_GetNumberOfMSType()
MediaStorage_GetNumberOfMSType = _gdcmswig.MediaStorage_GetNumberOfMSType

def MediaStorage_GetNumberOfMSString() -> "unsigned int":
    return _gdcmswig.MediaStorage_GetNumberOfMSString()
MediaStorage_GetNumberOfMSString = _gdcmswig.MediaStorage_GetNumberOfMSString

def MediaStorage_GetNumberOfModality() -> "unsigned int":
    return _gdcmswig.MediaStorage_GetNumberOfModality()
MediaStorage_GetNumberOfModality = _gdcmswig.MediaStorage_GetNumberOfModality

class Tag(_object):
    """


    Class to represent a DICOM Data Element ( Attribute) Tag (Group,
    Element).

    Basically an uint32_t which can also be expressed as two uint16_t
    (group and element) DATA ELEMENT TAG: A unique identifier for a Data
    Element composed of an ordered pair of numbers (a Group Number
    followed by an Element Number). GROUP NUMBER: The first number in the
    ordered pair of numbers that makes up a Data Element Tag. ELEMENT
    NUMBER: The second number in the ordered pair of numbers that makes up
    a Data Element Tag.

    C++ includes: gdcmTag.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Tag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Tag, name)
    __repr__ = _swig_repr

    def GetGroup(self) -> "uint16_t":
        """
        uint16_t
        gdcm::Tag::GetGroup() const

        Returns the 'Group number' of the given Tag. 
        """
        return _gdcmswig.Tag_GetGroup(self)


    def GetElement(self) -> "uint16_t":
        """
        uint16_t
        gdcm::Tag::GetElement() const

        Returns the ' Element number' of the given Tag. 
        """
        return _gdcmswig.Tag_GetElement(self)


    def SetGroup(self, group: 'uint16_t') -> "void":
        """
        void
        gdcm::Tag::SetGroup(uint16_t group)

        Sets the 'Group number' of the given Tag. 
        """
        return _gdcmswig.Tag_SetGroup(self, group)


    def SetElement(self, element: 'uint16_t') -> "void":
        """
        void
        gdcm::Tag::SetElement(uint16_t element)

        Sets the ' Element number' of the given Tag. 
        """
        return _gdcmswig.Tag_SetElement(self, element)


    def GetElementTag(self) -> "uint32_t":
        """
        uint32_t
        gdcm::Tag::GetElementTag() const

        Returns the full tag value of the given Tag. 
        """
        return _gdcmswig.Tag_GetElementTag(self)


    def SetElementTag(self, *args) -> "void":
        """
        void
        gdcm::Tag::SetElementTag(uint32_t tag)

        Sets the full tag value of the given Tag. 
        """
        return _gdcmswig.Tag_SetElementTag(self, *args)


    def __getitem__(self, *args) -> "uint16_t &":
        return _gdcmswig.Tag___getitem__(self, *args)

    def __eq__(self, _val: 'Tag') -> "bool":
        return _gdcmswig.Tag___eq__(self, _val)

    def __ne__(self, _val: 'Tag') -> "bool":
        return _gdcmswig.Tag___ne__(self, _val)

    def __lt__(self, _val: 'Tag') -> "bool":
        return _gdcmswig.Tag___lt__(self, _val)

    def __le__(self, t2: 'Tag') -> "bool":
        return _gdcmswig.Tag___le__(self, t2)

    def __init__(self, *args):
        """
        gdcm::Tag::Tag(const Tag
        &_val) 
        """
        this = _gdcmswig.new_Tag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetLength(self) -> "uint32_t":
        """
        uint32_t
        gdcm::Tag::GetLength() const

        return the length of tag (read: size on disk) 
        """
        return _gdcmswig.Tag_GetLength(self)


    def IsPublic(self) -> "bool":
        """
        bool
        gdcm::Tag::IsPublic() const

        STANDARD DATA ELEMENT: A Data Element defined in the DICOM Standard,
        and therefore listed in the DICOM Data Element Dictionary in PS 3.6.
        Is the Tag from the Public dict...well the implementation is buggy it
        does not prove the element is indeed in the dict... 
        """
        return _gdcmswig.Tag_IsPublic(self)


    def IsPrivate(self) -> "bool":
        """
        bool
        gdcm::Tag::IsPrivate() const

        PRIVATE DATA ELEMENT: Additional Data Element, defined by an
        implementor, to communicate information that is not contained in
        Standard Data Elements. Private Data elements have odd Group Numbers.

        """
        return _gdcmswig.Tag_IsPrivate(self)


    def GetPrivateCreator(self) -> "gdcm::Tag":
        """
        Tag
        gdcm::Tag::GetPrivateCreator() const

        Return the Private Creator Data Element tag of a private data element.

        """
        return _gdcmswig.Tag_GetPrivateCreator(self)


    def SetPrivateCreator(self, t: 'Tag') -> "void":
        """
        void
        gdcm::Tag::SetPrivateCreator(Tag const &t)

        Set private creator: 
        """
        return _gdcmswig.Tag_SetPrivateCreator(self, t)


    def IsPrivateCreator(self) -> "bool":
        """
        bool
        gdcm::Tag::IsPrivateCreator() const

        Returns if tag is a Private Creator (xxxx,00yy), where xxxx is odd
        number and yy in [0x10,0xFF] 
        """
        return _gdcmswig.Tag_IsPrivateCreator(self)


    def IsIllegal(self) -> "bool":
        """
        bool
        gdcm::Tag::IsIllegal() const

        return if the tag is considered to be an illegal tag 
        """
        return _gdcmswig.Tag_IsIllegal(self)


    def IsGroupLength(self) -> "bool":
        """
        bool
        gdcm::Tag::IsGroupLength() const

        return whether the tag correspond to a group length tag: 
        """
        return _gdcmswig.Tag_IsGroupLength(self)


    def IsGroupXX(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Tag::IsGroupXX(const Tag &t) const

        e.g 6002,3000 belong to groupXX: 6000,3000 
        """
        return _gdcmswig.Tag_IsGroupXX(self, t)


    def ReadFromCommaSeparatedString(self, str: 'char const *') -> "bool":
        """
        bool
        gdcm::Tag::ReadFromCommaSeparatedString(const char *str)

        Read from a comma separated string. This is a highly user oriented
        function, the string should be formated as: 1234,5678 to specify the
        tag (0x1234,0x5678) The notation comes from the DICOM standard, and is
        handy to use from a command line program 
        """
        return _gdcmswig.Tag_ReadFromCommaSeparatedString(self, str)


    def ReadFromContinuousString(self, str: 'char const *') -> "bool":
        """
        bool
        gdcm::Tag::ReadFromContinuousString(const char *str)

        Read From XML formatted tag value eg. tag = "12345678" It comes in
        useful when reading tag values from XML file(in NativeDICOMModel) 
        """
        return _gdcmswig.Tag_ReadFromContinuousString(self, str)


    def PrintAsContinuousString(self) -> "std::string":
        """
        std::string gdcm::Tag::PrintAsContinuousString() const

        Print tag value with no separating comma: eg. tag = "12345678" It
        comes in useful when reading tag values from XML file(in
        NativeDICOMModel) 
        """
        return _gdcmswig.Tag_PrintAsContinuousString(self)


    def PrintAsContinuousUpperCaseString(self) -> "std::string":
        """
        std::string gdcm::Tag::PrintAsContinuousUpperCaseString() const

        Same as PrintAsContinuousString, but hexadecimal [a-f] are printed
        using upper case. 
        """
        return _gdcmswig.Tag_PrintAsContinuousUpperCaseString(self)


    def ReadFromPipeSeparatedString(self, str: 'char const *') -> "bool":
        """
        bool
        gdcm::Tag::ReadFromPipeSeparatedString(const char *str)

        Read from a pipe separated string (GDCM 1.x compat only). Do not use
        in newer code See:   ReadFromCommaSeparatedString 
        """
        return _gdcmswig.Tag_ReadFromPipeSeparatedString(self, str)


    def PrintAsPipeSeparatedString(self) -> "std::string":
        """
        std::string gdcm::Tag::PrintAsPipeSeparatedString() const

        Print as a pipe separated string (GDCM 1.x compat only). Do not use in
        newer code See:   ReadFromPipeSeparatedString 
        """
        return _gdcmswig.Tag_PrintAsPipeSeparatedString(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.Tag___str__(self)
    __swig_destroy__ = _gdcmswig.delete_Tag
    __del__ = lambda self: None
Tag_swigregister = _gdcmswig.Tag_swigregister
Tag_swigregister(Tag)


def __rshift__(_is: 'std::istream &', _val: 'Tag') -> "std::istream &":
    return _gdcmswig.__rshift__(_is, _val)
__rshift__ = _gdcmswig.__rshift__
class PrivateTag(Tag):
    """


    Class to represent a Private DICOM Data Element ( Attribute) Tag
    (Group, Element, Owner)

    private tag have element value in: [0x10,0xff], for instance
    0x0009,0x0000 is NOT a private tag

    C++ includes: gdcmPrivateTag.h 
    """

    __swig_setmethods__ = {}
    for _s in [Tag]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrivateTag, name, value)
    __swig_getmethods__ = {}
    for _s in [Tag]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PrivateTag, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::PrivateTag::PrivateTag(Tag const &t, const char *owner="") """
        this = _gdcmswig.new_PrivateTag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetOwner(self) -> "char const *":
        """
        const char*
        gdcm::PrivateTag::GetOwner() const 
        """
        return _gdcmswig.PrivateTag_GetOwner(self)


    def SetOwner(self, owner: 'char const *') -> "void":
        """
        void
        gdcm::PrivateTag::SetOwner(const char *owner) 
        """
        return _gdcmswig.PrivateTag_SetOwner(self, owner)


    def __lt__(self, _val: 'PrivateTag') -> "bool":
        return _gdcmswig.PrivateTag___lt__(self, _val)

    def ReadFromCommaSeparatedString(self, str: 'char const *') -> "bool":
        """
        bool gdcm::PrivateTag::ReadFromCommaSeparatedString(const char *str)

        Read PrivateTag from a string. Element number will be truncated to
        8bits. Eg: "1234,5678,GDCM" is private tag: (1234,78,"GDCM") 
        """
        return _gdcmswig.PrivateTag_ReadFromCommaSeparatedString(self, str)


    def GetAsDataElement(self) -> "DataElement":
        """DataElement gdcm::PrivateTag::GetAsDataElement() const """
        return _gdcmswig.PrivateTag_GetAsDataElement(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.PrivateTag___str__(self)
    __swig_destroy__ = _gdcmswig.delete_PrivateTag
    __del__ = lambda self: None
PrivateTag_swigregister = _gdcmswig.PrivateTag_swigregister
PrivateTag_swigregister(PrivateTag)

class ProgressEvent(AnyEvent):
    """


    ProgressEvent.

    Special type of event triggered during

    See:   AnyEvent

    C++ includes: gdcmProgressEvent.h 
    """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ProgressEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ProgressEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_ProgressEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual
        const char* gdcm::ProgressEvent::GetEventName() const

        Return the StringName associated with the event. 
        """
        return _gdcmswig.ProgressEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::ProgressEvent::CheckEvent(const ::gdcm::Event *e) const 
        """
        return _gdcmswig.ProgressEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual
        ::gdcm::Event* gdcm::ProgressEvent::MakeObject() const

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.ProgressEvent_MakeObject(self)


    def SetProgress(self, p: 'double') -> "void":
        """
        void
        gdcm::ProgressEvent::SetProgress(double p) 
        """
        return _gdcmswig.ProgressEvent_SetProgress(self, p)


    def GetProgress(self) -> "double":
        """
        double
        gdcm::ProgressEvent::GetProgress() const 
        """
        return _gdcmswig.ProgressEvent_GetProgress(self)

    if _newclass:
        Cast = staticmethod(_gdcmswig.ProgressEvent_Cast)
    else:
        Cast = _gdcmswig.ProgressEvent_Cast
ProgressEvent_swigregister = _gdcmswig.ProgressEvent_swigregister
ProgressEvent_swigregister(ProgressEvent)

def ProgressEvent_Cast(event: 'Event') -> "gdcm::ProgressEvent *":
    return _gdcmswig.ProgressEvent_Cast(event)
ProgressEvent_Cast = _gdcmswig.ProgressEvent_Cast

class AnonymizeEvent(AnyEvent):
    """


    AnonymizeEvent.

    Special type of event triggered during the Anonymization process

    See:   Anonymizer

    C++ includes: gdcmAnonymizeEvent.h 
    """

    __swig_setmethods__ = {}
    for _s in [AnyEvent]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, AnonymizeEvent, name, value)
    __swig_getmethods__ = {}
    for _s in [AnyEvent]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, AnonymizeEvent, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_AnonymizeEvent
    __del__ = lambda self: None

    def GetEventName(self) -> "char const *":
        """
        virtual
        const char* gdcm::AnonymizeEvent::GetEventName() const

        Return the StringName associated with the event. 
        """
        return _gdcmswig.AnonymizeEvent_GetEventName(self)


    def CheckEvent(self, e: 'Event') -> "bool":
        """
        virtual bool
        gdcm::AnonymizeEvent::CheckEvent(const ::gdcm::Event *e) const 
        """
        return _gdcmswig.AnonymizeEvent_CheckEvent(self, e)


    def MakeObject(self) -> "::gdcm::Event *":
        """
        virtual
        ::gdcm::Event* gdcm::AnonymizeEvent::MakeObject() const

        Create an Event of this type This method work as a Factory for
        creating events of each particular type. 
        """
        return _gdcmswig.AnonymizeEvent_MakeObject(self)


    def SetTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::AnonymizeEvent::SetTag(const Tag &t) 
        """
        return _gdcmswig.AnonymizeEvent_SetTag(self, t)


    def GetTag(self) -> "gdcm::Tag const &":
        """
        Tag const&
        gdcm::AnonymizeEvent::GetTag() const 
        """
        return _gdcmswig.AnonymizeEvent_GetTag(self)

    if _newclass:
        Cast = staticmethod(_gdcmswig.AnonymizeEvent_Cast)
    else:
        Cast = _gdcmswig.AnonymizeEvent_Cast
AnonymizeEvent_swigregister = _gdcmswig.AnonymizeEvent_swigregister
AnonymizeEvent_swigregister(AnonymizeEvent)

def AnonymizeEvent_Cast(event: 'Event') -> "gdcm::AnonymizeEvent *":
    return _gdcmswig.AnonymizeEvent_Cast(event)
AnonymizeEvent_Cast = _gdcmswig.AnonymizeEvent_Cast

class VL(_object):
    """


    Value Length.

    WARNING:  this is a 4bytes value ! Do not try to use it for 2bytes
    value length

    C++ includes: gdcmVL.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VL, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VL, name)
    __repr__ = _swig_repr

    def __init__(self, vl: 'uint32_t'=0):
        """gdcm::VL::VL(uint32_t vl=0) """
        this = _gdcmswig.new_VL(vl)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        GetVL32Max = staticmethod(_gdcmswig.VL_GetVL32Max)
    else:
        GetVL32Max = _gdcmswig.VL_GetVL32Max
    if _newclass:
        GetVL16Max = staticmethod(_gdcmswig.VL_GetVL16Max)
    else:
        GetVL16Max = _gdcmswig.VL_GetVL16Max

    def IsUndefined(self) -> "bool":
        """
        bool
        gdcm::VL::IsUndefined() const 
        """
        return _gdcmswig.VL_IsUndefined(self)


    def SetToUndefined(self) -> "void":
        """
        void
        gdcm::VL::SetToUndefined() 
        """
        return _gdcmswig.VL_SetToUndefined(self)


    def IsOdd(self) -> "bool":
        """
        bool gdcm::VL::IsOdd() const

        Return whether or not the VL is odd or not. 
        """
        return _gdcmswig.VL_IsOdd(self)


    def __add__(self, vl: 'VL') -> "gdcm::VL &":
        return _gdcmswig.VL___add__(self, vl)

    def GetLength(self) -> "gdcm::VL":
        """
        VL gdcm::VL::GetLength()
        const 
        """
        return _gdcmswig.VL_GetLength(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.VL___str__(self)
    __swig_destroy__ = _gdcmswig.delete_VL
    __del__ = lambda self: None
VL_swigregister = _gdcmswig.VL_swigregister
VL_swigregister(VL)

def VL_GetVL32Max() -> "uint32_t":
    return _gdcmswig.VL_GetVL32Max()
VL_GetVL32Max = _gdcmswig.VL_GetVL32Max

def VL_GetVL16Max() -> "uint16_t":
    return _gdcmswig.VL_GetVL16Max()
VL_GetVL16Max = _gdcmswig.VL_GetVL16Max

class VR(_object):
    """


    VR class.

    This is adapted from DICOM standard The biggest difference is the
    INVALID VR and the composite one that differ from standard (more like
    an addition) This allow us to represent all the possible case express
    in the DICOMV3 dict VALUE REPRESENTATION ( VR) Specifies the data type
    and format of the Value(s) contained in the Value Field of a Data
    Element. VALUE REPRESENTATION FIELD: The field where the Value
    Representation of a Data Element is stored in the encoding of a Data
    Element structure with explicit VR.

    C++ includes: gdcmVR.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VR, name)
    __repr__ = _swig_repr
    INVALID = _gdcmswig.VR_INVALID
    AE = _gdcmswig.VR_AE
    AS = _gdcmswig.VR_AS
    AT = _gdcmswig.VR_AT
    CS = _gdcmswig.VR_CS
    DA = _gdcmswig.VR_DA
    DS = _gdcmswig.VR_DS
    DT = _gdcmswig.VR_DT
    FD = _gdcmswig.VR_FD
    FL = _gdcmswig.VR_FL
    IS = _gdcmswig.VR_IS
    LO = _gdcmswig.VR_LO
    LT = _gdcmswig.VR_LT
    OB = _gdcmswig.VR_OB
    OD = _gdcmswig.VR_OD
    OF = _gdcmswig.VR_OF
    OL = _gdcmswig.VR_OL
    OW = _gdcmswig.VR_OW
    PN = _gdcmswig.VR_PN
    SH = _gdcmswig.VR_SH
    SL = _gdcmswig.VR_SL
    SQ = _gdcmswig.VR_SQ
    SS = _gdcmswig.VR_SS
    ST = _gdcmswig.VR_ST
    TM = _gdcmswig.VR_TM
    UI = _gdcmswig.VR_UI
    UL = _gdcmswig.VR_UL
    UN = _gdcmswig.VR_UN
    US = _gdcmswig.VR_US
    UT = _gdcmswig.VR_UT
    OB_OW = _gdcmswig.VR_OB_OW
    US_SS = _gdcmswig.VR_US_SS
    US_SS_OW = _gdcmswig.VR_US_SS_OW
    VL16 = _gdcmswig.VR_VL16
    VL32 = _gdcmswig.VR_VL32
    VRASCII = _gdcmswig.VR_VRASCII
    VRBINARY = _gdcmswig.VR_VRBINARY
    VR_VM1 = _gdcmswig.VR_VR_VM1
    VRALL = _gdcmswig.VR_VRALL
    VR_END = _gdcmswig.VR_VR_END
    if _newclass:
        GetVRString = staticmethod(_gdcmswig.VR_GetVRString)
    else:
        GetVRString = _gdcmswig.VR_GetVRString
    if _newclass:
        GetVRTypeFromFile = staticmethod(_gdcmswig.VR_GetVRTypeFromFile)
    else:
        GetVRTypeFromFile = _gdcmswig.VR_GetVRTypeFromFile
    if _newclass:
        GetVRType = staticmethod(_gdcmswig.VR_GetVRType)
    else:
        GetVRType = _gdcmswig.VR_GetVRType
    if _newclass:
        GetVRStringFromFile = staticmethod(_gdcmswig.VR_GetVRStringFromFile)
    else:
        GetVRStringFromFile = _gdcmswig.VR_GetVRStringFromFile
    if _newclass:
        IsValid = staticmethod(_gdcmswig.VR_IsValid)
    else:
        IsValid = _gdcmswig.VR_IsValid
    if _newclass:
        IsSwap = staticmethod(_gdcmswig.VR_IsSwap)
    else:
        IsSwap = _gdcmswig.VR_IsSwap

    def GetSizeof(self) -> "unsigned int":
        """
        unsigned int
        gdcm::VR::GetSizeof() const 
        """
        return _gdcmswig.VR_GetSizeof(self)


    def GetLength(*args) -> "uint32_t":
        """
        int gdcm::VR::GetLength()
        const 
        """
        return _gdcmswig.VR_GetLength(*args)

    GetLength = staticmethod(GetLength)
    if _newclass:
        IsBinary = staticmethod(_gdcmswig.VR_IsBinary)
    else:
        IsBinary = _gdcmswig.VR_IsBinary
    if _newclass:
        IsASCII = staticmethod(_gdcmswig.VR_IsASCII)
    else:
        IsASCII = _gdcmswig.VR_IsASCII
    if _newclass:
        CanDisplay = staticmethod(_gdcmswig.VR_CanDisplay)
    else:
        CanDisplay = _gdcmswig.VR_CanDisplay
    if _newclass:
        IsBinary2 = staticmethod(_gdcmswig.VR_IsBinary2)
    else:
        IsBinary2 = _gdcmswig.VR_IsBinary2
    if _newclass:
        IsASCII2 = staticmethod(_gdcmswig.VR_IsASCII2)
    else:
        IsASCII2 = _gdcmswig.VR_IsASCII2

    def __init__(self, *args):
        """
        gdcm::VR::VR(VRType vr=INVALID)

        """
        this = _gdcmswig.new_VR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Read(self, arg2: 'std::istream &') -> "std::istream &":
        """
        std::istream&
        gdcm::VR::Read(std::istream &is) 
        """
        return _gdcmswig.VR_Read(self, arg2)


    def Write(self, os: 'std::ostream &') -> "std::ostream const &":
        """
        const std::ostream&
        gdcm::VR::Write(std::ostream &os) const 
        """
        return _gdcmswig.VR_Write(self, os)


    def GetSize(self) -> "unsigned int":
        """
        unsigned int
        gdcm::VR::GetSize() const 
        """
        return _gdcmswig.VR_GetSize(self)


    def Compatible(self, vr: 'VR') -> "bool":
        """
        bool
        gdcm::VR::Compatible(VR const &vr) const 
        """
        return _gdcmswig.VR_Compatible(self, vr)


    def IsVRFile(self) -> "bool":
        """
        bool gdcm::VR::IsVRFile()
        const 
        """
        return _gdcmswig.VR_IsVRFile(self)


    def IsDual(self) -> "bool":
        """
        bool gdcm::VR::IsDual()
        const 
        """
        return _gdcmswig.VR_IsDual(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.VR___str__(self)
    __swig_destroy__ = _gdcmswig.delete_VR
    __del__ = lambda self: None
VR_swigregister = _gdcmswig.VR_swigregister
VR_swigregister(VR)

def VR_GetVRString(vr: 'gdcm::VR::VRType') -> "char const *":
    return _gdcmswig.VR_GetVRString(vr)
VR_GetVRString = _gdcmswig.VR_GetVRString

def VR_GetVRTypeFromFile(vr: 'char const *') -> "gdcm::VR::VRType":
    return _gdcmswig.VR_GetVRTypeFromFile(vr)
VR_GetVRTypeFromFile = _gdcmswig.VR_GetVRTypeFromFile

def VR_GetVRType(vr: 'char const *') -> "gdcm::VR::VRType":
    return _gdcmswig.VR_GetVRType(vr)
VR_GetVRType = _gdcmswig.VR_GetVRType

def VR_GetVRStringFromFile(vr: 'gdcm::VR::VRType') -> "char const *":
    return _gdcmswig.VR_GetVRStringFromFile(vr)
VR_GetVRStringFromFile = _gdcmswig.VR_GetVRStringFromFile

def VR_IsValid(*args) -> "bool":
    return _gdcmswig.VR_IsValid(*args)
VR_IsValid = _gdcmswig.VR_IsValid

def VR_IsSwap(vr: 'char const *') -> "bool":
    return _gdcmswig.VR_IsSwap(vr)
VR_IsSwap = _gdcmswig.VR_IsSwap

def VR_GetLength(*args) -> "uint32_t":
    """
    int gdcm::VR::GetLength()
    const 
    """
    return _gdcmswig.VR_GetLength(*args)

def VR_IsBinary(vr: 'gdcm::VR::VRType') -> "bool":
    return _gdcmswig.VR_IsBinary(vr)
VR_IsBinary = _gdcmswig.VR_IsBinary

def VR_IsASCII(vr: 'gdcm::VR::VRType') -> "bool":
    return _gdcmswig.VR_IsASCII(vr)
VR_IsASCII = _gdcmswig.VR_IsASCII

def VR_CanDisplay(vr: 'gdcm::VR::VRType') -> "bool":
    return _gdcmswig.VR_CanDisplay(vr)
VR_CanDisplay = _gdcmswig.VR_CanDisplay

def VR_IsBinary2(vr: 'gdcm::VR::VRType') -> "bool":
    return _gdcmswig.VR_IsBinary2(vr)
VR_IsBinary2 = _gdcmswig.VR_IsBinary2

def VR_IsASCII2(vr: 'gdcm::VR::VRType') -> "bool":
    return _gdcmswig.VR_IsASCII2(vr)
VR_IsASCII2 = _gdcmswig.VR_IsASCII2

class VM(_object):
    """


    Value Multiplicity Looking at the DICOMV3 dict only there is very few
    cases: 1 2 3 4 5 6 8 16 24 1-2 1-3 1-8 1-32 1-99 1-n 2-2n 2-n 3-3n
    3-n.

    Some private dict define some more: 4-4n 1-4 1-5 256 9 3-4

    even more:

    7-7n 10 18 12 35 47_47n 30_30n 28

    6-6n

    C++ includes: gdcmVM.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, VM, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, VM, name)
    __repr__ = _swig_repr
    VM0 = _gdcmswig.VM_VM0
    VM1 = _gdcmswig.VM_VM1
    VM2 = _gdcmswig.VM_VM2
    VM3 = _gdcmswig.VM_VM3
    VM4 = _gdcmswig.VM_VM4
    VM5 = _gdcmswig.VM_VM5
    VM6 = _gdcmswig.VM_VM6
    VM8 = _gdcmswig.VM_VM8
    VM9 = _gdcmswig.VM_VM9
    VM10 = _gdcmswig.VM_VM10
    VM12 = _gdcmswig.VM_VM12
    VM16 = _gdcmswig.VM_VM16
    VM18 = _gdcmswig.VM_VM18
    VM24 = _gdcmswig.VM_VM24
    VM28 = _gdcmswig.VM_VM28
    VM32 = _gdcmswig.VM_VM32
    VM35 = _gdcmswig.VM_VM35
    VM99 = _gdcmswig.VM_VM99
    VM256 = _gdcmswig.VM_VM256
    VM1_2 = _gdcmswig.VM_VM1_2
    VM1_3 = _gdcmswig.VM_VM1_3
    VM1_4 = _gdcmswig.VM_VM1_4
    VM1_5 = _gdcmswig.VM_VM1_5
    VM1_8 = _gdcmswig.VM_VM1_8
    VM1_32 = _gdcmswig.VM_VM1_32
    VM1_99 = _gdcmswig.VM_VM1_99
    VM1_n = _gdcmswig.VM_VM1_n
    VM2_2n = _gdcmswig.VM_VM2_2n
    VM2_n = _gdcmswig.VM_VM2_n
    VM3_4 = _gdcmswig.VM_VM3_4
    VM3_3n = _gdcmswig.VM_VM3_3n
    VM3_n = _gdcmswig.VM_VM3_n
    VM4_4n = _gdcmswig.VM_VM4_4n
    VM6_6n = _gdcmswig.VM_VM6_6n
    VM7_7n = _gdcmswig.VM_VM7_7n
    VM30_30n = _gdcmswig.VM_VM30_30n
    VM47_47n = _gdcmswig.VM_VM47_47n
    VM_END = _gdcmswig.VM_VM_END
    if _newclass:
        GetVMString = staticmethod(_gdcmswig.VM_GetVMString)
    else:
        GetVMString = _gdcmswig.VM_GetVMString
    if _newclass:
        GetVMType = staticmethod(_gdcmswig.VM_GetVMType)
    else:
        GetVMType = _gdcmswig.VM_GetVMType
    if _newclass:
        IsValid = staticmethod(_gdcmswig.VM_IsValid)
    else:
        IsValid = _gdcmswig.VM_IsValid

    def Compatible(self, vm: 'VM') -> "bool":
        """
        bool
        gdcm::VM::Compatible(VM const &vm) const

        WARNING: Implementation deficiency The Compatible function is poorly
        implemented, the reference vm should be coming from the dictionary,
        while the passed in value is the value guess from the file. 
        """
        return _gdcmswig.VM_Compatible(self, vm)

    if _newclass:
        GetVMTypeFromLength = staticmethod(_gdcmswig.VM_GetVMTypeFromLength)
    else:
        GetVMTypeFromLength = _gdcmswig.VM_GetVMTypeFromLength
    if _newclass:
        GetNumberOfElementsFromArray = staticmethod(_gdcmswig.VM_GetNumberOfElementsFromArray)
    else:
        GetNumberOfElementsFromArray = _gdcmswig.VM_GetNumberOfElementsFromArray

    def __init__(self, *args):
        """gdcm::VM::VM(VMType type=VM0) """
        this = _gdcmswig.new_VM(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetLength(self) -> "unsigned int":
        """
        unsigned int
        gdcm::VM::GetLength() const 
        """
        return _gdcmswig.VM_GetLength(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.VM___str__(self)
    __swig_destroy__ = _gdcmswig.delete_VM
    __del__ = lambda self: None
VM_swigregister = _gdcmswig.VM_swigregister
VM_swigregister(VM)

def VM_GetVMString(vm: 'gdcm::VM::VMType') -> "char const *":
    return _gdcmswig.VM_GetVMString(vm)
VM_GetVMString = _gdcmswig.VM_GetVMString

def VM_GetVMType(vm: 'char const *') -> "gdcm::VM::VMType":
    return _gdcmswig.VM_GetVMType(vm)
VM_GetVMType = _gdcmswig.VM_GetVMType

def VM_IsValid(vm1: 'int', vm2: 'gdcm::VM::VMType') -> "bool":
    return _gdcmswig.VM_IsValid(vm1, vm2)
VM_IsValid = _gdcmswig.VM_IsValid

def VM_GetVMTypeFromLength(length: 'unsigned int', size: 'unsigned int') -> "gdcm::VM::VMType":
    return _gdcmswig.VM_GetVMTypeFromLength(length, size)
VM_GetVMTypeFromLength = _gdcmswig.VM_GetVMTypeFromLength

def VM_GetNumberOfElementsFromArray(array: 'char const *', length: 'size_t') -> "size_t":
    return _gdcmswig.VM_GetNumberOfElementsFromArray(array, length)
VM_GetNumberOfElementsFromArray = _gdcmswig.VM_GetNumberOfElementsFromArray

class FilenamesType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilenamesType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FilenamesType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.FilenamesType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.FilenamesType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.FilenamesType___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _gdcmswig.FilenamesType___len__(self)

    def __getslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "std::vector< std::string,std::allocator< std::string > > *":
        return _gdcmswig.FilenamesType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.FilenamesType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::string >::difference_type', j: 'std::vector< std::string >::difference_type') -> "void":
        return _gdcmswig.FilenamesType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.FilenamesType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _gdcmswig.FilenamesType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.FilenamesType___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _gdcmswig.FilenamesType_pop(self)

    def append(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _gdcmswig.FilenamesType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.FilenamesType_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _gdcmswig.FilenamesType_size(self)

    def swap(self, v: 'FilenamesType') -> "void":
        return _gdcmswig.FilenamesType_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _gdcmswig.FilenamesType_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _gdcmswig.FilenamesType_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _gdcmswig.FilenamesType_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _gdcmswig.FilenamesType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.FilenamesType_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _gdcmswig.FilenamesType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.FilenamesType_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _gdcmswig.FilenamesType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_FilenamesType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< std::string >::value_type const &') -> "void":
        return _gdcmswig.FilenamesType_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _gdcmswig.FilenamesType_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _gdcmswig.FilenamesType_back(self)

    def assign(self, n: 'std::vector< std::string >::size_type', x: 'std::vector< std::string >::value_type const &') -> "void":
        return _gdcmswig.FilenamesType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.FilenamesType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.FilenamesType_insert(self, *args)

    def reserve(self, n: 'std::vector< std::string >::size_type') -> "void":
        return _gdcmswig.FilenamesType_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _gdcmswig.FilenamesType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_FilenamesType
    __del__ = lambda self: None
FilenamesType_swigregister = _gdcmswig.FilenamesType_swigregister
FilenamesType_swigregister(FilenamesType)

class Directory(_object):
    """


    Class for manipulation directories.

    This implementation provide a cross platform implementation for
    manipulating directores: basically traversing directories and
    harvesting files

    will not take into account unix type hidden file recursive option will
    not look into UNIX type hidden directory (those starting with a '.')

    Since python or C# provide there own equivalent implementation, in
    which case gdcm::Directory does not make much sense.

    C++ includes: gdcmDirectory.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Directory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Directory, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Directory::Directory() """
        this = _gdcmswig.new_Directory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Directory
    __del__ = lambda self: None

    def Print(self, *args) -> "void":
        """
        void
        gdcm::Directory::Print(std::ostream &os=std::cout) const

        Print. 
        """
        return _gdcmswig.Directory_Print(self, *args)


    def GetToplevel(self) -> "gdcm::Directory::FilenameType const &":
        """
        FilenameType
        const& gdcm::Directory::GetToplevel() const

        Get the name of the toplevel directory. 
        """
        return _gdcmswig.Directory_GetToplevel(self)


    def GetFilenames(self) -> "gdcm::Directory::FilenamesType const &":
        """
        FilenamesType
        const& gdcm::Directory::GetFilenames() const

        Set/Get the file names within the directory. 
        """
        return _gdcmswig.Directory_GetFilenames(self)


    def GetDirectories(self) -> "gdcm::Directory::FilenamesType const &":
        """
        FilenamesType
        const& gdcm::Directory::GetDirectories() const

        Return the Directories traversed. 
        """
        return _gdcmswig.Directory_GetDirectories(self)


    def Load(self, name: 'gdcm::Directory::FilenameType const &', recursive: 'bool'=False) -> "unsigned int":
        """
        unsigned int
        gdcm::Directory::Load(FilenameType const &name, bool recursive=false)

        construct a list of filenames and subdirectory beneath directory: name
        WARNING:  : hidden file and hidden directory are not loaded. 
        """
        return _gdcmswig.Directory_Load(self, name, recursive)


    def __str__(self) -> "char const *":
        return _gdcmswig.Directory___str__(self)
Directory_swigregister = _gdcmswig.Directory_swigregister
Directory_swigregister(Directory)

class Object(_object):
    """


    Object.

    main superclass for object that want to use SmartPointer invasive ref
    counting system

    See:   SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Object, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Object, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Object
    __del__ = lambda self: None

    def __init__(self, *args):
        """
        gdcm::Object::Object(const Object &)

        Special requirement for copy/cstor, assignment operator. 
        """
        this = _gdcmswig.new_Object(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        virtual void
        gdcm::Object::Print(std::ostream &) const 
        """
        return _gdcmswig.Object_Print(self, arg2)

Object_swigregister = _gdcmswig.Object_swigregister
Object_swigregister(Object)

class Value(Object):
    """


    Class to represent the value of a Data Element.

    VALUE: A component of a Value Field. A Value Field may consist of one
    or more of these components.

    C++ includes: gdcmValue.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Value, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Value, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Value
    __del__ = lambda self: None

    def GetLength(self) -> "gdcm::VL":
        """
        virtual VL
        gdcm::Value::GetLength() const =0 
        """
        return _gdcmswig.Value_GetLength(self)


    def SetLength(self, l: 'VL') -> "void":
        """
        virtual void
        gdcm::Value::SetLength(VL l)=0 
        """
        return _gdcmswig.Value_SetLength(self, l)


    def Clear(self) -> "void":
        """
        virtual void
        gdcm::Value::Clear()=0 
        """
        return _gdcmswig.Value_Clear(self)


    def __eq__(self, val: 'Value') -> "bool":
        return _gdcmswig.Value___eq__(self, val)

    def __str__(self) -> "char const *":
        return _gdcmswig.Value___str__(self)
Value_swigregister = _gdcmswig.Value_swigregister
Value_swigregister(Value)

class ByteValue(Value):
    """


    Class to represent binary value (array of bytes)

    C++ includes: gdcmByteValue.h 
    """

    __swig_setmethods__ = {}
    for _s in [Value]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ByteValue, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ByteValue, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::ByteValue::ByteValue(std::vector< char > &v)

        WARNING:  casting to uint32_t 
        """
        this = _gdcmswig.new_ByteValue(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ByteValue
    __del__ = lambda self: None

    def PrintASCII(self, os: 'std::ostream &', maxlength: 'VL') -> "void":
        """
        void
        gdcm::ByteValue::PrintASCII(std::ostream &os, VL maxlength) const 
        """
        return _gdcmswig.ByteValue_PrintASCII(self, os, maxlength)


    def PrintHex(self, os: 'std::ostream &', maxlength: 'VL') -> "void":
        """
        void
        gdcm::ByteValue::PrintHex(std::ostream &os, VL maxlength) const 
        """
        return _gdcmswig.ByteValue_PrintHex(self, os, maxlength)


    def PrintGroupLength(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::ByteValue::PrintGroupLength(std::ostream &os) 
        """
        return _gdcmswig.ByteValue_PrintGroupLength(self, os)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::ByteValue::IsEmpty() const 
        """
        return _gdcmswig.ByteValue_IsEmpty(self)


    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::ByteValue::GetLength() const 
        """
        return _gdcmswig.ByteValue_GetLength(self)


    def ComputeLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::ByteValue::ComputeLength() const 
        """
        return _gdcmswig.ByteValue_ComputeLength(self)


    def SetLength(self, vl: 'VL') -> "void":
        """
        void
        gdcm::ByteValue::SetLength(VL vl) 
        """
        return _gdcmswig.ByteValue_SetLength(self, vl)


    def __eq__(self, *args) -> "bool":
        return _gdcmswig.ByteValue___eq__(self, *args)

    def Append(self, bv: 'ByteValue') -> "void":
        """
        void
        gdcm::ByteValue::Append(ByteValue const &bv) 
        """
        return _gdcmswig.ByteValue_Append(self, bv)


    def Clear(self) -> "void":
        """
        void
        gdcm::ByteValue::Clear() 
        """
        return _gdcmswig.ByteValue_Clear(self)


    def Fill(self, c: 'char') -> "void":
        """
        void
        gdcm::ByteValue::Fill(char c) 
        """
        return _gdcmswig.ByteValue_Fill(self, c)


    def IsPrintable(self, length: 'VL') -> "bool":
        """
        bool
        gdcm::ByteValue::IsPrintable(VL length) const

        Checks whether a ' ByteValue' is printable or not (in order to avoid
        corrupting the terminal of invocation when printing) I don't think
        this function is working since it does not handle UNICODE or character
        set... 
        """
        return _gdcmswig.ByteValue_IsPrintable(self, length)


    def PrintPNXML(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::ByteValue::PrintPNXML(std::ostream &os) const

        To Print Values in Native DICOM format 
        """
        return _gdcmswig.ByteValue_PrintPNXML(self, os)


    def PrintASCIIXML(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::ByteValue::PrintASCIIXML(std::ostream &os) const 
        """
        return _gdcmswig.ByteValue_PrintASCIIXML(self, os)


    def PrintHexXML(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::ByteValue::PrintHexXML(std::ostream &os) const 
        """
        return _gdcmswig.ByteValue_PrintHexXML(self, os)


    def __str__(self) -> "char const *":
        return _gdcmswig.ByteValue___str__(self)

    def WriteBuffer(self) -> "std::string":
        """
        bool
        gdcm::ByteValue::WriteBuffer(std::ostream &os) const 
        """
        return _gdcmswig.ByteValue_WriteBuffer(self)


    def GetBuffer(self, *args) -> "std::string":
        """
        bool
        gdcm::ByteValue::GetBuffer(char *buffer, unsigned long length) const

        """
        return _gdcmswig.ByteValue_GetBuffer(self, *args)

ByteValue_swigregister = _gdcmswig.ByteValue_swigregister
ByteValue_swigregister(ByteValue)

class ASN1(_object):
    """


    Class for ASN1.

    C++ includes: gdcmASN1.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ASN1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ASN1, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ASN1::ASN1() """
        this = _gdcmswig.new_ASN1()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ASN1
    __del__ = lambda self: None
    if _newclass:
        ParseDumpFile = staticmethod(_gdcmswig.ASN1_ParseDumpFile)
    else:
        ParseDumpFile = _gdcmswig.ASN1_ParseDumpFile
    if _newclass:
        ParseDump = staticmethod(_gdcmswig.ASN1_ParseDump)
    else:
        ParseDump = _gdcmswig.ASN1_ParseDump
ASN1_swigregister = _gdcmswig.ASN1_swigregister
ASN1_swigregister(ASN1)

def ASN1_ParseDumpFile(filename: 'char const *') -> "bool":
    return _gdcmswig.ASN1_ParseDumpFile(filename)
ASN1_ParseDumpFile = _gdcmswig.ASN1_ParseDumpFile

def ASN1_ParseDump(array: 'char const *', length: 'size_t') -> "bool":
    return _gdcmswig.ASN1_ParseDump(array, length)
ASN1_ParseDump = _gdcmswig.ASN1_ParseDump

class SmartPtrSQ(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrSQ, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrSQ, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrSQ(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrSQ
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::SequenceOfItems *":
        return _gdcmswig.SmartPtrSQ___deref__(self)

    def __ref__(self) -> "gdcm::SequenceOfItems &":
        return _gdcmswig.SmartPtrSQ___ref__(self)

    def GetPointer(self) -> "gdcm::SequenceOfItems *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrSQ_GetPointer(self)


    def Begin(self, *args) -> "gdcm::SequenceOfItems::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfItems::Begin() const 
        """
        return _gdcmswig.SmartPtrSQ_Begin(self, *args)


    def End(self, *args) -> "gdcm::SequenceOfItems::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfItems::End() const 
        """
        return _gdcmswig.SmartPtrSQ_End(self, *args)


    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfItems::GetLength() const

        Returns the SQ length, as read from disk. 
        """
        return _gdcmswig.SmartPtrSQ_GetLength(self)


    def SetLength(self, length: 'VL') -> "void":
        """
        void
        gdcm::SequenceOfItems::SetLength(VL length)

        Sets the actual SQ length. 
        """
        return _gdcmswig.SmartPtrSQ_SetLength(self, length)


    def SetLengthToUndefined(self) -> "void":
        """
        void gdcm::SequenceOfItems::SetLengthToUndefined()

        Properly set the Sequence of Item to be undefined length. 
        """
        return _gdcmswig.SmartPtrSQ_SetLengthToUndefined(self)


    def IsUndefinedLength(self) -> "bool":
        """
        bool
        gdcm::SequenceOfItems::IsUndefinedLength() const

        return if Value Length if of undefined length 
        """
        return _gdcmswig.SmartPtrSQ_IsUndefinedLength(self)


    def Clear(self) -> "void":
        """
        void
        gdcm::SequenceOfItems::Clear()

        remove all items within the sequence 
        """
        return _gdcmswig.SmartPtrSQ_Clear(self)


    def AddItem(self, item: 'Item') -> "void":
        """
        void
        gdcm::SequenceOfItems::AddItem(Item const &item)

        Appends an Item to the already added ones. 
        """
        return _gdcmswig.SmartPtrSQ_AddItem(self, item)


    def AddNewUndefinedLengthItem(self) -> "gdcm::Item &":
        """
        Item&
        gdcm::SequenceOfItems::AddNewUndefinedLengthItem()

        Appends an Item to the already added ones. 
        """
        return _gdcmswig.SmartPtrSQ_AddNewUndefinedLengthItem(self)


    def RemoveItemByIndex(self, index: 'gdcm::SequenceOfItems::SizeType const') -> "bool":
        """
        bool
        gdcm::SequenceOfItems::RemoveItemByIndex(const SizeType index)

        Remove an Item as specified by its index, if index > size, false is
        returned Index starts at 1 not 0 
        """
        return _gdcmswig.SmartPtrSQ_RemoveItemByIndex(self, index)


    def IsEmpty(self) -> "bool":
        return _gdcmswig.SmartPtrSQ_IsEmpty(self)

    def GetNumberOfItems(self) -> "gdcm::SequenceOfItems::SizeType":
        """SizeType gdcm::SequenceOfItems::GetNumberOfItems() const """
        return _gdcmswig.SmartPtrSQ_GetNumberOfItems(self)


    def SetNumberOfItems(self, n: 'gdcm::SequenceOfItems::SizeType') -> "void":
        """
        void
        gdcm::SequenceOfItems::SetNumberOfItems(SizeType n) 
        """
        return _gdcmswig.SmartPtrSQ_SetNumberOfItems(self, n)


    def GetItem(self, *args) -> "gdcm::Item &":
        """
        Item&
        gdcm::SequenceOfItems::GetItem(SizeType position) 
        """
        return _gdcmswig.SmartPtrSQ_GetItem(self, *args)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::SequenceOfItems::Print(std::ostream &os) const 
        """
        return _gdcmswig.SmartPtrSQ_Print(self, os)


    def New(self) -> "gdcm::SmartPointer< gdcm::SequenceOfItems >":
        return _gdcmswig.SmartPtrSQ_New(self)

    def FindDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::SequenceOfItems::FindDataElement(const Tag &t) const 
        """
        return _gdcmswig.SmartPtrSQ_FindDataElement(self, t)


    def __eq__(self, val: 'Value') -> "bool":
        return _gdcmswig.SmartPtrSQ___eq__(self, val)
    __swig_setmethods__["SequenceLengthField"] = _gdcmswig.SmartPtrSQ_SequenceLengthField_set
    __swig_getmethods__["SequenceLengthField"] = _gdcmswig.SmartPtrSQ_SequenceLengthField_get
    if _newclass:
        SequenceLengthField = _swig_property(_gdcmswig.SmartPtrSQ_SequenceLengthField_get, _gdcmswig.SmartPtrSQ_SequenceLengthField_set)
    __swig_setmethods__["Items"] = _gdcmswig.SmartPtrSQ_Items_set
    __swig_getmethods__["Items"] = _gdcmswig.SmartPtrSQ_Items_get
    if _newclass:
        Items = _swig_property(_gdcmswig.SmartPtrSQ_Items_get, _gdcmswig.SmartPtrSQ_Items_set)

    def __str__(self) -> "char const *":
        return _gdcmswig.SmartPtrSQ___str__(self)
SmartPtrSQ_swigregister = _gdcmswig.SmartPtrSQ_swigregister
SmartPtrSQ_swigregister(SmartPtrSQ)

class SmartPtrFrag(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrFrag, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrFrag, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrFrag(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrFrag
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::SequenceOfFragments *":
        return _gdcmswig.SmartPtrFrag___deref__(self)

    def __ref__(self) -> "gdcm::SequenceOfFragments &":
        return _gdcmswig.SmartPtrFrag___ref__(self)

    def GetPointer(self) -> "gdcm::SequenceOfFragments *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrFrag_GetPointer(self)


    def Begin(self, *args) -> "gdcm::SequenceOfFragments::ConstIterator":
        """ConstIterator gdcm::SequenceOfFragments::Begin() const """
        return _gdcmswig.SmartPtrFrag_Begin(self, *args)


    def End(self, *args) -> "gdcm::SequenceOfFragments::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfFragments::End() const 
        """
        return _gdcmswig.SmartPtrFrag_End(self, *args)


    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfFragments::GetLength() const

        Returns the SQ length, as read from disk. 
        """
        return _gdcmswig.SmartPtrFrag_GetLength(self)


    def SetLength(self, length: 'VL') -> "void":
        """
        void
        gdcm::SequenceOfFragments::SetLength(VL length)

        Sets the actual SQ length. 
        """
        return _gdcmswig.SmartPtrFrag_SetLength(self, length)


    def Clear(self) -> "void":
        """
        void
        gdcm::SequenceOfFragments::Clear()

        Clear. 
        """
        return _gdcmswig.SmartPtrFrag_Clear(self)


    def AddFragment(self, item: 'Fragment') -> "void":
        """
        void
        gdcm::SequenceOfFragments::AddFragment(Fragment const &item)

        Appends a Fragment to the already added ones. 
        """
        return _gdcmswig.SmartPtrFrag_AddFragment(self, item)


    def ComputeByteLength(self) -> "unsigned long":
        """unsigned long gdcm::SequenceOfFragments::ComputeByteLength() const """
        return _gdcmswig.SmartPtrFrag_ComputeByteLength(self)


    def ComputeLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfFragments::ComputeLength() const 
        """
        return _gdcmswig.SmartPtrFrag_ComputeLength(self)


    def GetBuffer(self, buffer: 'char *', length: 'unsigned long') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::GetBuffer(char *buffer, unsigned long
        length) const 
        """
        return _gdcmswig.SmartPtrFrag_GetBuffer(self, buffer, length)


    def GetFragBuffer(self, fragNb: 'unsigned int', buffer: 'char *', length: 'unsigned long &') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::GetFragBuffer(unsigned int fragNb, char
        *buffer, unsigned long &length) const 
        """
        return _gdcmswig.SmartPtrFrag_GetFragBuffer(self, fragNb, buffer, length)


    def GetNumberOfFragments(self) -> "gdcm::SequenceOfFragments::SizeType":
        """SizeType gdcm::SequenceOfFragments::GetNumberOfFragments() const """
        return _gdcmswig.SmartPtrFrag_GetNumberOfFragments(self)


    def GetFragment(self, num: 'gdcm::SequenceOfFragments::SizeType') -> "gdcm::Fragment const &":
        """
        const
        Fragment& gdcm::SequenceOfFragments::GetFragment(SizeType num) const

        """
        return _gdcmswig.SmartPtrFrag_GetFragment(self, num)


    def WriteBuffer(self, os: 'std::ostream &') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::WriteBuffer(std::ostream &os) const 
        """
        return _gdcmswig.SmartPtrFrag_WriteBuffer(self, os)


    def GetTable(self, *args) -> "BasicOffsetTable &":
        """BasicOffsetTable& gdcm::SequenceOfFragments::GetTable() """
        return _gdcmswig.SmartPtrFrag_GetTable(self, *args)


    def New(self) -> "gdcm::SmartPointer< gdcm::SequenceOfFragments >":
        return _gdcmswig.SmartPtrFrag_New(self)

    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::SequenceOfFragments::Print(std::ostream &os) const 
        """
        return _gdcmswig.SmartPtrFrag_Print(self, os)


    def __eq__(self, val: 'Value') -> "bool":
        return _gdcmswig.SmartPtrFrag___eq__(self, val)

    def __str__(self) -> "char const *":
        return _gdcmswig.SmartPtrFrag___str__(self)
SmartPtrFrag_swigregister = _gdcmswig.SmartPtrFrag_swigregister
SmartPtrFrag_swigregister(SmartPtrFrag)

class DataElement(_object):
    """


    Class to represent a Data Element either Implicit or Explicit.

    DATA ELEMENT: A unit of information as defined by a single entry in
    the data dictionary. An encoded Information Object Definition ( IOD)
    Attribute that is composed of, at a minimum, three fields: a Data
    Element Tag, a Value Length, and a Value Field. For some specific
    Transfer Syntaxes, a Data Element also contains a VR Field where the
    Value Representation of that Data Element is specified explicitly.

    Design: A DataElement in GDCM always store VL ( Value Length) on a 32
    bits integer even when VL is 16 bits

    A DataElement always store the VR even for Implicit TS, in which case
    VR is defaulted to VR::INVALID

    For Item start/end (See 0xfffe tags), Value is NULL

    See:   ExplicitDataElement ImplicitDataElement

    C++ includes: gdcmDataElement.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataElement, name)
    __repr__ = _swig_repr

    def GetTag(self, *args) -> "gdcm::Tag &":
        """
        Tag&
        gdcm::DataElement::GetTag() 
        """
        return _gdcmswig.DataElement_GetTag(self, *args)


    def SetTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::DataElement::SetTag(const Tag &t)

        Set Tag Use with cautious (need to match Part 6) 
        """
        return _gdcmswig.DataElement_SetTag(self, t)


    def GetVL(self, *args) -> "gdcm::VL &":
        """
        VL&
        gdcm::DataElement::GetVL() 
        """
        return _gdcmswig.DataElement_GetVL(self, *args)


    def SetVL(self, vl: 'VL') -> "void":
        """
        void
        gdcm::DataElement::SetVL(const VL &vl)

        Set VL Use with cautious (need to match Part 6), advanced user only
        See:   SetByteValue 
        """
        return _gdcmswig.DataElement_SetVL(self, vl)


    def SetVLToUndefined(self) -> "void":
        """
        void
        gdcm::DataElement::SetVLToUndefined() 
        """
        return _gdcmswig.DataElement_SetVLToUndefined(self)


    def GetVR(self) -> "gdcm::VR const &":
        """
        VR const&
        gdcm::DataElement::GetVR() const

        Get VR do not set VR::SQ on bytevalue data element 
        """
        return _gdcmswig.DataElement_GetVR(self)


    def SetVR(self, vr: 'VR') -> "void":
        """
        void
        gdcm::DataElement::SetVR(VR const &vr)

        Set VR Use with cautious (need to match Part 6), advanced user only vr
        is a VR::VRALL (not a dual one such as OB_OW) 
        """
        return _gdcmswig.DataElement_SetVR(self, vr)


    def GetValue(self, *args) -> "gdcm::Value &":
        """
        Value&
        gdcm::DataElement::GetValue() 
        """
        return _gdcmswig.DataElement_GetValue(self, *args)


    def SetValue(self, vl: 'Value') -> "void":
        """
        void
        gdcm::DataElement::SetValue(Value const &vl)

        WARNING:  you need to set the ValueLengthField explicitly 
        """
        return _gdcmswig.DataElement_SetValue(self, vl)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::DataElement::IsEmpty() const

        Check if Data Element is empty. 
        """
        return _gdcmswig.DataElement_IsEmpty(self)


    def Empty(self) -> "void":
        """
        void
        gdcm::DataElement::Empty()

        Make Data Element empty (no Value) 
        """
        return _gdcmswig.DataElement_Empty(self)


    def Clear(self) -> "void":
        """
        void
        gdcm::DataElement::Clear()

        Clear Data Element (make Value empty and invalidate Tag & VR) 
        """
        return _gdcmswig.DataElement_Clear(self)


    def SetByteValue(self, array: 'char const *', length: 'VL') -> "void":
        """
        void
        gdcm::DataElement::SetByteValue(const char *array, VL length)

        Set the byte value WARNING:  user need to read DICOM standard for an
        understanding of: even padding

        \\0 vs space padding By default even padding is achieved using \\0
        regardless of the of VR 
        """
        return _gdcmswig.DataElement_SetByteValue(self, array, length)


    def GetByteValue(self) -> "gdcm::ByteValue const *":
        """
        const
        ByteValue* gdcm::DataElement::GetByteValue() const

        Return the Value of DataElement as a ByteValue (if possible) WARNING:
        : You need to check for NULL return value 
        """
        return _gdcmswig.DataElement_GetByteValue(self)


    def GetValueAsSQ(self) -> "gdcm::SmartPointer< gdcm::SequenceOfItems >":
        """
        SmartPointer<SequenceOfItems> gdcm::DataElement::GetValueAsSQ() const

        Interpret the Value stored in the DataElement. This is more robust
        (but also more expensive) to call this function rather than the
        simpliest form: GetSequenceOfItems() It also return NULL when the
        Value is NOT of type SequenceOfItems WARNING:  in case
        GetSequenceOfItems() succeed the function return this value, otherwise
        it creates a new SequenceOfItems, you should handle that in your case,
        for instance: SmartPointer<SequenceOfItems> sqi = de.GetValueAsSQ();

        """
        return _gdcmswig.DataElement_GetValueAsSQ(self)


    def GetSequenceOfFragments(self, *args) -> "gdcm::SequenceOfFragments *":
        """SequenceOfFragments* gdcm::DataElement::GetSequenceOfFragments() """
        return _gdcmswig.DataElement_GetSequenceOfFragments(self, *args)


    def IsUndefinedLength(self) -> "bool":
        """
        bool
        gdcm::DataElement::IsUndefinedLength() const

        return if Value Length if of undefined length 
        """
        return _gdcmswig.DataElement_IsUndefinedLength(self)


    def __init__(self, *args):
        """gdcm::DataElement::DataElement(const DataElement &_val) """
        this = _gdcmswig.new_DataElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __lt__(self, de: 'DataElement') -> "bool":
        return _gdcmswig.DataElement___lt__(self, de)

    def __eq__(self, de: 'DataElement') -> "bool":
        return _gdcmswig.DataElement___eq__(self, de)

    def SetByteStringValue(self, array: 'char const *') -> "void":
        return _gdcmswig.DataElement_SetByteStringValue(self, array)

    def __str__(self) -> "char const *":
        return _gdcmswig.DataElement___str__(self)
    __swig_destroy__ = _gdcmswig.delete_DataElement
    __del__ = lambda self: None
DataElement_swigregister = _gdcmswig.DataElement_swigregister
DataElement_swigregister(DataElement)


def __ne__(lhs: 'DataElement', rhs: 'DataElement') -> "bool":
    return _gdcmswig.__ne__(lhs, rhs)
__ne__ = _gdcmswig.__ne__
class Item(DataElement):
    """


    Class to represent an Item.

    A component of the value of a Data Element that is of Value
    Representation Sequence of Items. An Item contains a Data Set . See PS
    3.5 7.5.1 Item Encoding Rules Each Item of a Data Element of VR SQ
    shall be encoded as a DICOM Standart Data Element with a specific Data
    Element Tag of Value (FFFE,E000). The Item Tag is followed by a 4 byte
    Item Length field encoded in one of the following two ways Explicit/
    Implicit ITEM: A component of the Value of a Data Element that is of
    Value Representation Sequence of Items. An Item contains a Data Set.

    C++ includes: gdcmItem.h 
    """

    __swig_setmethods__ = {}
    for _s in [DataElement]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Item, name, value)
    __swig_getmethods__ = {}
    for _s in [DataElement]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Item, name)
    __repr__ = _swig_repr

    def Clear(self) -> "void":
        """void gdcm::Item::Clear() """
        return _gdcmswig.Item_Clear(self)


    def InsertDataElement(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::Item::InsertDataElement(const DataElement &de) 
        """
        return _gdcmswig.Item_InsertDataElement(self, de)


    def GetDataElement(self, t: 'Tag') -> "gdcm::DataElement const &":
        """
        const DataElement&
        gdcm::Item::GetDataElement(const Tag &t) const 
        """
        return _gdcmswig.Item_GetDataElement(self, t)


    def SetNestedDataSet(self, nested: 'DataSet') -> "void":
        """
        void
        gdcm::Item::SetNestedDataSet(const DataSet &nested) 
        """
        return _gdcmswig.Item_SetNestedDataSet(self, nested)


    def GetNestedDataSet(self, *args) -> "gdcm::DataSet &":
        """
        DataSet&
        gdcm::Item::GetNestedDataSet() 
        """
        return _gdcmswig.Item_GetNestedDataSet(self, *args)


    def __init__(self, *args):
        """
        gdcm::Item::Item(Item const
        &val) 
        """
        this = _gdcmswig.new_Item(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def FindDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Item::FindDataElement(const Tag &t) const 
        """
        return _gdcmswig.Item_FindDataElement(self, t)


    def __str__(self) -> "char const *":
        return _gdcmswig.Item___str__(self)
    __swig_destroy__ = _gdcmswig.delete_Item
    __del__ = lambda self: None
Item_swigregister = _gdcmswig.Item_swigregister
Item_swigregister(Item)

class SequenceOfItems(Value):
    """


    Class to represent a Sequence Of Items.

    (value representation : SQ) a Value Representation for Data Elements
    that contains a sequence of Data Sets.

    Sequence of Item allows for Nested Data Sets

    See PS 3.5, 7.4.6 Data Element Type Within a Sequence SEQUENCE OF
    ITEMS (VALUE REPRESENTATION SQ) A Value Representation for Data
    Elements that contain a sequence of Data Sets. Sequence of Items
    allows for Nested Data Sets.

    C++ includes: gdcmSequenceOfItems.h 
    """

    __swig_setmethods__ = {}
    for _s in [Value]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceOfItems, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceOfItems, name)
    __repr__ = _swig_repr

    def Begin(self, *args) -> "gdcm::SequenceOfItems::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfItems::Begin() const 
        """
        return _gdcmswig.SequenceOfItems_Begin(self, *args)


    def End(self, *args) -> "gdcm::SequenceOfItems::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfItems::End() const 
        """
        return _gdcmswig.SequenceOfItems_End(self, *args)


    def __init__(self):
        """
        gdcm::SequenceOfItems::SequenceOfItems()

        constructor (UndefinedLength by default) 
        """
        this = _gdcmswig.new_SequenceOfItems()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfItems::GetLength() const

        Returns the SQ length, as read from disk. 
        """
        return _gdcmswig.SequenceOfItems_GetLength(self)


    def SetLength(self, length: 'VL') -> "void":
        """
        void
        gdcm::SequenceOfItems::SetLength(VL length)

        Sets the actual SQ length. 
        """
        return _gdcmswig.SequenceOfItems_SetLength(self, length)


    def SetLengthToUndefined(self) -> "void":
        """
        void gdcm::SequenceOfItems::SetLengthToUndefined()

        Properly set the Sequence of Item to be undefined length. 
        """
        return _gdcmswig.SequenceOfItems_SetLengthToUndefined(self)


    def IsUndefinedLength(self) -> "bool":
        """
        bool
        gdcm::SequenceOfItems::IsUndefinedLength() const

        return if Value Length if of undefined length 
        """
        return _gdcmswig.SequenceOfItems_IsUndefinedLength(self)


    def Clear(self) -> "void":
        """
        void
        gdcm::SequenceOfItems::Clear()

        remove all items within the sequence 
        """
        return _gdcmswig.SequenceOfItems_Clear(self)


    def AddItem(self, item: 'Item') -> "void":
        """
        void
        gdcm::SequenceOfItems::AddItem(Item const &item)

        Appends an Item to the already added ones. 
        """
        return _gdcmswig.SequenceOfItems_AddItem(self, item)


    def AddNewUndefinedLengthItem(self) -> "gdcm::Item &":
        """
        Item&
        gdcm::SequenceOfItems::AddNewUndefinedLengthItem()

        Appends an Item to the already added ones. 
        """
        return _gdcmswig.SequenceOfItems_AddNewUndefinedLengthItem(self)


    def RemoveItemByIndex(self, index: 'gdcm::SequenceOfItems::SizeType const') -> "bool":
        """
        bool
        gdcm::SequenceOfItems::RemoveItemByIndex(const SizeType index)

        Remove an Item as specified by its index, if index > size, false is
        returned Index starts at 1 not 0 
        """
        return _gdcmswig.SequenceOfItems_RemoveItemByIndex(self, index)


    def IsEmpty(self) -> "bool":
        return _gdcmswig.SequenceOfItems_IsEmpty(self)

    def GetNumberOfItems(self) -> "gdcm::SequenceOfItems::SizeType":
        """SizeType gdcm::SequenceOfItems::GetNumberOfItems() const """
        return _gdcmswig.SequenceOfItems_GetNumberOfItems(self)


    def SetNumberOfItems(self, n: 'gdcm::SequenceOfItems::SizeType') -> "void":
        """
        void
        gdcm::SequenceOfItems::SetNumberOfItems(SizeType n) 
        """
        return _gdcmswig.SequenceOfItems_SetNumberOfItems(self, n)


    def GetItem(self, *args) -> "gdcm::Item &":
        """
        Item&
        gdcm::SequenceOfItems::GetItem(SizeType position) 
        """
        return _gdcmswig.SequenceOfItems_GetItem(self, *args)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::SequenceOfItems::Print(std::ostream &os) const 
        """
        return _gdcmswig.SequenceOfItems_Print(self, os)

    if _newclass:
        New = staticmethod(_gdcmswig.SequenceOfItems_New)
    else:
        New = _gdcmswig.SequenceOfItems_New

    def FindDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::SequenceOfItems::FindDataElement(const Tag &t) const 
        """
        return _gdcmswig.SequenceOfItems_FindDataElement(self, t)


    def __eq__(self, val: 'Value') -> "bool":
        return _gdcmswig.SequenceOfItems___eq__(self, val)
    __swig_setmethods__["SequenceLengthField"] = _gdcmswig.SequenceOfItems_SequenceLengthField_set
    __swig_getmethods__["SequenceLengthField"] = _gdcmswig.SequenceOfItems_SequenceLengthField_get
    if _newclass:
        SequenceLengthField = _swig_property(_gdcmswig.SequenceOfItems_SequenceLengthField_get, _gdcmswig.SequenceOfItems_SequenceLengthField_set)
    __swig_setmethods__["Items"] = _gdcmswig.SequenceOfItems_Items_set
    __swig_getmethods__["Items"] = _gdcmswig.SequenceOfItems_Items_get
    if _newclass:
        Items = _swig_property(_gdcmswig.SequenceOfItems_Items_get, _gdcmswig.SequenceOfItems_Items_set)

    def __str__(self) -> "char const *":
        return _gdcmswig.SequenceOfItems___str__(self)
    __swig_destroy__ = _gdcmswig.delete_SequenceOfItems
    __del__ = lambda self: None
SequenceOfItems_swigregister = _gdcmswig.SequenceOfItems_swigregister
SequenceOfItems_swigregister(SequenceOfItems)

def SequenceOfItems_New() -> "gdcm::SmartPointer< gdcm::SequenceOfItems >":
    return _gdcmswig.SequenceOfItems_New()
SequenceOfItems_New = _gdcmswig.SequenceOfItems_New

class DataElementException(_object):
    """
    C++ includes:
    gdcmDataSet.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataElementException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataElementException, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _gdcmswig.new_DataElementException()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DataElementException
    __del__ = lambda self: None
DataElementException_swigregister = _gdcmswig.DataElementException_swigregister
DataElementException_swigregister(DataElementException)

class DataSet(_object):
    """


    Class to represent a Data Set (which contains Data Elements)

    A Data Set represents an instance of a real world Information Object
    DATA SET: Exchanged information consisting of a structured set of
    Attribute values directly or indirectly related to Information
    Objects. The value of each Attribute in a Data Set is expressed as a
    Data Element. A collection of Data Elements ordered by increasing Data
    Element Tag number that is an encoding of the values of Attributes of
    a real world object.

    Implementation note. If one do: DataSet ds; ds.SetLength(0);
    ds.Read(is); setting length to 0 actually means try to read is as if
    it was a root DataSet. Other value are undefined (nested dataset with
    undefined length) or defined length (different from 0) means nested
    dataset with defined length.

    WARNING:  a DataSet does not have a Transfer Syntax type, only a File
    does.

    C++ includes: gdcmDataSet.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataSet, name)
    __repr__ = _swig_repr

    def Begin(self, *args) -> "gdcm::DataSet::Iterator":
        """
        Iterator
        gdcm::DataSet::Begin() 
        """
        return _gdcmswig.DataSet_Begin(self, *args)


    def End(self, *args) -> "gdcm::DataSet::Iterator":
        """
        Iterator
        gdcm::DataSet::End() 
        """
        return _gdcmswig.DataSet_End(self, *args)


    def GetDES(self, *args) -> "gdcm::DataSet::DataElementSet &":
        """
        DataElementSet&
        gdcm::DataSet::GetDES() 
        """
        return _gdcmswig.DataSet_GetDES(self, *args)


    def Clear(self) -> "void":
        """
        void
        gdcm::DataSet::Clear() 
        """
        return _gdcmswig.DataSet_Clear(self)


    def Size(self) -> "gdcm::DataSet::SizeType":
        """
        SizeType
        gdcm::DataSet::Size() const 
        """
        return _gdcmswig.DataSet_Size(self)


    def Print(self, *args) -> "void":
        """
        void
        gdcm::DataSet::Print(std::ostream &os, std::string const &indent="")
        const 
        """
        return _gdcmswig.DataSet_Print(self, *args)


    def Insert(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::DataSet::Insert(const DataElement &de)

        Insert a DataElement in the DataSet. WARNING:  : Tag need to be >= 0x8
        to be considered valid data element 
        """
        return _gdcmswig.DataSet_Insert(self, de)


    def Replace(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::DataSet::Replace(const DataElement &de)

        Replace a dataelement with another one. 
        """
        return _gdcmswig.DataSet_Replace(self, de)


    def ReplaceEmpty(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::DataSet::ReplaceEmpty(const DataElement &de)

        Only replace a DICOM attribute when it is missing or empty. 
        """
        return _gdcmswig.DataSet_ReplaceEmpty(self, de)


    def Remove(self, tag: 'Tag') -> "gdcm::DataSet::SizeType":
        """
        SizeType
        gdcm::DataSet::Remove(const Tag &tag)

        Completely remove a dataelement from the dataset. 
        """
        return _gdcmswig.DataSet_Remove(self, tag)


    def __call__(self, group: 'uint16_t', element: 'uint16_t') -> "gdcm::DataElement const &":
        return _gdcmswig.DataSet___call__(self, group, element)

    def GetPrivateCreator(self, t: 'Tag') -> "std::string":
        """
        std::string
        gdcm::DataSet::GetPrivateCreator(const Tag &t) const

        Return the private creator of the private tag 't': 
        """
        return _gdcmswig.DataSet_GetPrivateCreator(self, t)


    def GetDataElement(self, *args) -> "gdcm::DataElement const &":
        """
        const
        DataElement& gdcm::DataSet::GetDataElement(const PrivateTag &t) const

        Return the dataelement. 
        """
        return _gdcmswig.DataSet_GetDataElement(self, *args)


    def FindDataElement(self, *args) -> "bool":
        """
        bool
        gdcm::DataSet::FindDataElement(const Tag &t) const 
        """
        return _gdcmswig.DataSet_FindDataElement(self, *args)


    def FindNextDataElement(self, t: 'Tag') -> "gdcm::DataElement const &":
        """
        const
        DataElement& gdcm::DataSet::FindNextDataElement(const Tag &t) const 
        """
        return _gdcmswig.DataSet_FindNextDataElement(self, t)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::DataSet::IsEmpty() const

        Returns if the dataset is empty. 
        """
        return _gdcmswig.DataSet_IsEmpty(self)


    def GetMediaStorage(self) -> "gdcm::MediaStorage":
        """
        MediaStorage
        gdcm::DataSet::GetMediaStorage() const 
        """
        return _gdcmswig.DataSet_GetMediaStorage(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.DataSet___str__(self)

    def __init__(self):
        this = _gdcmswig.new_DataSet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DataSet
    __del__ = lambda self: None
DataSet_swigregister = _gdcmswig.DataSet_swigregister
DataSet_swigregister(DataSet)

class PythonDataSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonDataSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonDataSet, name)
    __repr__ = _swig_repr

    def __init__(self, des: 'DataSet'):
        this = _gdcmswig.new_PythonDataSet(des)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetCurrent(self) -> "gdcm::DataElement const &":
        return _gdcmswig.PythonDataSet_GetCurrent(self)

    def Start(self) -> "void":
        return _gdcmswig.PythonDataSet_Start(self)

    def IsAtEnd(self) -> "bool":
        return _gdcmswig.PythonDataSet_IsAtEnd(self)

    def Next(self) -> "void":
        return _gdcmswig.PythonDataSet_Next(self)
    __swig_destroy__ = _gdcmswig.delete_PythonDataSet
    __del__ = lambda self: None
PythonDataSet_swigregister = _gdcmswig.PythonDataSet_swigregister
PythonDataSet_swigregister(PythonDataSet)

class PhotometricInterpretation(_object):
    """


    Class to represent an PhotometricInterpretation.

    C++ includes: gdcmPhotometricInterpretation.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PhotometricInterpretation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PhotometricInterpretation, name)
    __repr__ = _swig_repr
    UNKNOWN = _gdcmswig.PhotometricInterpretation_UNKNOWN
    MONOCHROME1 = _gdcmswig.PhotometricInterpretation_MONOCHROME1
    MONOCHROME2 = _gdcmswig.PhotometricInterpretation_MONOCHROME2
    PALETTE_COLOR = _gdcmswig.PhotometricInterpretation_PALETTE_COLOR
    RGB = _gdcmswig.PhotometricInterpretation_RGB
    HSV = _gdcmswig.PhotometricInterpretation_HSV
    ARGB = _gdcmswig.PhotometricInterpretation_ARGB
    CMYK = _gdcmswig.PhotometricInterpretation_CMYK
    YBR_FULL = _gdcmswig.PhotometricInterpretation_YBR_FULL
    YBR_FULL_422 = _gdcmswig.PhotometricInterpretation_YBR_FULL_422
    YBR_PARTIAL_422 = _gdcmswig.PhotometricInterpretation_YBR_PARTIAL_422
    YBR_PARTIAL_420 = _gdcmswig.PhotometricInterpretation_YBR_PARTIAL_420
    YBR_ICT = _gdcmswig.PhotometricInterpretation_YBR_ICT
    YBR_RCT = _gdcmswig.PhotometricInterpretation_YBR_RCT
    PI_END = _gdcmswig.PhotometricInterpretation_PI_END

    def __init__(self, *args):
        """
        gdcm::PhotometricInterpretation::PhotometricInterpretation(PIType
        pi=UNKNOWN) 
        """
        this = _gdcmswig.new_PhotometricInterpretation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        GetPIString = staticmethod(_gdcmswig.PhotometricInterpretation_GetPIString)
    else:
        GetPIString = _gdcmswig.PhotometricInterpretation_GetPIString

    def GetString(self) -> "char const *":
        """const char* gdcm::PhotometricInterpretation::GetString() const """
        return _gdcmswig.PhotometricInterpretation_GetString(self)

    if _newclass:
        GetPIType = staticmethod(_gdcmswig.PhotometricInterpretation_GetPIType)
    else:
        GetPIType = _gdcmswig.PhotometricInterpretation_GetPIType
    if _newclass:
        IsRetired = staticmethod(_gdcmswig.PhotometricInterpretation_IsRetired)
    else:
        IsRetired = _gdcmswig.PhotometricInterpretation_IsRetired

    def IsLossy(self) -> "bool":
        """
        bool
        gdcm::PhotometricInterpretation::IsLossy() const 
        """
        return _gdcmswig.PhotometricInterpretation_IsLossy(self)


    def IsLossless(self) -> "bool":
        """bool gdcm::PhotometricInterpretation::IsLossless() const """
        return _gdcmswig.PhotometricInterpretation_IsLossless(self)


    def GetSamplesPerPixel(self) -> "unsigned short":
        """
        unsigned short
        gdcm::PhotometricInterpretation::GetSamplesPerPixel() const

        return the value for Sample Per Pixel associated with a particular
        Photometric Interpretation 
        """
        return _gdcmswig.PhotometricInterpretation_GetSamplesPerPixel(self)


    def GetType(self) -> "gdcm::PhotometricInterpretation::PIType":
        """PIType gdcm::PhotometricInterpretation::GetType() const """
        return _gdcmswig.PhotometricInterpretation_GetType(self)


    def IsSameColorSpace(self, pi: 'PhotometricInterpretation') -> "bool":
        """
        bool
        gdcm::PhotometricInterpretation::IsSameColorSpace(PhotometricInterpretation
        const &pi) const 
        """
        return _gdcmswig.PhotometricInterpretation_IsSameColorSpace(self, pi)


    def __str__(self) -> "char const *":
        return _gdcmswig.PhotometricInterpretation___str__(self)
    __swig_destroy__ = _gdcmswig.delete_PhotometricInterpretation
    __del__ = lambda self: None
PhotometricInterpretation_swigregister = _gdcmswig.PhotometricInterpretation_swigregister
PhotometricInterpretation_swigregister(PhotometricInterpretation)

def PhotometricInterpretation_GetPIString(pi: 'gdcm::PhotometricInterpretation::PIType') -> "char const *":
    return _gdcmswig.PhotometricInterpretation_GetPIString(pi)
PhotometricInterpretation_GetPIString = _gdcmswig.PhotometricInterpretation_GetPIString

def PhotometricInterpretation_GetPIType(pi: 'char const *') -> "gdcm::PhotometricInterpretation::PIType":
    return _gdcmswig.PhotometricInterpretation_GetPIType(pi)
PhotometricInterpretation_GetPIType = _gdcmswig.PhotometricInterpretation_GetPIType

def PhotometricInterpretation_IsRetired(pi: 'gdcm::PhotometricInterpretation::PIType') -> "bool":
    return _gdcmswig.PhotometricInterpretation_IsRetired(pi)
PhotometricInterpretation_IsRetired = _gdcmswig.PhotometricInterpretation_IsRetired

class LookupTable(Object):
    """


    LookupTable class.

    C++ includes: gdcmLookupTable.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, LookupTable, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, LookupTable, name)
    __repr__ = _swig_repr
    RED = _gdcmswig.LookupTable_RED
    GREEN = _gdcmswig.LookupTable_GREEN
    BLUE = _gdcmswig.LookupTable_BLUE
    GRAY = _gdcmswig.LookupTable_GRAY
    UNKNOWN = _gdcmswig.LookupTable_UNKNOWN
    __swig_destroy__ = _gdcmswig.delete_LookupTable
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::LookupTable::Print(std::ostream &) const 
        """
        return _gdcmswig.LookupTable_Print(self, arg2)


    def Allocate(self, bitsample: 'unsigned short'=8) -> "void":
        """
        void
        gdcm::LookupTable::Allocate(unsigned short bitsample=8)

        Allocate the LUT. 
        """
        return _gdcmswig.LookupTable_Allocate(self, bitsample)


    def InitializeLUT(self, type: 'gdcm::LookupTable::LookupTableType', length: 'unsigned short', subscript: 'unsigned short', bitsize: 'unsigned short') -> "void":
        """
        void
        gdcm::LookupTable::InitializeLUT(LookupTableType type, unsigned short
        length, unsigned short subscript, unsigned short bitsize)

        Generic interface: 
        """
        return _gdcmswig.LookupTable_InitializeLUT(self, type, length, subscript, bitsize)


    def GetLUTLength(self, type: 'gdcm::LookupTable::LookupTableType') -> "unsigned int":
        """
        unsigned int
        gdcm::LookupTable::GetLUTLength(LookupTableType type) const 
        """
        return _gdcmswig.LookupTable_GetLUTLength(self, type)


    def SetLUT(self, type: 'gdcm::LookupTable::LookupTableType', array: 'unsigned char const *', length: 'unsigned int') -> "void":
        """
        virtual void
        gdcm::LookupTable::SetLUT(LookupTableType type, const unsigned char
        *array, unsigned int length) 
        """
        return _gdcmswig.LookupTable_SetLUT(self, type, array, length)


    def GetLUT(self, type: 'gdcm::LookupTable::LookupTableType', array: 'unsigned char *', length: 'unsigned int &') -> "void":
        """
        void
        gdcm::LookupTable::GetLUT(LookupTableType type, unsigned char *array,
        unsigned int &length) const 
        """
        return _gdcmswig.LookupTable_GetLUT(self, type, array, length)


    def GetLUTDescriptor(self, type: 'gdcm::LookupTable::LookupTableType', length: 'unsigned short &', subscript: 'unsigned short &', bitsize: 'unsigned short &') -> "void":
        """
        void
        gdcm::LookupTable::GetLUTDescriptor(LookupTableType type, unsigned
        short &length, unsigned short &subscript, unsigned short &bitsize)
        const 
        """
        return _gdcmswig.LookupTable_GetLUTDescriptor(self, type, length, subscript, bitsize)


    def InitializeRedLUT(self, length: 'unsigned short', subscript: 'unsigned short', bitsize: 'unsigned short') -> "void":
        """
        void
        gdcm::LookupTable::InitializeRedLUT(unsigned short length, unsigned
        short subscript, unsigned short bitsize)

        RED / GREEN / BLUE specific: 
        """
        return _gdcmswig.LookupTable_InitializeRedLUT(self, length, subscript, bitsize)


    def SetRedLUT(self, red: 'unsigned char const *', length: 'unsigned int') -> "void":
        """
        void
        gdcm::LookupTable::SetRedLUT(const unsigned char *red, unsigned int
        length) 
        """
        return _gdcmswig.LookupTable_SetRedLUT(self, red, length)


    def InitializeGreenLUT(self, length: 'unsigned short', subscript: 'unsigned short', bitsize: 'unsigned short') -> "void":
        """
        void
        gdcm::LookupTable::InitializeGreenLUT(unsigned short length, unsigned
        short subscript, unsigned short bitsize) 
        """
        return _gdcmswig.LookupTable_InitializeGreenLUT(self, length, subscript, bitsize)


    def SetGreenLUT(self, green: 'unsigned char const *', length: 'unsigned int') -> "void":
        """
        void
        gdcm::LookupTable::SetGreenLUT(const unsigned char *green, unsigned
        int length) 
        """
        return _gdcmswig.LookupTable_SetGreenLUT(self, green, length)


    def InitializeBlueLUT(self, length: 'unsigned short', subscript: 'unsigned short', bitsize: 'unsigned short') -> "void":
        """
        void
        gdcm::LookupTable::InitializeBlueLUT(unsigned short length, unsigned
        short subscript, unsigned short bitsize) 
        """
        return _gdcmswig.LookupTable_InitializeBlueLUT(self, length, subscript, bitsize)


    def SetBlueLUT(self, blue: 'unsigned char const *', length: 'unsigned int') -> "void":
        """
        void
        gdcm::LookupTable::SetBlueLUT(const unsigned char *blue, unsigned int
        length) 
        """
        return _gdcmswig.LookupTable_SetBlueLUT(self, blue, length)


    def Clear(self) -> "void":
        """
        void
        gdcm::LookupTable::Clear()

        Clear the LUT. 
        """
        return _gdcmswig.LookupTable_Clear(self)


    def Decode(self, *args) -> "bool":
        """
        bool
        gdcm::LookupTable::Decode(char *outputbuffer, size_t outlen, const
        char *inputbuffer, size_t inlen) const

        Decode the LUT outputbuffer will contains the RGB decoded PALETTE
        COLOR input image of size inlen the outputbuffer should be at least 3
        times the size of inlen 
        """
        return _gdcmswig.LookupTable_Decode(self, *args)


    def IsRGB8(self) -> "bool":
        return _gdcmswig.LookupTable_IsRGB8(self)

    def Decode8(self, outputbuffer: 'char *', outlen: 'size_t', inputbuffer: 'char const *', inlen: 'size_t') -> "bool":
        return _gdcmswig.LookupTable_Decode8(self, outputbuffer, outlen, inputbuffer, inlen)

    def __init__(self, *args):
        """gdcm::LookupTable::LookupTable(LookupTable const &lut) """
        this = _gdcmswig.new_LookupTable(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetBufferAsRGBA(self, rgba: 'unsigned char *') -> "bool":
        """
        bool
        gdcm::LookupTable::GetBufferAsRGBA(unsigned char *rgba) const

        return the LUT as RGBA buffer 
        """
        return _gdcmswig.LookupTable_GetBufferAsRGBA(self, rgba)


    def GetPointer(self) -> "unsigned char const *":
        """
        const unsigned
        char* gdcm::LookupTable::GetPointer() const

        return a raw pointer to the LUT 
        """
        return _gdcmswig.LookupTable_GetPointer(self)


    def WriteBufferAsRGBA(self, rgba: 'unsigned char const *') -> "bool":
        """
        bool
        gdcm::LookupTable::WriteBufferAsRGBA(const unsigned char *rgba)

        Write the LUT as RGBA. 
        """
        return _gdcmswig.LookupTable_WriteBufferAsRGBA(self, rgba)


    def GetBitSample(self) -> "unsigned short":
        """
        unsigned
        short gdcm::LookupTable::GetBitSample() const

        return the bit sample 
        """
        return _gdcmswig.LookupTable_GetBitSample(self)


    def Initialized(self) -> "bool":
        """
        bool
        gdcm::LookupTable::Initialized() const

        return whether the LUT has been initialized 
        """
        return _gdcmswig.LookupTable_Initialized(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.LookupTable___str__(self)
LookupTable_swigregister = _gdcmswig.LookupTable_swigregister
LookupTable_swigregister(LookupTable)

class Overlay(Object):
    """


    Overlay class.

    see AreOverlaysInPixelData Todo Is there actually any way to recognize
    an overlay ? On images with multiple overlay I do not see any way to
    differenciate them (other than the group tag).

    Example:

    C++ includes: gdcmOverlay.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Overlay, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Overlay, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Overlay
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::Overlay::Print(std::ostream &) const

        Print. 
        """
        return _gdcmswig.Overlay_Print(self, arg2)


    def Update(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::Overlay::Update(const DataElement &de)

        Update overlay from data element de: 
        """
        return _gdcmswig.Overlay_Update(self, de)


    def SetGroup(self, group: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetGroup(unsigned short group)

        Set Group number. 
        """
        return _gdcmswig.Overlay_SetGroup(self, group)


    def GetGroup(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Overlay::GetGroup() const

        Get Group number. 
        """
        return _gdcmswig.Overlay_GetGroup(self)


    def SetRows(self, rows: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetRows(unsigned short rows)

        set rows 
        """
        return _gdcmswig.Overlay_SetRows(self, rows)


    def GetRows(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Overlay::GetRows() const

        get rows 
        """
        return _gdcmswig.Overlay_GetRows(self)


    def SetColumns(self, columns: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetColumns(unsigned short columns)

        set columns 
        """
        return _gdcmswig.Overlay_SetColumns(self, columns)


    def GetColumns(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Overlay::GetColumns() const

        get columns 
        """
        return _gdcmswig.Overlay_GetColumns(self)


    def SetNumberOfFrames(self, numberofframes: 'unsigned int') -> "void":
        """
        void
        gdcm::Overlay::SetNumberOfFrames(unsigned int numberofframes)

        set number of frames 
        """
        return _gdcmswig.Overlay_SetNumberOfFrames(self, numberofframes)


    def SetDescription(self, description: 'char const *') -> "void":
        """
        void
        gdcm::Overlay::SetDescription(const char *description)

        set description 
        """
        return _gdcmswig.Overlay_SetDescription(self, description)


    def GetDescription(self) -> "char const *":
        """
        const char*
        gdcm::Overlay::GetDescription() const

        get description 
        """
        return _gdcmswig.Overlay_GetDescription(self)

    Invalid = _gdcmswig.Overlay_Invalid
    Graphics = _gdcmswig.Overlay_Graphics
    ROI = _gdcmswig.Overlay_ROI

    def SetType(self, type: 'char const *') -> "void":
        """
        void
        gdcm::Overlay::SetType(const char *type)

        set type 
        """
        return _gdcmswig.Overlay_SetType(self, type)


    def GetType(self) -> "char const *":
        """
        const char*
        gdcm::Overlay::GetType() const

        get type 
        """
        return _gdcmswig.Overlay_GetType(self)


    def GetTypeAsEnum(self) -> "gdcm::Overlay::OverlayType":
        """
        OverlayType
        gdcm::Overlay::GetTypeAsEnum() const 
        """
        return _gdcmswig.Overlay_GetTypeAsEnum(self)

    if _newclass:
        GetOverlayTypeAsString = staticmethod(_gdcmswig.Overlay_GetOverlayTypeAsString)
    else:
        GetOverlayTypeAsString = _gdcmswig.Overlay_GetOverlayTypeAsString
    if _newclass:
        GetOverlayTypeFromString = staticmethod(_gdcmswig.Overlay_GetOverlayTypeFromString)
    else:
        GetOverlayTypeFromString = _gdcmswig.Overlay_GetOverlayTypeFromString

    def SetOrigin(self, origin: 'short const [2]') -> "void":
        """
        void
        gdcm::Overlay::SetOrigin(const signed short origin[2])

        set origin 
        """
        return _gdcmswig.Overlay_SetOrigin(self, origin)


    def GetOrigin(self) -> "short const *":
        """
        const signed short*
        gdcm::Overlay::GetOrigin() const

        get origin 
        """
        return _gdcmswig.Overlay_GetOrigin(self)


    def SetFrameOrigin(self, frameorigin: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetFrameOrigin(unsigned short frameorigin)

        set frame origin 
        """
        return _gdcmswig.Overlay_SetFrameOrigin(self, frameorigin)


    def SetBitsAllocated(self, bitsallocated: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetBitsAllocated(unsigned short bitsallocated)

        set bits allocated 
        """
        return _gdcmswig.Overlay_SetBitsAllocated(self, bitsallocated)


    def GetBitsAllocated(self) -> "unsigned short":
        """
        unsigned
        short gdcm::Overlay::GetBitsAllocated() const

        return bits allocated 
        """
        return _gdcmswig.Overlay_GetBitsAllocated(self)


    def SetBitPosition(self, bitposition: 'unsigned short') -> "void":
        """
        void
        gdcm::Overlay::SetBitPosition(unsigned short bitposition)

        set bit position 
        """
        return _gdcmswig.Overlay_SetBitPosition(self, bitposition)


    def GetBitPosition(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Overlay::GetBitPosition() const

        return bit position 
        """
        return _gdcmswig.Overlay_GetBitPosition(self)


    def SetOverlay(self, array: 'char const *', length: 'size_t') -> "void":
        """
        void
        gdcm::Overlay::SetOverlay(const char *array, size_t length)

        set overlay from byte array + length 
        """
        return _gdcmswig.Overlay_SetOverlay(self, array, length)


    def GrabOverlayFromPixelData(self, ds: 'DataSet') -> "bool":
        """
        bool
        gdcm::Overlay::GrabOverlayFromPixelData(DataSet const &ds) 
        """
        return _gdcmswig.Overlay_GrabOverlayFromPixelData(self, ds)


    def GetOverlayData(self) -> "gdcm::ByteValue const &":
        """
        const
        ByteValue& gdcm::Overlay::GetOverlayData() const

        Return the Overlay Data as ByteValue: Not thread safe 
        """
        return _gdcmswig.Overlay_GetOverlayData(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Overlay::IsEmpty() const

        Return whether or not the Overlay is empty: 
        """
        return _gdcmswig.Overlay_IsEmpty(self)


    def IsZero(self) -> "bool":
        """
        bool
        gdcm::Overlay::IsZero() const

        return true if all bits are set to 0 
        """
        return _gdcmswig.Overlay_IsZero(self)


    def IsInPixelData(self, *args) -> "void":
        """
        void
        gdcm::Overlay::IsInPixelData(bool b)

        Set whether or no the OverlayData is in the Pixel Data: 
        """
        return _gdcmswig.Overlay_IsInPixelData(self, *args)


    def Decompress(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Overlay::Decompress(std::ostream &os) const

        Decode the internal OverlayData (packed bits) into unpacked
        representation. 
        """
        return _gdcmswig.Overlay_Decompress(self, os)


    def GetUnpackBufferLength(self) -> "size_t":
        """
        size_t
        gdcm::Overlay::GetUnpackBufferLength() const

        Retrieve the size of the buffer needed to hold the Overlay as
        specified by Col & Row parameters 
        """
        return _gdcmswig.Overlay_GetUnpackBufferLength(self)


    def GetUnpackBuffer(self, buffer: 'char *', len: 'size_t') -> "bool":
        """
        bool
        gdcm::Overlay::GetUnpackBuffer(char *buffer, size_t len) const

        Retrieve the unpack buffer for Overlay. This is an error if the size
        if below GetUnpackBufferLength() 
        """
        return _gdcmswig.Overlay_GetUnpackBuffer(self, buffer, len)


    def __init__(self, *args):
        """gdcm::Overlay::Overlay(Overlay const &ov) """
        this = _gdcmswig.new_Overlay(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self) -> "char const *":
        return _gdcmswig.Overlay___str__(self)
Overlay_swigregister = _gdcmswig.Overlay_swigregister
Overlay_swigregister(Overlay)

def Overlay_GetOverlayTypeAsString(ot: 'gdcm::Overlay::OverlayType') -> "char const *":
    return _gdcmswig.Overlay_GetOverlayTypeAsString(ot)
Overlay_GetOverlayTypeAsString = _gdcmswig.Overlay_GetOverlayTypeAsString

def Overlay_GetOverlayTypeFromString(arg2: 'char const *') -> "gdcm::Overlay::OverlayType":
    return _gdcmswig.Overlay_GetOverlayTypeFromString(arg2)
Overlay_GetOverlayTypeFromString = _gdcmswig.Overlay_GetOverlayTypeFromString

class DataElementSet(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataElementSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataElementSet, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.DataElementSet_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.DataElementSet___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.DataElementSet___bool__(self)

    def __len__(self) -> "std::set< gdcm::DataElement >::size_type":
        return _gdcmswig.DataElementSet___len__(self)

    def append(self, x: 'DataElement') -> "void":
        return _gdcmswig.DataElementSet_append(self, x)

    def __contains__(self, x: 'DataElement') -> "bool":
        return _gdcmswig.DataElementSet___contains__(self, x)

    def __getitem__(self, i: 'std::set< gdcm::DataElement >::difference_type') -> "std::set< gdcm::DataElement >::value_type":
        return _gdcmswig.DataElementSet___getitem__(self, i)

    def add(self, x: 'DataElement') -> "void":
        return _gdcmswig.DataElementSet_add(self, x)

    def discard(self, x: 'DataElement') -> "void":
        return _gdcmswig.DataElementSet_discard(self, x)

    def __init__(self, *args):
        this = _gdcmswig.new_DataElementSet(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _gdcmswig.DataElementSet_empty(self)

    def size(self) -> "std::set< gdcm::DataElement >::size_type":
        return _gdcmswig.DataElementSet_size(self)

    def clear(self) -> "void":
        return _gdcmswig.DataElementSet_clear(self)

    def swap(self, v: 'DataElementSet') -> "void":
        return _gdcmswig.DataElementSet_swap(self, v)

    def count(self, x: 'DataElement') -> "std::set< gdcm::DataElement >::size_type":
        return _gdcmswig.DataElementSet_count(self, x)

    def begin(self) -> "std::set< gdcm::DataElement >::iterator":
        return _gdcmswig.DataElementSet_begin(self)

    def end(self) -> "std::set< gdcm::DataElement >::iterator":
        return _gdcmswig.DataElementSet_end(self)

    def rbegin(self) -> "std::set< gdcm::DataElement >::reverse_iterator":
        return _gdcmswig.DataElementSet_rbegin(self)

    def rend(self) -> "std::set< gdcm::DataElement >::reverse_iterator":
        return _gdcmswig.DataElementSet_rend(self)

    def erase(self, *args) -> "void":
        return _gdcmswig.DataElementSet_erase(self, *args)

    def find(self, x: 'DataElement') -> "std::set< gdcm::DataElement >::iterator":
        return _gdcmswig.DataElementSet_find(self, x)

    def lower_bound(self, x: 'DataElement') -> "std::set< gdcm::DataElement >::iterator":
        return _gdcmswig.DataElementSet_lower_bound(self, x)

    def upper_bound(self, x: 'DataElement') -> "std::set< gdcm::DataElement >::iterator":
        return _gdcmswig.DataElementSet_upper_bound(self, x)

    def equal_range(self, x: 'DataElement') -> "std::pair< std::set< gdcm::DataElement >::iterator,std::set< gdcm::DataElement >::iterator >":
        return _gdcmswig.DataElementSet_equal_range(self, x)

    def insert(self, __x: 'DataElement') -> "std::pair< std::set< gdcm::DataElement >::iterator,bool >":
        return _gdcmswig.DataElementSet_insert(self, __x)
    __swig_destroy__ = _gdcmswig.delete_DataElementSet
    __del__ = lambda self: None
DataElementSet_swigregister = _gdcmswig.DataElementSet_swigregister
DataElementSet_swigregister(DataElementSet)

class Preamble(_object):
    """


    DICOM Preamble (Part 10)

    C++ includes: gdcmPreamble.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Preamble, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Preamble, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Preamble
    __del__ = lambda self: None

    def Clear(self) -> "void":
        """
        void
        gdcm::Preamble::Clear()

        Clear. 
        """
        return _gdcmswig.Preamble_Clear(self)


    def Valid(self) -> "void":
        """
        void
        gdcm::Preamble::Valid()

        Set Preamble to the default one. 
        """
        return _gdcmswig.Preamble_Valid(self)


    def Create(self) -> "void":
        """
        void
        gdcm::Preamble::Create() 
        """
        return _gdcmswig.Preamble_Create(self)


    def Remove(self) -> "void":
        """
        void
        gdcm::Preamble::Remove() 
        """
        return _gdcmswig.Preamble_Remove(self)


    def Read(self, arg2: 'std::istream &') -> "std::istream &":
        """
        std::istream&
        gdcm::Preamble::Read(std::istream &is)

        Read Preamble. 
        """
        return _gdcmswig.Preamble_Read(self, arg2)


    def Write(self, os: 'std::ostream &') -> "std::ostream const &":
        """
        std::ostream const&
        gdcm::Preamble::Write(std::ostream &os) const

        Write Preamble. 
        """
        return _gdcmswig.Preamble_Write(self, os)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Preamble::Print(std::ostream &os) const

        Print Preamble. 
        """
        return _gdcmswig.Preamble_Print(self, os)


    def GetInternal(self) -> "char const *":
        """
        const char*
        gdcm::Preamble::GetInternal() const

        Get internal pointer to preamble. 
        """
        return _gdcmswig.Preamble_GetInternal(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Preamble::IsEmpty() const

        Check if Preamble is empty. 
        """
        return _gdcmswig.Preamble_IsEmpty(self)


    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::Preamble::GetLength() const

        Return size of Preamble. 
        """
        return _gdcmswig.Preamble_GetLength(self)


    def __init__(self, *args):
        """gdcm::Preamble::Preamble(Preamble const &) """
        this = _gdcmswig.new_Preamble(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self) -> "char const *":
        return _gdcmswig.Preamble___str__(self)
Preamble_swigregister = _gdcmswig.Preamble_swigregister
Preamble_swigregister(Preamble)

class TransferSyntax(_object):
    """


    Class to manipulate Transfer Syntax.

    TRANSFER SYNTAX (Standard and Private): A set of encoding rules that
    allow Application Entities to unambiguously negotiate the encoding
    techniques (e.g., Data Element structure, byte ordering, compression)
    they are able to support, thereby allowing these Application Entities
    to communicate. Todo : The implementation is completely retarded ->
    see gdcm::UIDs for a replacement We need: IsSupported We need
    preprocess of raw/xml file We need GetFullName()

    Need a notion of Private Syntax. As defined in PS 3.5. Section 9.2

    See:   UIDs

    C++ includes: gdcmTransferSyntax.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TransferSyntax, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TransferSyntax, name)
    __repr__ = _swig_repr
    Unknown = _gdcmswig.TransferSyntax_Unknown
    Explicit = _gdcmswig.TransferSyntax_Explicit
    Implicit = _gdcmswig.TransferSyntax_Implicit
    ImplicitVRLittleEndian = _gdcmswig.TransferSyntax_ImplicitVRLittleEndian
    ImplicitVRBigEndianPrivateGE = _gdcmswig.TransferSyntax_ImplicitVRBigEndianPrivateGE
    ExplicitVRLittleEndian = _gdcmswig.TransferSyntax_ExplicitVRLittleEndian
    DeflatedExplicitVRLittleEndian = _gdcmswig.TransferSyntax_DeflatedExplicitVRLittleEndian
    ExplicitVRBigEndian = _gdcmswig.TransferSyntax_ExplicitVRBigEndian
    JPEGBaselineProcess1 = _gdcmswig.TransferSyntax_JPEGBaselineProcess1
    JPEGExtendedProcess2_4 = _gdcmswig.TransferSyntax_JPEGExtendedProcess2_4
    JPEGExtendedProcess3_5 = _gdcmswig.TransferSyntax_JPEGExtendedProcess3_5
    JPEGSpectralSelectionProcess6_8 = _gdcmswig.TransferSyntax_JPEGSpectralSelectionProcess6_8
    JPEGFullProgressionProcess10_12 = _gdcmswig.TransferSyntax_JPEGFullProgressionProcess10_12
    JPEGLosslessProcess14 = _gdcmswig.TransferSyntax_JPEGLosslessProcess14
    JPEGLosslessProcess14_1 = _gdcmswig.TransferSyntax_JPEGLosslessProcess14_1
    JPEGLSLossless = _gdcmswig.TransferSyntax_JPEGLSLossless
    JPEGLSNearLossless = _gdcmswig.TransferSyntax_JPEGLSNearLossless
    JPEG2000Lossless = _gdcmswig.TransferSyntax_JPEG2000Lossless
    JPEG2000 = _gdcmswig.TransferSyntax_JPEG2000
    JPEG2000Part2Lossless = _gdcmswig.TransferSyntax_JPEG2000Part2Lossless
    JPEG2000Part2 = _gdcmswig.TransferSyntax_JPEG2000Part2
    RLELossless = _gdcmswig.TransferSyntax_RLELossless
    MPEG2MainProfile = _gdcmswig.TransferSyntax_MPEG2MainProfile
    ImplicitVRBigEndianACRNEMA = _gdcmswig.TransferSyntax_ImplicitVRBigEndianACRNEMA
    WeirdPapryus = _gdcmswig.TransferSyntax_WeirdPapryus
    CT_private_ELE = _gdcmswig.TransferSyntax_CT_private_ELE
    JPIPReferenced = _gdcmswig.TransferSyntax_JPIPReferenced
    MPEG2MainProfileHighLevel = _gdcmswig.TransferSyntax_MPEG2MainProfileHighLevel
    MPEG4AVCH264HighProfileLevel4_1 = _gdcmswig.TransferSyntax_MPEG4AVCH264HighProfileLevel4_1
    MPEG4AVCH264BDcompatibleHighProfileLevel4_1 = _gdcmswig.TransferSyntax_MPEG4AVCH264BDcompatibleHighProfileLevel4_1
    TS_END = _gdcmswig.TransferSyntax_TS_END
    if _newclass:
        GetTSString = staticmethod(_gdcmswig.TransferSyntax_GetTSString)
    else:
        GetTSString = _gdcmswig.TransferSyntax_GetTSString
    if _newclass:
        GetTSType = staticmethod(_gdcmswig.TransferSyntax_GetTSType)
    else:
        GetTSType = _gdcmswig.TransferSyntax_GetTSType

    def GetNegociatedType(self) -> "gdcm::TransferSyntax::NegociatedType":
        """NegociatedType gdcm::TransferSyntax::GetNegociatedType() const """
        return _gdcmswig.TransferSyntax_GetNegociatedType(self)


    def GetSwapCode(self) -> "gdcm::SwapCode":
        """
        SwapCode
        gdcm::TransferSyntax::GetSwapCode() const

        Deprecated Return the SwapCode associated with the Transfer Syntax. Be
        careful with the special GE private syntax the DataSet is written in
        little endian but the Pixel Data is in Big Endian. 
        """
        return _gdcmswig.TransferSyntax_GetSwapCode(self)


    def IsValid(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsValid() const 
        """
        return _gdcmswig.TransferSyntax_IsValid(self)


    def __init__(self, *args):
        """
        gdcm::TransferSyntax::TransferSyntax(TSType
        type=ImplicitVRLittleEndian) 
        """
        this = _gdcmswig.new_TransferSyntax(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def IsEncoded(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsEncoded() const 
        """
        return _gdcmswig.TransferSyntax_IsEncoded(self)


    def IsImplicit(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsImplicit() const 
        """
        return _gdcmswig.TransferSyntax_IsImplicit(self)


    def IsExplicit(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsExplicit() const 
        """
        return _gdcmswig.TransferSyntax_IsExplicit(self)


    def IsEncapsulated(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsEncapsulated() const 
        """
        return _gdcmswig.TransferSyntax_IsEncapsulated(self)


    def IsLossy(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsLossy() const

        Return true if the transfer syntax algorithm is a lossy algorithm 
        """
        return _gdcmswig.TransferSyntax_IsLossy(self)


    def IsLossless(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::IsLossless() const

        Return true if the transfer syntax algorithm is a lossless algorithm

        """
        return _gdcmswig.TransferSyntax_IsLossless(self)


    def CanStoreLossy(self) -> "bool":
        """
        bool
        gdcm::TransferSyntax::CanStoreLossy() const

        return true if TransFer Syntax Allow storing of Lossy Pixel Data 
        """
        return _gdcmswig.TransferSyntax_CanStoreLossy(self)


    def GetString(self) -> "char const *":
        """
        const char*
        gdcm::TransferSyntax::GetString() const 
        """
        return _gdcmswig.TransferSyntax_GetString(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.TransferSyntax___str__(self)
    __swig_destroy__ = _gdcmswig.delete_TransferSyntax
    __del__ = lambda self: None
TransferSyntax_swigregister = _gdcmswig.TransferSyntax_swigregister
TransferSyntax_swigregister(TransferSyntax)

def TransferSyntax_GetTSString(ts: 'gdcm::TransferSyntax::TSType') -> "char const *":
    return _gdcmswig.TransferSyntax_GetTSString(ts)
TransferSyntax_GetTSString = _gdcmswig.TransferSyntax_GetTSString

def TransferSyntax_GetTSType(str: 'char const *') -> "gdcm::TransferSyntax::TSType":
    return _gdcmswig.TransferSyntax_GetTSType(str)
TransferSyntax_GetTSType = _gdcmswig.TransferSyntax_GetTSType

class FileMetaInformation(DataSet):
    """


    Class to represent a File Meta Information.

    FileMetaInformation is a Explicit Structured Set. Whenever the file
    contains an ImplicitDataElement DataSet, a conversion will take place.

    Definition: The File Meta Information includes identifying information
    on the encapsulated Data Set. This header consists of a 128 byte File
    Preamble, followed by a 4 byte DICOM prefix, followed by the File Meta
    Elements shown in Table 7.1-1. This header shall be present in every
    DICOM file.

    See:   Writer Reader

    C++ includes: gdcmFileMetaInformation.h 
    """

    __swig_setmethods__ = {}
    for _s in [DataSet]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileMetaInformation, name, value)
    __swig_getmethods__ = {}
    for _s in [DataSet]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileMetaInformation, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_FileMetaInformation
    __del__ = lambda self: None

    def IsValid(self) -> "bool":
        """
        bool
        gdcm::FileMetaInformation::IsValid() const 
        """
        return _gdcmswig.FileMetaInformation_IsValid(self)


    def GetMetaInformationTS(self) -> "gdcm::TransferSyntax::NegociatedType":
        """
        TransferSyntax::NegociatedType
        gdcm::FileMetaInformation::GetMetaInformationTS() const 
        """
        return _gdcmswig.FileMetaInformation_GetMetaInformationTS(self)


    def SetDataSetTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::FileMetaInformation::SetDataSetTransferSyntax(const
        TransferSyntax &ts) 
        """
        return _gdcmswig.FileMetaInformation_SetDataSetTransferSyntax(self, ts)


    def GetDataSetTransferSyntax(self) -> "gdcm::TransferSyntax const &":
        """
        const
        TransferSyntax& gdcm::FileMetaInformation::GetDataSetTransferSyntax()
        const 
        """
        return _gdcmswig.FileMetaInformation_GetDataSetTransferSyntax(self)


    def GetMediaStorage(self) -> "gdcm::MediaStorage":
        """MediaStorage gdcm::FileMetaInformation::GetMediaStorage() const """
        return _gdcmswig.FileMetaInformation_GetMediaStorage(self)


    def GetMediaStorageAsString(self) -> "std::string":
        """
        std::string
        gdcm::FileMetaInformation::GetMediaStorageAsString() const 
        """
        return _gdcmswig.FileMetaInformation_GetMediaStorageAsString(self)


    def Insert(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::FileMetaInformation::Insert(const DataElement &de) 
        """
        return _gdcmswig.FileMetaInformation_Insert(self, de)


    def Replace(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::FileMetaInformation::Replace(const DataElement &de) 
        """
        return _gdcmswig.FileMetaInformation_Replace(self, de)


    def Read(self, arg2: 'std::istream &') -> "std::istream &":
        """
        std::istream&
        gdcm::FileMetaInformation::Read(std::istream &is)

        Read. 
        """
        return _gdcmswig.FileMetaInformation_Read(self, arg2)


    def ReadCompat(self, arg2: 'std::istream &') -> "std::istream &":
        """
        std::istream& gdcm::FileMetaInformation::ReadCompat(std::istream &is)

        """
        return _gdcmswig.FileMetaInformation_ReadCompat(self, arg2)


    def Write(self, os: 'std::ostream &') -> "std::ostream &":
        """
        std::ostream& gdcm::FileMetaInformation::Write(std::ostream &os) const

        Write. 
        """
        return _gdcmswig.FileMetaInformation_Write(self, os)


    def FillFromDataSet(self, ds: 'DataSet') -> "void":
        """
        void gdcm::FileMetaInformation::FillFromDataSet(DataSet const &ds)

        Construct a FileMetaInformation from an already existing DataSet: 
        """
        return _gdcmswig.FileMetaInformation_FillFromDataSet(self, ds)


    def GetPreamble(self, *args) -> "gdcm::Preamble &":
        """Preamble& gdcm::FileMetaInformation::GetPreamble() """
        return _gdcmswig.FileMetaInformation_GetPreamble(self, *args)


    def SetPreamble(self, p: 'Preamble') -> "void":
        """
        void
        gdcm::FileMetaInformation::SetPreamble(const Preamble &p) 
        """
        return _gdcmswig.FileMetaInformation_SetPreamble(self, p)

    if _newclass:
        SetImplementationClassUID = staticmethod(_gdcmswig.FileMetaInformation_SetImplementationClassUID)
    else:
        SetImplementationClassUID = _gdcmswig.FileMetaInformation_SetImplementationClassUID
    if _newclass:
        AppendImplementationClassUID = staticmethod(_gdcmswig.FileMetaInformation_AppendImplementationClassUID)
    else:
        AppendImplementationClassUID = _gdcmswig.FileMetaInformation_AppendImplementationClassUID
    if _newclass:
        GetImplementationClassUID = staticmethod(_gdcmswig.FileMetaInformation_GetImplementationClassUID)
    else:
        GetImplementationClassUID = _gdcmswig.FileMetaInformation_GetImplementationClassUID
    if _newclass:
        SetImplementationVersionName = staticmethod(_gdcmswig.FileMetaInformation_SetImplementationVersionName)
    else:
        SetImplementationVersionName = _gdcmswig.FileMetaInformation_SetImplementationVersionName
    if _newclass:
        GetImplementationVersionName = staticmethod(_gdcmswig.FileMetaInformation_GetImplementationVersionName)
    else:
        GetImplementationVersionName = _gdcmswig.FileMetaInformation_GetImplementationVersionName
    if _newclass:
        SetSourceApplicationEntityTitle = staticmethod(_gdcmswig.FileMetaInformation_SetSourceApplicationEntityTitle)
    else:
        SetSourceApplicationEntityTitle = _gdcmswig.FileMetaInformation_SetSourceApplicationEntityTitle
    if _newclass:
        GetSourceApplicationEntityTitle = staticmethod(_gdcmswig.FileMetaInformation_GetSourceApplicationEntityTitle)
    else:
        GetSourceApplicationEntityTitle = _gdcmswig.FileMetaInformation_GetSourceApplicationEntityTitle

    def __init__(self, *args):
        """
        gdcm::FileMetaInformation::FileMetaInformation(FileMetaInformation
        const &fmi) 
        """
        this = _gdcmswig.new_FileMetaInformation(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFullLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::FileMetaInformation::GetFullLength() const 
        """
        return _gdcmswig.FileMetaInformation_GetFullLength(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.FileMetaInformation___str__(self)
FileMetaInformation_swigregister = _gdcmswig.FileMetaInformation_swigregister
FileMetaInformation_swigregister(FileMetaInformation)

def FileMetaInformation_SetImplementationClassUID(imp: 'char const *') -> "void":
    return _gdcmswig.FileMetaInformation_SetImplementationClassUID(imp)
FileMetaInformation_SetImplementationClassUID = _gdcmswig.FileMetaInformation_SetImplementationClassUID

def FileMetaInformation_AppendImplementationClassUID(imp: 'char const *') -> "void":
    return _gdcmswig.FileMetaInformation_AppendImplementationClassUID(imp)
FileMetaInformation_AppendImplementationClassUID = _gdcmswig.FileMetaInformation_AppendImplementationClassUID

def FileMetaInformation_GetImplementationClassUID() -> "char const *":
    return _gdcmswig.FileMetaInformation_GetImplementationClassUID()
FileMetaInformation_GetImplementationClassUID = _gdcmswig.FileMetaInformation_GetImplementationClassUID

def FileMetaInformation_SetImplementationVersionName(version: 'char const *') -> "void":
    return _gdcmswig.FileMetaInformation_SetImplementationVersionName(version)
FileMetaInformation_SetImplementationVersionName = _gdcmswig.FileMetaInformation_SetImplementationVersionName

def FileMetaInformation_GetImplementationVersionName() -> "char const *":
    return _gdcmswig.FileMetaInformation_GetImplementationVersionName()
FileMetaInformation_GetImplementationVersionName = _gdcmswig.FileMetaInformation_GetImplementationVersionName

def FileMetaInformation_SetSourceApplicationEntityTitle(title: 'char const *') -> "void":
    return _gdcmswig.FileMetaInformation_SetSourceApplicationEntityTitle(title)
FileMetaInformation_SetSourceApplicationEntityTitle = _gdcmswig.FileMetaInformation_SetSourceApplicationEntityTitle

def FileMetaInformation_GetSourceApplicationEntityTitle() -> "char const *":
    return _gdcmswig.FileMetaInformation_GetSourceApplicationEntityTitle()
FileMetaInformation_GetSourceApplicationEntityTitle = _gdcmswig.FileMetaInformation_GetSourceApplicationEntityTitle

class File(Object):
    """


    a DICOM File

    See PS 3.10 File: A File is an ordered string of zero or more bytes,
    where the first byte is at the beginning of the file and the last byte
    at the end of the File. Files are identified by a unique File ID and
    may by written, read and/or deleted.

    See:   Reader Writer

    C++ includes: gdcmFile.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, File, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, File, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::File::File() """
        this = _gdcmswig.new_File()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_File
    __del__ = lambda self: None

    def Read(self, arg2: 'std::istream &') -> "std::istream &":
        """
        std::istream&
        gdcm::File::Read(std::istream &is)

        Read. 
        """
        return _gdcmswig.File_Read(self, arg2)


    def Write(self, os: 'std::ostream &') -> "std::ostream const &":
        """
        std::ostream const&
        gdcm::File::Write(std::ostream &os) const

        Write. 
        """
        return _gdcmswig.File_Write(self, os)


    def GetHeader(self, *args) -> "gdcm::FileMetaInformation &":
        """
        FileMetaInformation&
        gdcm::File::GetHeader()

        Get File Meta Information. 
        """
        return _gdcmswig.File_GetHeader(self, *args)


    def SetHeader(self, fmi: 'FileMetaInformation') -> "void":
        """
        void
        gdcm::File::SetHeader(const FileMetaInformation &fmi)

        Set File Meta Information. 
        """
        return _gdcmswig.File_SetHeader(self, fmi)


    def GetDataSet(self, *args) -> "gdcm::DataSet &":
        """
        DataSet&
        gdcm::File::GetDataSet()

        Get Data Set. 
        """
        return _gdcmswig.File_GetDataSet(self, *args)


    def SetDataSet(self, ds: 'DataSet') -> "void":
        """
        void
        gdcm::File::SetDataSet(const DataSet &ds)

        Set Data Set. 
        """
        return _gdcmswig.File_SetDataSet(self, ds)


    def __str__(self) -> "char const *":
        return _gdcmswig.File___str__(self)
File_swigregister = _gdcmswig.File_swigregister
File_swigregister(File)

class Bitmap(Object):
    """


    Bitmap class.

    A bitmap based image. Used as parent for both IconImage and the main
    Pixel Data Image It does not contains any World Space information
    (IPP, IOP)

    C++ includes: gdcmBitmap.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Bitmap, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Bitmap, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Bitmap::Bitmap()

        """
        this = _gdcmswig.new_Bitmap()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Bitmap
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::Bitmap::Print(std::ostream &) const 
        """
        return _gdcmswig.Bitmap_Print(self, arg2)


    def AreOverlaysInPixelData(self) -> "bool":
        """
        virtual
        bool gdcm::Bitmap::AreOverlaysInPixelData() const 
        """
        return _gdcmswig.Bitmap_AreOverlaysInPixelData(self)


    def UnusedBitsPresentInPixelData(self) -> "bool":
        return _gdcmswig.Bitmap_UnusedBitsPresentInPixelData(self)

    def GetNumberOfDimensions(self) -> "unsigned int":
        """
        unsigned
        int gdcm::Bitmap::GetNumberOfDimensions() const

        Return the number of dimension of the pixel data bytes; for example 2
        for a 2D matrices of values. 
        """
        return _gdcmswig.Bitmap_GetNumberOfDimensions(self)


    def SetNumberOfDimensions(self, dim: 'unsigned int') -> "void":
        """
        void
        gdcm::Bitmap::SetNumberOfDimensions(unsigned int dim) 
        """
        return _gdcmswig.Bitmap_SetNumberOfDimensions(self, dim)


    def GetPlanarConfiguration(self) -> "unsigned int":
        """
        unsigned
        int gdcm::Bitmap::GetPlanarConfiguration() const

        return the planar configuration 
        """
        return _gdcmswig.Bitmap_GetPlanarConfiguration(self)


    def SetPlanarConfiguration(self, pc: 'unsigned int') -> "void":
        """
        void
        gdcm::Bitmap::SetPlanarConfiguration(unsigned int pc)

        WARNING:  you need to call SetPixelFormat first (before
        SetPlanarConfiguration) for consistency checking 
        """
        return _gdcmswig.Bitmap_SetPlanarConfiguration(self, pc)


    def GetNeedByteSwap(self) -> "bool":
        """
        bool
        gdcm::Bitmap::GetNeedByteSwap() const 
        """
        return _gdcmswig.Bitmap_GetNeedByteSwap(self)


    def SetNeedByteSwap(self, b: 'bool') -> "void":
        """
        void
        gdcm::Bitmap::SetNeedByteSwap(bool b) 
        """
        return _gdcmswig.Bitmap_SetNeedByteSwap(self, b)


    def SetTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::Bitmap::SetTransferSyntax(TransferSyntax const &ts)

        Transfer syntax. 
        """
        return _gdcmswig.Bitmap_SetTransferSyntax(self, ts)


    def GetTransferSyntax(self) -> "gdcm::TransferSyntax const &":
        """
        const
        TransferSyntax& gdcm::Bitmap::GetTransferSyntax() const 
        """
        return _gdcmswig.Bitmap_GetTransferSyntax(self)


    def IsTransferSyntaxCompatible(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::Bitmap::IsTransferSyntaxCompatible(TransferSyntax const &ts)
        const 
        """
        return _gdcmswig.Bitmap_IsTransferSyntaxCompatible(self, ts)


    def SetDataElement(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::Bitmap::SetDataElement(DataElement const &de) 
        """
        return _gdcmswig.Bitmap_SetDataElement(self, de)


    def GetDataElement(self, *args) -> "gdcm::DataElement &":
        """
        DataElement&
        gdcm::Bitmap::GetDataElement() 
        """
        return _gdcmswig.Bitmap_GetDataElement(self, *args)


    def SetLUT(self, lut: 'LookupTable') -> "void":
        """
        void
        gdcm::Bitmap::SetLUT(LookupTable const &lut)

        Set/Get LUT. 
        """
        return _gdcmswig.Bitmap_SetLUT(self, lut)


    def GetLUT(self, *args) -> "gdcm::LookupTable &":
        """
        LookupTable&
        gdcm::Bitmap::GetLUT() 
        """
        return _gdcmswig.Bitmap_GetLUT(self, *args)


    def GetDimensions(self) -> "unsigned int const *":
        """
        const unsigned
        int* gdcm::Bitmap::GetDimensions() const

        Return the dimension of the pixel data, first dimension (x), then 2nd
        (y), then 3rd (z)... 
        """
        return _gdcmswig.Bitmap_GetDimensions(self)


    def GetDimension(self, idx: 'unsigned int') -> "unsigned int":
        """
        unsigned int
        gdcm::Bitmap::GetDimension(unsigned int idx) const 
        """
        return _gdcmswig.Bitmap_GetDimension(self, idx)


    def SetColumns(self, col: 'unsigned int') -> "void":
        """
        void
        gdcm::Bitmap::SetColumns(unsigned int col) 
        """
        return _gdcmswig.Bitmap_SetColumns(self, col)


    def GetColumns(self) -> "unsigned int":
        """
        unsigned int
        gdcm::Bitmap::GetColumns() const 
        """
        return _gdcmswig.Bitmap_GetColumns(self)


    def SetRows(self, rows: 'unsigned int') -> "void":
        """
        void
        gdcm::Bitmap::SetRows(unsigned int rows) 
        """
        return _gdcmswig.Bitmap_SetRows(self, rows)


    def GetRows(self) -> "unsigned int":
        """
        unsigned int
        gdcm::Bitmap::GetRows() const 
        """
        return _gdcmswig.Bitmap_GetRows(self)


    def SetDimensions(self, dims: 'unsigned int const [3]') -> "void":
        """
        void
        gdcm::Bitmap::SetDimensions(const unsigned int dims[3]) 
        """
        return _gdcmswig.Bitmap_SetDimensions(self, dims)


    def SetDimension(self, idx: 'unsigned int', dim: 'unsigned int') -> "void":
        """
        void
        gdcm::Bitmap::SetDimension(unsigned int idx, unsigned int dim) 
        """
        return _gdcmswig.Bitmap_SetDimension(self, idx, dim)


    def GetPixelFormat(self, *args) -> "gdcm::PixelFormat &":
        """
        PixelFormat&
        gdcm::Bitmap::GetPixelFormat() 
        """
        return _gdcmswig.Bitmap_GetPixelFormat(self, *args)


    def SetPixelFormat(self, pf: 'PixelFormat') -> "void":
        """
        void
        gdcm::Bitmap::SetPixelFormat(PixelFormat const &pf) 
        """
        return _gdcmswig.Bitmap_SetPixelFormat(self, pf)


    def GetPhotometricInterpretation(self) -> "gdcm::PhotometricInterpretation const &":
        """
        const PhotometricInterpretation&
        gdcm::Bitmap::GetPhotometricInterpretation() const

        return the photometric interpretation 
        """
        return _gdcmswig.Bitmap_GetPhotometricInterpretation(self)


    def SetPhotometricInterpretation(self, pi: 'PhotometricInterpretation') -> "void":
        """
        void
        gdcm::Bitmap::SetPhotometricInterpretation(PhotometricInterpretation
        const &pi) 
        """
        return _gdcmswig.Bitmap_SetPhotometricInterpretation(self, pi)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Bitmap::IsEmpty() const 
        """
        return _gdcmswig.Bitmap_IsEmpty(self)


    def Clear(self) -> "void":
        """
        void
        gdcm::Bitmap::Clear() 
        """
        return _gdcmswig.Bitmap_Clear(self)


    def GetBufferLength(self) -> "unsigned long":
        """
        unsigned long
        gdcm::Bitmap::GetBufferLength() const

        Return the length of the image after decompression WARNING for palette
        color: It will NOT take into account the Palette Color thus you need
        to multiply this length by 3 if computing the size of equivalent RGB
        image 
        """
        return _gdcmswig.Bitmap_GetBufferLength(self)


    def IsLossy(self) -> "bool":
        """
        bool
        gdcm::Bitmap::IsLossy() const

        Return whether or not the image was compressed using a lossy
        compressor or not. 
        """
        return _gdcmswig.Bitmap_IsLossy(self)


    def SetLossyFlag(self, f: 'bool') -> "void":
        """
        void
        gdcm::Bitmap::SetLossyFlag(bool f)

        Specifically set that the image was compressed using a lossy
        compression mechanism. 
        """
        return _gdcmswig.Bitmap_SetLossyFlag(self, f)


    def __str__(self) -> "char const *":
        return _gdcmswig.Bitmap___str__(self)

    def GetBuffer(self) -> "void":
        """
        bool
        gdcm::Bitmap::GetBuffer(char *buffer) const

        Acces the raw data. 
        """
        return _gdcmswig.Bitmap_GetBuffer(self)

Bitmap_swigregister = _gdcmswig.Bitmap_swigregister
Bitmap_swigregister(Bitmap)

class Pixmap(Bitmap):
    """


    Pixmap class.

    A bitmap based image. Used as parent for both IconImage and the main
    Pixel Data Image It does not contains any World Space information
    (IPP, IOP)

    See:   PixmapReader

    C++ includes: gdcmPixmap.h 
    """

    __swig_setmethods__ = {}
    for _s in [Bitmap]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pixmap, name, value)
    __swig_getmethods__ = {}
    for _s in [Bitmap]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Pixmap, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Pixmap::Pixmap()

        """
        this = _gdcmswig.new_Pixmap()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Pixmap
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::Pixmap::Print(std::ostream &) const 
        """
        return _gdcmswig.Pixmap_Print(self, arg2)


    def AreOverlaysInPixelData(self) -> "bool":
        """
        bool
        gdcm::Pixmap::AreOverlaysInPixelData() const

        returns if Overlays are stored in the unused bit of the pixel data: 
        """
        return _gdcmswig.Pixmap_AreOverlaysInPixelData(self)


    def UnusedBitsPresentInPixelData(self) -> "bool":
        return _gdcmswig.Pixmap_UnusedBitsPresentInPixelData(self)

    def GetCurve(self, *args) -> "Curve const &":
        """
        const Curve&
        gdcm::Pixmap::GetCurve(size_t i=0) const 
        """
        return _gdcmswig.Pixmap_GetCurve(self, *args)


    def GetNumberOfCurves(self) -> "size_t":
        """
        size_t
        gdcm::Pixmap::GetNumberOfCurves() const 
        """
        return _gdcmswig.Pixmap_GetNumberOfCurves(self)


    def SetNumberOfCurves(self, n: 'size_t') -> "void":
        """
        void
        gdcm::Pixmap::SetNumberOfCurves(size_t n) 
        """
        return _gdcmswig.Pixmap_SetNumberOfCurves(self, n)


    def GetOverlay(self, *args) -> "gdcm::Overlay const &":
        """
        const Overlay&
        gdcm::Pixmap::GetOverlay(size_t i=0) const 
        """
        return _gdcmswig.Pixmap_GetOverlay(self, *args)


    def GetNumberOfOverlays(self) -> "size_t":
        """
        size_t
        gdcm::Pixmap::GetNumberOfOverlays() const 
        """
        return _gdcmswig.Pixmap_GetNumberOfOverlays(self)


    def SetNumberOfOverlays(self, n: 'size_t') -> "void":
        """
        void
        gdcm::Pixmap::SetNumberOfOverlays(size_t n) 
        """
        return _gdcmswig.Pixmap_SetNumberOfOverlays(self, n)


    def RemoveOverlay(self, i: 'size_t') -> "void":
        """
        void
        gdcm::Pixmap::RemoveOverlay(size_t i) 
        """
        return _gdcmswig.Pixmap_RemoveOverlay(self, i)


    def GetIconImage(self, *args) -> "gdcm::IconImage &":
        """
        IconImage&
        gdcm::Pixmap::GetIconImage() 
        """
        return _gdcmswig.Pixmap_GetIconImage(self, *args)


    def SetIconImage(self, ii: 'Bitmap') -> "void":
        """
        void
        gdcm::Pixmap::SetIconImage(IconImage const &ii) 
        """
        return _gdcmswig.Pixmap_SetIconImage(self, ii)


    def __str__(self) -> "char const *":
        return _gdcmswig.Pixmap___str__(self)
Pixmap_swigregister = _gdcmswig.Pixmap_swigregister
Pixmap_swigregister(Pixmap)

class Image(Pixmap):
    """


    Image.

    This is the container for an Image in the general sense. From this
    container you should be able to request information like: Origin

    Dimension

    PixelFormat ... But also to retrieve the image as a raw buffer (char
    *) Since we have to deal with both RAW data and JPEG stream (which
    internally encode all the above information) this API might seems
    redundant. One way to solve that would be to subclass Image with
    JPEGImage which would from the stream extract the header info and fill
    it to please Image...well except origin for instance

    Basically you can see it as a storage for the Pixel Data element
    (7fe0,0010).

    WARNING:  This class does some heuristics to guess the Spacing but is
    not compatible with DICOM CP-586. In case of doubt use PixmapReader
    instead

    See:   ImageReader PixmapReader

    C++ includes: gdcmImage.h 
    """

    __swig_setmethods__ = {}
    for _s in [Pixmap]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Image, name, value)
    __swig_getmethods__ = {}
    for _s in [Pixmap]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Image, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Image::Image() """
        this = _gdcmswig.new_Image()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Image
    __del__ = lambda self: None

    def GetSpacing(self, *args) -> "double":
        """
        double
        gdcm::Image::GetSpacing(unsigned int idx) const 
        """
        return _gdcmswig.Image_GetSpacing(self, *args)


    def SetSpacing(self, *args) -> "void":
        """
        void
        gdcm::Image::SetSpacing(unsigned int idx, double spacing) 
        """
        return _gdcmswig.Image_SetSpacing(self, *args)


    def GetOrigin(self, *args) -> "double":
        """
        double
        gdcm::Image::GetOrigin(unsigned int idx) const 
        """
        return _gdcmswig.Image_GetOrigin(self, *args)


    def SetOrigin(self, *args) -> "void":
        """
        void
        gdcm::Image::SetOrigin(unsigned int idx, double ori) 
        """
        return _gdcmswig.Image_SetOrigin(self, *args)


    def GetDirectionCosines(self, *args) -> "double":
        """
        double
        gdcm::Image::GetDirectionCosines(unsigned int idx) const 
        """
        return _gdcmswig.Image_GetDirectionCosines(self, *args)


    def SetDirectionCosines(self, *args) -> "void":
        """
        void
        gdcm::Image::SetDirectionCosines(unsigned int idx, double dircos) 
        """
        return _gdcmswig.Image_SetDirectionCosines(self, *args)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Image::Print(std::ostream &os) const

        print 
        """
        return _gdcmswig.Image_Print(self, os)


    def SetIntercept(self, intercept: 'double') -> "void":
        """
        void
        gdcm::Image::SetIntercept(double intercept)

        intercept 
        """
        return _gdcmswig.Image_SetIntercept(self, intercept)


    def GetIntercept(self) -> "double":
        """
        double
        gdcm::Image::GetIntercept() const 
        """
        return _gdcmswig.Image_GetIntercept(self)


    def SetSlope(self, slope: 'double') -> "void":
        """
        void
        gdcm::Image::SetSlope(double slope)

        slope 
        """
        return _gdcmswig.Image_SetSlope(self, slope)


    def GetSlope(self) -> "double":
        """
        double
        gdcm::Image::GetSlope() const 
        """
        return _gdcmswig.Image_GetSlope(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.Image___str__(self)
Image_swigregister = _gdcmswig.Image_swigregister
Image_swigregister(Image)

class Fragment(DataElement):
    """


    Class to represent a Fragment.

    C++ includes: gdcmFragment.h 
    """

    __swig_setmethods__ = {}
    for _s in [DataElement]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Fragment, name, value)
    __swig_getmethods__ = {}
    for _s in [DataElement]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Fragment, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Fragment::Fragment() """
        this = _gdcmswig.new_Fragment()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::Fragment::GetLength() const 
        """
        return _gdcmswig.Fragment_GetLength(self)


    def ComputeLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::Fragment::ComputeLength() const 
        """
        return _gdcmswig.Fragment_ComputeLength(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.Fragment___str__(self)
    __swig_destroy__ = _gdcmswig.delete_Fragment
    __del__ = lambda self: None
Fragment_swigregister = _gdcmswig.Fragment_swigregister
Fragment_swigregister(Fragment)

class fragmentVector(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, fragmentVector, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, fragmentVector, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.fragmentVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.fragmentVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.fragmentVector___bool__(self)

    def __len__(self) -> "std::vector< gdcm::Fragment >::size_type":
        return _gdcmswig.fragmentVector___len__(self)

    def __getslice__(self, i: 'std::vector< gdcm::Fragment >::difference_type', j: 'std::vector< gdcm::Fragment >::difference_type') -> "std::vector< gdcm::Fragment,std::allocator< gdcm::Fragment > > *":
        return _gdcmswig.fragmentVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.fragmentVector___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< gdcm::Fragment >::difference_type', j: 'std::vector< gdcm::Fragment >::difference_type') -> "void":
        return _gdcmswig.fragmentVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.fragmentVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gdcm::Fragment >::value_type const &":
        return _gdcmswig.fragmentVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.fragmentVector___setitem__(self, *args)

    def pop(self) -> "std::vector< gdcm::Fragment >::value_type":
        return _gdcmswig.fragmentVector_pop(self)

    def append(self, x: 'Fragment') -> "void":
        return _gdcmswig.fragmentVector_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.fragmentVector_empty(self)

    def size(self) -> "std::vector< gdcm::Fragment >::size_type":
        return _gdcmswig.fragmentVector_size(self)

    def swap(self, v: 'fragmentVector') -> "void":
        return _gdcmswig.fragmentVector_swap(self, v)

    def begin(self) -> "std::vector< gdcm::Fragment >::iterator":
        return _gdcmswig.fragmentVector_begin(self)

    def end(self) -> "std::vector< gdcm::Fragment >::iterator":
        return _gdcmswig.fragmentVector_end(self)

    def rbegin(self) -> "std::vector< gdcm::Fragment >::reverse_iterator":
        return _gdcmswig.fragmentVector_rbegin(self)

    def rend(self) -> "std::vector< gdcm::Fragment >::reverse_iterator":
        return _gdcmswig.fragmentVector_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.fragmentVector_clear(self)

    def get_allocator(self) -> "std::vector< gdcm::Fragment >::allocator_type":
        return _gdcmswig.fragmentVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.fragmentVector_pop_back(self)

    def erase(self, *args) -> "std::vector< gdcm::Fragment >::iterator":
        return _gdcmswig.fragmentVector_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_fragmentVector(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'Fragment') -> "void":
        return _gdcmswig.fragmentVector_push_back(self, x)

    def front(self) -> "std::vector< gdcm::Fragment >::value_type const &":
        return _gdcmswig.fragmentVector_front(self)

    def back(self) -> "std::vector< gdcm::Fragment >::value_type const &":
        return _gdcmswig.fragmentVector_back(self)

    def assign(self, n: 'std::vector< gdcm::Fragment >::size_type', x: 'Fragment') -> "void":
        return _gdcmswig.fragmentVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.fragmentVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.fragmentVector_insert(self, *args)

    def reserve(self, n: 'std::vector< gdcm::Fragment >::size_type') -> "void":
        return _gdcmswig.fragmentVector_reserve(self, n)

    def capacity(self) -> "std::vector< gdcm::Fragment >::size_type":
        return _gdcmswig.fragmentVector_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_fragmentVector
    __del__ = lambda self: None
fragmentVector_swigregister = _gdcmswig.fragmentVector_swigregister
fragmentVector_swigregister(fragmentVector)

class PDBElement(_object):
    """


    Class to represent a PDB Element.

    See:   PDBHeader

    C++ includes: gdcmPDBElement.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PDBElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PDBElement, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PDBElement::PDBElement() """
        this = _gdcmswig.new_PDBElement()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::PDBElement::GetName() const

        Set/Get Name. 
        """
        return _gdcmswig.PDBElement_GetName(self)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::PDBElement::SetName(const char *name) 
        """
        return _gdcmswig.PDBElement_SetName(self, name)


    def GetValue(self) -> "char const *":
        """
        const char*
        gdcm::PDBElement::GetValue() const

        Set/Get Value. 
        """
        return _gdcmswig.PDBElement_GetValue(self)


    def SetValue(self, value: 'char const *') -> "void":
        """
        void
        gdcm::PDBElement::SetValue(const char *value) 
        """
        return _gdcmswig.PDBElement_SetValue(self, value)


    def __eq__(self, de: 'PDBElement') -> "bool":
        return _gdcmswig.PDBElement___eq__(self, de)

    def __str__(self) -> "char const *":
        return _gdcmswig.PDBElement___str__(self)
    __swig_destroy__ = _gdcmswig.delete_PDBElement
    __del__ = lambda self: None
PDBElement_swigregister = _gdcmswig.PDBElement_swigregister
PDBElement_swigregister(PDBElement)

class PDBHeader(_object):
    """


    Class for PDBHeader.

    GEMS MR Image have an Attribute (0025,1b,GEMS_SERS_01) which store the
    Acquisition parameter of the MR Image. It is compressed and can
    therefore not be used as is. This class de- encapsulated the Protocol
    Data Block and allow users to query element by name.

    WARNING:  Everything you do with this code is at your own risk, since
    decoding process was not written from specification documents.

    WARNING:  : the API of this class might change.

    See:   CSAHeader

    C++ includes: gdcmPDBHeader.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PDBHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PDBHeader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PDBHeader::PDBHeader() """
        this = _gdcmswig.new_PDBHeader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PDBHeader
    __del__ = lambda self: None

    def LoadFromDataElement(self, de: 'DataElement') -> "bool":
        """
        bool
        gdcm::PDBHeader::LoadFromDataElement(DataElement const &de)

        Load the PDB Header from a DataElement of a DataSet. 
        """
        return _gdcmswig.PDBHeader_LoadFromDataElement(self, de)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::PDBHeader::Print(std::ostream &os) const

        Print. 
        """
        return _gdcmswig.PDBHeader_Print(self, os)

    if _newclass:
        GetPDBInfoTag = staticmethod(_gdcmswig.PDBHeader_GetPDBInfoTag)
    else:
        GetPDBInfoTag = _gdcmswig.PDBHeader_GetPDBInfoTag

    def GetPDBElementByName(self, name: 'char const *') -> "gdcm::PDBElement const &":
        """
        const
        PDBElement& gdcm::PDBHeader::GetPDBElementByName(const char *name)

        Lookup in the PDB header if a PDB element match the name 'name':
        WARNING:  Case Sensitive 
        """
        return _gdcmswig.PDBHeader_GetPDBElementByName(self, name)


    def FindPDBElementByName(self, name: 'char const *') -> "bool":
        """
        bool
        gdcm::PDBHeader::FindPDBElementByName(const char *name)

        Return true if the PDB element matching name is found or not. 
        """
        return _gdcmswig.PDBHeader_FindPDBElementByName(self, name)


    def __str__(self) -> "char const *":
        return _gdcmswig.PDBHeader___str__(self)
PDBHeader_swigregister = _gdcmswig.PDBHeader_swigregister
PDBHeader_swigregister(PDBHeader)

def PDBHeader_GetPDBInfoTag() -> "gdcm::PrivateTag const &":
    return _gdcmswig.PDBHeader_GetPDBInfoTag()
PDBHeader_GetPDBInfoTag = _gdcmswig.PDBHeader_GetPDBInfoTag

class MrProtocol(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MrProtocol, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MrProtocol, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _gdcmswig.new_MrProtocol()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_MrProtocol
    __del__ = lambda self: None

    def Load(self, bv: 'ByteValue', str: 'char const *', version: 'int') -> "bool":
        return _gdcmswig.MrProtocol_Load(self, bv, str, version)

    def Print(self, os: 'std::ostream &') -> "void":
        return _gdcmswig.MrProtocol_Print(self, os)

    def GetVersion(self) -> "int":
        return _gdcmswig.MrProtocol_GetVersion(self)

    def GetMrProtocolByName(self, name: 'char const *') -> "char const *":
        return _gdcmswig.MrProtocol_GetMrProtocolByName(self, name)

    def FindMrProtocolByName(self, name: 'char const *') -> "bool":
        return _gdcmswig.MrProtocol_FindMrProtocolByName(self, name)

    def GetSliceArray(self, sa: 'gdcm::MrProtocol::SliceArray &') -> "bool":
        return _gdcmswig.MrProtocol_GetSliceArray(self, sa)

    def __str__(self) -> "char const *":
        return _gdcmswig.MrProtocol___str__(self)
MrProtocol_swigregister = _gdcmswig.MrProtocol_swigregister
MrProtocol_swigregister(MrProtocol)

class CSAElement(_object):
    """


    Class to represent a CSA Element.

    See:   CSAHeader

    C++ includes: gdcmCSAElement.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSAElement, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSAElement, name)
    __repr__ = _swig_repr

    def GetKey(self) -> "unsigned int":
        """
        unsigned int
        gdcm::CSAElement::GetKey() const

        Set/Get Key. 
        """
        return _gdcmswig.CSAElement_GetKey(self)


    def SetKey(self, key: 'unsigned int') -> "void":
        """
        void
        gdcm::CSAElement::SetKey(unsigned int key) 
        """
        return _gdcmswig.CSAElement_SetKey(self, key)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::CSAElement::GetName() const

        Set/Get Name. 
        """
        return _gdcmswig.CSAElement_GetName(self)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::CSAElement::SetName(const char *name) 
        """
        return _gdcmswig.CSAElement_SetName(self, name)


    def GetVM(self) -> "gdcm::VM const &":
        """
        const VM&
        gdcm::CSAElement::GetVM() const

        Set/Get VM. 
        """
        return _gdcmswig.CSAElement_GetVM(self)


    def SetVM(self, vm: 'VM') -> "void":
        """
        void
        gdcm::CSAElement::SetVM(const VM &vm) 
        """
        return _gdcmswig.CSAElement_SetVM(self, vm)


    def GetVR(self) -> "gdcm::VR const &":
        """
        VR const&
        gdcm::CSAElement::GetVR() const

        Set/Get VR. 
        """
        return _gdcmswig.CSAElement_GetVR(self)


    def SetVR(self, vr: 'VR') -> "void":
        """
        void
        gdcm::CSAElement::SetVR(VR const &vr) 
        """
        return _gdcmswig.CSAElement_SetVR(self, vr)


    def GetSyngoDT(self) -> "unsigned int":
        """
        unsigned int
        gdcm::CSAElement::GetSyngoDT() const

        Set/Get SyngoDT. 
        """
        return _gdcmswig.CSAElement_GetSyngoDT(self)


    def SetSyngoDT(self, syngodt: 'unsigned int') -> "void":
        """
        void
        gdcm::CSAElement::SetSyngoDT(unsigned int syngodt) 
        """
        return _gdcmswig.CSAElement_SetSyngoDT(self, syngodt)


    def GetNoOfItems(self) -> "unsigned int":
        """
        unsigned int
        gdcm::CSAElement::GetNoOfItems() const

        Set/Get NoOfItems. 
        """
        return _gdcmswig.CSAElement_GetNoOfItems(self)


    def SetNoOfItems(self, items: 'unsigned int') -> "void":
        """
        void
        gdcm::CSAElement::SetNoOfItems(unsigned int items) 
        """
        return _gdcmswig.CSAElement_SetNoOfItems(self, items)


    def GetValue(self, *args) -> "gdcm::Value &":
        """
        Value&
        gdcm::CSAElement::GetValue() 
        """
        return _gdcmswig.CSAElement_GetValue(self, *args)


    def SetValue(self, vl: 'Value') -> "void":
        """
        void
        gdcm::CSAElement::SetValue(Value const &vl) 
        """
        return _gdcmswig.CSAElement_SetValue(self, vl)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::CSAElement::IsEmpty() const

        Check if CSA Element is empty. 
        """
        return _gdcmswig.CSAElement_IsEmpty(self)


    def SetByteValue(self, array: 'char const *', length: 'VL') -> "void":
        """
        void
        gdcm::CSAElement::SetByteValue(const char *array, VL length)

        Set. 
        """
        return _gdcmswig.CSAElement_SetByteValue(self, array, length)


    def GetByteValue(self) -> "gdcm::ByteValue const *":
        """
        const
        ByteValue* gdcm::CSAElement::GetByteValue() const

        Return the Value of CSAElement as a ByteValue (if possible) WARNING:
        : You need to check for NULL return value 
        """
        return _gdcmswig.CSAElement_GetByteValue(self)


    def __init__(self, *args):
        """gdcm::CSAElement::CSAElement(const CSAElement &_val) """
        this = _gdcmswig.new_CSAElement(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __lt__(self, de: 'CSAElement') -> "bool":
        return _gdcmswig.CSAElement___lt__(self, de)

    def __eq__(self, de: 'CSAElement') -> "bool":
        return _gdcmswig.CSAElement___eq__(self, de)

    def __str__(self) -> "char const *":
        return _gdcmswig.CSAElement___str__(self)

    def SetByteStringValue(self, array: 'char const *') -> "void":
        return _gdcmswig.CSAElement_SetByteStringValue(self, array)
    __swig_destroy__ = _gdcmswig.delete_CSAElement
    __del__ = lambda self: None
CSAElement_swigregister = _gdcmswig.CSAElement_swigregister
CSAElement_swigregister(CSAElement)

class CSAHeader(_object):
    """


    Class for CSAHeader.

    SIEMENS store private information in tag (0x0029,0x10,"SIEMENS CSA
    HEADER") this class is meant for user wishing to access values stored
    within this private attribute. There are basically two main 'format'
    for this attribute : SV10/NOMAGIC and DATASET_FORMAT SV10 and NOMAGIC
    are from a user prospective identical, see CSAHeader.xml for possible
    name / value stored in this format. DATASET_FORMAT is in fact simply
    just another DICOM dataset (implicit) with -currently unknown- value.
    This can be only be printed for now.

    WARNING:  Everything you do with this code is at your own risk, since
    decoding process was not written from specification documents.

    WARNING:  the API of this class might change. Todo MrEvaProtocol in
    29,1020 contains ^M that would be nice to get rid of on UNIX system...

    See:   PDBHeader  External references: 5.1.3.2.4.1 MEDCOM History
    Information and 5.1.4.3 CSA Non-Image Module
    inhttp://tamsinfo.toshiba.com/docrequest/pdf/E.Soft_v2.0.pdf

    C++ includes: gdcmCSAHeader.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSAHeader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSAHeader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::CSAHeader::CSAHeader() """
        this = _gdcmswig.new_CSAHeader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_CSAHeader
    __del__ = lambda self: None
    UNKNOWN = _gdcmswig.CSAHeader_UNKNOWN
    SV10 = _gdcmswig.CSAHeader_SV10
    NOMAGIC = _gdcmswig.CSAHeader_NOMAGIC
    DATASET_FORMAT = _gdcmswig.CSAHeader_DATASET_FORMAT
    INTERFILE = _gdcmswig.CSAHeader_INTERFILE
    ZEROED_OUT = _gdcmswig.CSAHeader_ZEROED_OUT

    def LoadFromDataElement(self, de: 'DataElement') -> "bool":
        """
        bool
        gdcm::CSAHeader::LoadFromDataElement(DataElement const &de)

        Decode the CSAHeader from element 'de'. 
        """
        return _gdcmswig.CSAHeader_LoadFromDataElement(self, de)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::CSAHeader::Print(std::ostream &os) const

        Print the CSAHeader (use only if Format == SV10 or NOMAGIC) 
        """
        return _gdcmswig.CSAHeader_Print(self, os)


    def GetDataSet(self) -> "gdcm::DataSet const &":
        """
        const DataSet&
        gdcm::CSAHeader::GetDataSet() const

        Return the DataSet output (use only if Format == DATASET_FORMAT ) 
        """
        return _gdcmswig.CSAHeader_GetDataSet(self)


    def GetInterfile(self) -> "char const *":
        """
        const char*
        gdcm::CSAHeader::GetInterfile() const

        Return the string output (use only if Format == Interfile) 
        """
        return _gdcmswig.CSAHeader_GetInterfile(self)


    def GetFormat(self) -> "gdcm::CSAHeader::CSAHeaderType":
        """
        CSAHeaderType
        gdcm::CSAHeader::GetFormat() const

        return the format of the CSAHeader SV10 and NOMAGIC are equivalent. 
        """
        return _gdcmswig.CSAHeader_GetFormat(self)

    if _newclass:
        GetCSAImageHeaderInfoTag = staticmethod(_gdcmswig.CSAHeader_GetCSAImageHeaderInfoTag)
    else:
        GetCSAImageHeaderInfoTag = _gdcmswig.CSAHeader_GetCSAImageHeaderInfoTag
    if _newclass:
        GetCSASeriesHeaderInfoTag = staticmethod(_gdcmswig.CSAHeader_GetCSASeriesHeaderInfoTag)
    else:
        GetCSASeriesHeaderInfoTag = _gdcmswig.CSAHeader_GetCSASeriesHeaderInfoTag
    if _newclass:
        GetCSADataInfo = staticmethod(_gdcmswig.CSAHeader_GetCSADataInfo)
    else:
        GetCSADataInfo = _gdcmswig.CSAHeader_GetCSADataInfo

    def GetCSAElementByName(self, name: 'char const *') -> "gdcm::CSAElement const &":
        """
        const
        CSAElement& gdcm::CSAHeader::GetCSAElementByName(const char *name)

        Return the CSAElement corresponding to name 'name' WARNING:  Case
        Sensitive 
        """
        return _gdcmswig.CSAHeader_GetCSAElementByName(self, name)


    def FindCSAElementByName(self, name: 'char const *') -> "bool":
        """
        bool
        gdcm::CSAHeader::FindCSAElementByName(const char *name)

        Return true if the CSA element matching 'name' is found or not
        WARNING:  Case Sensitive 
        """
        return _gdcmswig.CSAHeader_FindCSAElementByName(self, name)


    def GetMrProtocol(self, ds: 'DataSet', mrProtocol: 'MrProtocol') -> "bool":
        return _gdcmswig.CSAHeader_GetMrProtocol(self, ds, mrProtocol)

    def __str__(self) -> "char const *":
        return _gdcmswig.CSAHeader___str__(self)
CSAHeader_swigregister = _gdcmswig.CSAHeader_swigregister
CSAHeader_swigregister(CSAHeader)

def CSAHeader_GetCSAImageHeaderInfoTag() -> "gdcm::PrivateTag const &":
    return _gdcmswig.CSAHeader_GetCSAImageHeaderInfoTag()
CSAHeader_GetCSAImageHeaderInfoTag = _gdcmswig.CSAHeader_GetCSAImageHeaderInfoTag

def CSAHeader_GetCSASeriesHeaderInfoTag() -> "gdcm::PrivateTag const &":
    return _gdcmswig.CSAHeader_GetCSASeriesHeaderInfoTag()
CSAHeader_GetCSASeriesHeaderInfoTag = _gdcmswig.CSAHeader_GetCSASeriesHeaderInfoTag

def CSAHeader_GetCSADataInfo() -> "gdcm::PrivateTag const &":
    return _gdcmswig.CSAHeader_GetCSADataInfo()
CSAHeader_GetCSADataInfo = _gdcmswig.CSAHeader_GetCSADataInfo

class SequenceOfFragments(Value):
    """


    Class to represent a Sequence Of Fragments.

    Todo I do not enforce that Sequence of Fragments ends with a SQ end
    del

    C++ includes: gdcmSequenceOfFragments.h 
    """

    __swig_setmethods__ = {}
    for _s in [Value]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SequenceOfFragments, name, value)
    __swig_getmethods__ = {}
    for _s in [Value]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SequenceOfFragments, name)
    __repr__ = _swig_repr

    def Begin(self, *args) -> "gdcm::SequenceOfFragments::ConstIterator":
        """ConstIterator gdcm::SequenceOfFragments::Begin() const """
        return _gdcmswig.SequenceOfFragments_Begin(self, *args)


    def End(self, *args) -> "gdcm::SequenceOfFragments::ConstIterator":
        """
        ConstIterator
        gdcm::SequenceOfFragments::End() const 
        """
        return _gdcmswig.SequenceOfFragments_End(self, *args)


    def __init__(self):
        """
        gdcm::SequenceOfFragments::SequenceOfFragments()

        constructor (UndefinedLength by default) 
        """
        this = _gdcmswig.new_SequenceOfFragments()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfFragments::GetLength() const

        Returns the SQ length, as read from disk. 
        """
        return _gdcmswig.SequenceOfFragments_GetLength(self)


    def SetLength(self, length: 'VL') -> "void":
        """
        void
        gdcm::SequenceOfFragments::SetLength(VL length)

        Sets the actual SQ length. 
        """
        return _gdcmswig.SequenceOfFragments_SetLength(self, length)


    def Clear(self) -> "void":
        """
        void
        gdcm::SequenceOfFragments::Clear()

        Clear. 
        """
        return _gdcmswig.SequenceOfFragments_Clear(self)


    def AddFragment(self, item: 'Fragment') -> "void":
        """
        void
        gdcm::SequenceOfFragments::AddFragment(Fragment const &item)

        Appends a Fragment to the already added ones. 
        """
        return _gdcmswig.SequenceOfFragments_AddFragment(self, item)


    def ComputeByteLength(self) -> "unsigned long":
        """unsigned long gdcm::SequenceOfFragments::ComputeByteLength() const """
        return _gdcmswig.SequenceOfFragments_ComputeByteLength(self)


    def ComputeLength(self) -> "gdcm::VL":
        """
        VL
        gdcm::SequenceOfFragments::ComputeLength() const 
        """
        return _gdcmswig.SequenceOfFragments_ComputeLength(self)


    def GetBuffer(self, buffer: 'char *', length: 'unsigned long') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::GetBuffer(char *buffer, unsigned long
        length) const 
        """
        return _gdcmswig.SequenceOfFragments_GetBuffer(self, buffer, length)


    def GetFragBuffer(self, fragNb: 'unsigned int', buffer: 'char *', length: 'unsigned long &') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::GetFragBuffer(unsigned int fragNb, char
        *buffer, unsigned long &length) const 
        """
        return _gdcmswig.SequenceOfFragments_GetFragBuffer(self, fragNb, buffer, length)


    def GetNumberOfFragments(self) -> "gdcm::SequenceOfFragments::SizeType":
        """SizeType gdcm::SequenceOfFragments::GetNumberOfFragments() const """
        return _gdcmswig.SequenceOfFragments_GetNumberOfFragments(self)


    def GetFragment(self, num: 'gdcm::SequenceOfFragments::SizeType') -> "gdcm::Fragment const &":
        """
        const
        Fragment& gdcm::SequenceOfFragments::GetFragment(SizeType num) const

        """
        return _gdcmswig.SequenceOfFragments_GetFragment(self, num)


    def WriteBuffer(self, os: 'std::ostream &') -> "bool":
        """
        bool
        gdcm::SequenceOfFragments::WriteBuffer(std::ostream &os) const 
        """
        return _gdcmswig.SequenceOfFragments_WriteBuffer(self, os)


    def GetTable(self, *args) -> "BasicOffsetTable &":
        """BasicOffsetTable& gdcm::SequenceOfFragments::GetTable() """
        return _gdcmswig.SequenceOfFragments_GetTable(self, *args)

    if _newclass:
        New = staticmethod(_gdcmswig.SequenceOfFragments_New)
    else:
        New = _gdcmswig.SequenceOfFragments_New

    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::SequenceOfFragments::Print(std::ostream &os) const 
        """
        return _gdcmswig.SequenceOfFragments_Print(self, os)


    def __eq__(self, val: 'Value') -> "bool":
        return _gdcmswig.SequenceOfFragments___eq__(self, val)

    def __str__(self) -> "char const *":
        return _gdcmswig.SequenceOfFragments___str__(self)
    __swig_destroy__ = _gdcmswig.delete_SequenceOfFragments
    __del__ = lambda self: None
SequenceOfFragments_swigregister = _gdcmswig.SequenceOfFragments_swigregister
SequenceOfFragments_swigregister(SequenceOfFragments)

def SequenceOfFragments_New() -> "gdcm::SmartPointer< gdcm::SequenceOfFragments >":
    return _gdcmswig.SequenceOfFragments_New()
SequenceOfFragments_New = _gdcmswig.SequenceOfFragments_New

class BasicOffsetTable(Fragment):
    """


    Class to represent a BasicOffsetTable.

    C++ includes: gdcmBasicOffsetTable.h 
    """

    __swig_setmethods__ = {}
    for _s in [Fragment]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BasicOffsetTable, name, value)
    __swig_getmethods__ = {}
    for _s in [Fragment]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BasicOffsetTable, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::BasicOffsetTable::BasicOffsetTable() """
        this = _gdcmswig.new_BasicOffsetTable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self) -> "char const *":
        return _gdcmswig.BasicOffsetTable___str__(self)
    __swig_destroy__ = _gdcmswig.delete_BasicOffsetTable
    __del__ = lambda self: None
BasicOffsetTable_swigregister = _gdcmswig.BasicOffsetTable_swigregister
BasicOffsetTable_swigregister(BasicOffsetTable)

class FileSet(_object):
    """


    File-set: A File-set is a collection of DICOM Files (and possibly non-
    DICOM Files) that share a common naming space within which File IDs
    are unique.

    C++ includes: gdcmFileSet.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileSet, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileSet, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileSet::FileSet() """
        this = _gdcmswig.new_FileSet()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def AddFile(self, *args) -> "bool":
        """
        bool
        gdcm::FileSet::AddFile(const char *filename)

        Add a file 'filename' to the list of files. Return true on success,
        false in case filename could not be found on system. 
        """
        return _gdcmswig.FileSet_AddFile(self, *args)


    def SetFiles(self, files: 'FilenamesType') -> "void":
        """
        void
        gdcm::FileSet::SetFiles(FilesType const &files) 
        """
        return _gdcmswig.FileSet_SetFiles(self, files)


    def GetFiles(self) -> "gdcm::FileSet::FilesType const &":
        """
        FilesType const&
        gdcm::FileSet::GetFiles() const 
        """
        return _gdcmswig.FileSet_GetFiles(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.FileSet___str__(self)
    __swig_destroy__ = _gdcmswig.delete_FileSet
    __del__ = lambda self: None
FileSet_swigregister = _gdcmswig.FileSet_swigregister
FileSet_swigregister(FileSet)

class Global(_object):
    """


    Global.

    Global should be included in any translation unit that will use Dict
    or that implements the singleton pattern. It makes sure that the Dict
    singleton is created before and destroyed after all other singletons
    in GDCM.

    C++ includes: gdcmGlobal.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Global, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Global, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Global::Global()

        """
        this = _gdcmswig.new_Global()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Global
    __del__ = lambda self: None

    def GetDicts(self, *args) -> "gdcm::Dicts &":
        """
        Dicts&
        gdcm::Global::GetDicts() 
        """
        return _gdcmswig.Global_GetDicts(self, *args)


    def GetDefs(self) -> "gdcm::Defs const &":
        """
        Defs const&
        gdcm::Global::GetDefs() const

        retrieve the default/internal (Part 3) You need to explicitly call
        LoadResourcesFiles before 
        """
        return _gdcmswig.Global_GetDefs(self)

    if _newclass:
        GetInstance = staticmethod(_gdcmswig.Global_GetInstance)
    else:
        GetInstance = _gdcmswig.Global_GetInstance

    def LoadResourcesFiles(self) -> "bool":
        """
        bool
        gdcm::Global::LoadResourcesFiles()

        Load all internal XML files, resource path need to have been set
        before calling this member function (see Append/Prepend members func)
        WARNING:  not thread safe ! 
        """
        return _gdcmswig.Global_LoadResourcesFiles(self)


    def Append(self, path: 'char const *') -> "bool":
        """
        bool
        gdcm::Global::Append(const char *path)

        Append path at the end of the path list WARNING:  not thread safe ! 
        """
        return _gdcmswig.Global_Append(self, path)


    def Prepend(self, path: 'char const *') -> "bool":
        """
        bool
        gdcm::Global::Prepend(const char *path)

        Prepend path at the beginning of the path list WARNING:  not thread
        safe ! 
        """
        return _gdcmswig.Global_Prepend(self, path)


    def __str__(self) -> "char const *":
        return _gdcmswig.Global___str__(self)
Global_swigregister = _gdcmswig.Global_swigregister
Global_swigregister(Global)

def Global_GetInstance() -> "gdcm::Global &":
    return _gdcmswig.Global_GetInstance()
Global_GetInstance = _gdcmswig.Global_GetInstance

class DictEntry(_object):
    """


    Class to represent an Entry in the Dict.

    Does not really exist within the DICOM definition, just a way to
    minimize storage and have a mapping from gdcm::Tag to the needed
    information bla TODO FIXME: Need a PublicDictEntry...indeed DictEntry
    has a notion of retired which does not exist in PrivateDictEntry...

    See:   gdcm::Dict

    C++ includes: gdcmDictEntry.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictEntry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::DictEntry::DictEntry(const char *name="", const char
        *keyword="", VR const &vr=VR::INVALID, VM const &vm=VM::VM0, bool
        ret=false) 
        """
        this = _gdcmswig.new_DictEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetVR(self) -> "gdcm::VR const &":
        """
        const VR&
        gdcm::DictEntry::GetVR() const

        Set/Get VR. 
        """
        return _gdcmswig.DictEntry_GetVR(self)


    def SetVR(self, vr: 'VR') -> "void":
        """
        void
        gdcm::DictEntry::SetVR(const VR &vr) 
        """
        return _gdcmswig.DictEntry_SetVR(self, vr)


    def GetVM(self) -> "gdcm::VM const &":
        """
        const VM&
        gdcm::DictEntry::GetVM() const

        Set/Get VM. 
        """
        return _gdcmswig.DictEntry_GetVM(self)


    def SetVM(self, vm: 'VM') -> "void":
        """
        void
        gdcm::DictEntry::SetVM(VM const &vm) 
        """
        return _gdcmswig.DictEntry_SetVM(self, vm)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::DictEntry::GetName() const

        Set/Get Name. 
        """
        return _gdcmswig.DictEntry_GetName(self)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::DictEntry::SetName(const char *name) 
        """
        return _gdcmswig.DictEntry_SetName(self, name)


    def GetKeyword(self) -> "char const *":
        """
        const char*
        gdcm::DictEntry::GetKeyword() const

        same as GetName but without spaces... 
        """
        return _gdcmswig.DictEntry_GetKeyword(self)


    def SetKeyword(self, keyword: 'char const *') -> "void":
        """
        void
        gdcm::DictEntry::SetKeyword(const char *keyword) 
        """
        return _gdcmswig.DictEntry_SetKeyword(self, keyword)


    def GetRetired(self) -> "bool":
        """
        bool
        gdcm::DictEntry::GetRetired() const

        Set/Get Retired flag. 
        """
        return _gdcmswig.DictEntry_GetRetired(self)


    def SetRetired(self, retired: 'bool') -> "void":
        """
        void
        gdcm::DictEntry::SetRetired(bool retired) 
        """
        return _gdcmswig.DictEntry_SetRetired(self, retired)


    def SetGroupXX(self, v: 'bool') -> "void":
        """
        void
        gdcm::DictEntry::SetGroupXX(bool v)

        Set whether element is shared in multiple groups (Curve/Overlay
        typically) 
        """
        return _gdcmswig.DictEntry_SetGroupXX(self, v)


    def SetElementXX(self, v: 'bool') -> "void":
        """
        void
        gdcm::DictEntry::SetElementXX(bool v)

        Set whether element is shared in multiple elements (Source Image IDs
        typically) 
        """
        return _gdcmswig.DictEntry_SetElementXX(self, v)


    def IsUnique(self) -> "bool":
        """
        bool
        gdcm::DictEntry::IsUnique() const

        Return whether the name of the DataElement can be considered to be
        unique. As of 2008 all elements name were unique (except the
        expclitely 'XX' ones) 
        """
        return _gdcmswig.DictEntry_IsUnique(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.DictEntry___str__(self)
    __swig_destroy__ = _gdcmswig.delete_DictEntry
    __del__ = lambda self: None
DictEntry_swigregister = _gdcmswig.DictEntry_swigregister
DictEntry_swigregister(DictEntry)
cvar = _gdcmswig.cvar
GlobalInstance = cvar.GlobalInstance

class CSAHeaderDictEntry(_object):
    """


    Class to represent an Entry in the Dict.

    Does not really exist within the DICOM definition, just a way to
    minimize storage and have a mapping from gdcm::Tag to the needed
    information bla TODO FIXME: Need a PublicCSAHeaderDictEntry...indeed
    CSAHeaderDictEntry has a notion of retired which does not exist in
    PrivateCSAHeaderDictEntry...

    See:   gdcm::Dict

    C++ includes: gdcmCSAHeaderDictEntry.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSAHeaderDictEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSAHeaderDictEntry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::CSAHeaderDictEntry::CSAHeaderDictEntry(const char *name="", VR
        const &vr=VR::INVALID, VM const &vm=VM::VM0, const char *desc="") 
        """
        this = _gdcmswig.new_CSAHeaderDictEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetVR(self) -> "gdcm::VR const &":
        """
        const VR&
        gdcm::CSAHeaderDictEntry::GetVR() const

        Set/Get VR. 
        """
        return _gdcmswig.CSAHeaderDictEntry_GetVR(self)


    def SetVR(self, vr: 'VR') -> "void":
        """
        void
        gdcm::CSAHeaderDictEntry::SetVR(const VR &vr) 
        """
        return _gdcmswig.CSAHeaderDictEntry_SetVR(self, vr)


    def GetVM(self) -> "gdcm::VM const &":
        """
        const VM&
        gdcm::CSAHeaderDictEntry::GetVM() const

        Set/Get VM. 
        """
        return _gdcmswig.CSAHeaderDictEntry_GetVM(self)


    def SetVM(self, vm: 'VM') -> "void":
        """
        void
        gdcm::CSAHeaderDictEntry::SetVM(VM const &vm) 
        """
        return _gdcmswig.CSAHeaderDictEntry_SetVM(self, vm)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::CSAHeaderDictEntry::GetName() const

        Set/Get Name. 
        """
        return _gdcmswig.CSAHeaderDictEntry_GetName(self)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::CSAHeaderDictEntry::SetName(const char *name) 
        """
        return _gdcmswig.CSAHeaderDictEntry_SetName(self, name)


    def GetDescription(self) -> "char const *":
        """
        const char* gdcm::CSAHeaderDictEntry::GetDescription() const

        Set/Get Description. 
        """
        return _gdcmswig.CSAHeaderDictEntry_GetDescription(self)


    def SetDescription(self, desc: 'char const *') -> "void":
        """
        void
        gdcm::CSAHeaderDictEntry::SetDescription(const char *desc) 
        """
        return _gdcmswig.CSAHeaderDictEntry_SetDescription(self, desc)


    def __lt__(self, entry: 'CSAHeaderDictEntry') -> "bool":
        return _gdcmswig.CSAHeaderDictEntry___lt__(self, entry)

    def __str__(self) -> "char const *":
        return _gdcmswig.CSAHeaderDictEntry___str__(self)
    __swig_destroy__ = _gdcmswig.delete_CSAHeaderDictEntry
    __del__ = lambda self: None
CSAHeaderDictEntry_swigregister = _gdcmswig.CSAHeaderDictEntry_swigregister
CSAHeaderDictEntry_swigregister(CSAHeaderDictEntry)

class DictEntryTagPairType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictEntryTagPairType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DictEntryTagPairType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _gdcmswig.new_DictEntryTagPairType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _gdcmswig.DictEntryTagPairType_first_set
    __swig_getmethods__["first"] = _gdcmswig.DictEntryTagPairType_first_get
    if _newclass:
        first = _swig_property(_gdcmswig.DictEntryTagPairType_first_get, _gdcmswig.DictEntryTagPairType_first_set)
    __swig_setmethods__["second"] = _gdcmswig.DictEntryTagPairType_second_set
    __swig_getmethods__["second"] = _gdcmswig.DictEntryTagPairType_second_get
    if _newclass:
        second = _swig_property(_gdcmswig.DictEntryTagPairType_second_get, _gdcmswig.DictEntryTagPairType_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _gdcmswig.delete_DictEntryTagPairType
    __del__ = lambda self: None
DictEntryTagPairType_swigregister = _gdcmswig.DictEntryTagPairType_swigregister
DictEntryTagPairType_swigregister(DictEntryTagPairType)

class Dict(_object):
    """


    Class to represent a map of DictEntry.

    bla TODO FIXME: For Element == 0x0 need to return Name = Group Length
    ValueRepresentation = UL ValueMultiplicity = 1

    C++ includes: gdcmDict.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dict, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Dict::Dict() """
        this = _gdcmswig.new_Dict()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Begin(self) -> "gdcm::Dict::ConstIterator":
        """
        ConstIterator
        gdcm::Dict::Begin() const 
        """
        return _gdcmswig.Dict_Begin(self)


    def End(self) -> "gdcm::Dict::ConstIterator":
        """
        ConstIterator
        gdcm::Dict::End() const 
        """
        return _gdcmswig.Dict_End(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Dict::IsEmpty() const 
        """
        return _gdcmswig.Dict_IsEmpty(self)


    def AddDictEntry(self, tag: 'Tag', de: 'DictEntry') -> "void":
        """
        void
        gdcm::Dict::AddDictEntry(const Tag &tag, const DictEntry &de) 
        """
        return _gdcmswig.Dict_AddDictEntry(self, tag, de)


    def GetDictEntry(self, tag: 'Tag') -> "gdcm::DictEntry const &":
        """
        const DictEntry&
        gdcm::Dict::GetDictEntry(const Tag &tag) const 
        """
        return _gdcmswig.Dict_GetDictEntry(self, tag)


    def GetKeywordFromTag(self, tag: 'Tag') -> "char const *":
        """
        const char*
        gdcm::Dict::GetKeywordFromTag(Tag const &tag) const

        Function to return the Keyword from a Tag. 
        """
        return _gdcmswig.Dict_GetKeywordFromTag(self, tag)


    def GetDictEntryByName(self, name: 'char const *', tag: 'Tag') -> "gdcm::DictEntry const &":
        """
        const
        DictEntry& gdcm::Dict::GetDictEntryByName(const char *name, Tag &tag)
        const

        Inefficient way of looking up tag by name. Technically DICOM does not
        garantee uniqueness (and Curve / Overlay are there to prove it). But
        most of the time name is in fact uniq and can be uniquely link to a
        tag 
        """
        return _gdcmswig.Dict_GetDictEntryByName(self, name, tag)


    def __str__(self) -> "char const *":
        return _gdcmswig.Dict___str__(self)

    def GetDictEntryByKeyword(self, *args) -> "std::pair< gdcm::DictEntry,gdcm::Tag >":
        """
        const
        DictEntry& gdcm::Dict::GetDictEntryByKeyword(const char *keyword, Tag
        &tag) const

        Lookup DictEntry by keyword. Even if DICOM standard defines keyword as
        being unique. The lookup table is built on Tag. Therefore looking up a
        DictEntry by Keyword is more inefficient than looking up by Tag. 
        """
        return _gdcmswig.Dict_GetDictEntryByKeyword(self, *args)

    __swig_destroy__ = _gdcmswig.delete_Dict
    __del__ = lambda self: None
Dict_swigregister = _gdcmswig.Dict_swigregister
Dict_swigregister(Dict)

class PrivateDict(_object):
    """


    Private Dict.

    C++ includes: gdcmDict.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PrivateDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PrivateDict, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PrivateDict::PrivateDict() """
        this = _gdcmswig.new_PrivateDict()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PrivateDict
    __del__ = lambda self: None

    def AddDictEntry(self, tag: 'PrivateTag', de: 'DictEntry') -> "void":
        """
        void
        gdcm::PrivateDict::AddDictEntry(const PrivateTag &tag, const DictEntry
        &de) 
        """
        return _gdcmswig.PrivateDict_AddDictEntry(self, tag, de)


    def RemoveDictEntry(self, tag: 'PrivateTag') -> "bool":
        """
        bool
        gdcm::PrivateDict::RemoveDictEntry(const PrivateTag &tag)

        Remove entry 'tag'. Return true on success (element was found and
        remove). return false if element was not found. 
        """
        return _gdcmswig.PrivateDict_RemoveDictEntry(self, tag)


    def FindDictEntry(self, tag: 'PrivateTag') -> "bool":
        """
        bool
        gdcm::PrivateDict::FindDictEntry(const PrivateTag &tag) const 
        """
        return _gdcmswig.PrivateDict_FindDictEntry(self, tag)


    def GetDictEntry(self, tag: 'PrivateTag') -> "gdcm::DictEntry const &":
        """
        const
        DictEntry& gdcm::PrivateDict::GetDictEntry(const PrivateTag &tag)
        const 
        """
        return _gdcmswig.PrivateDict_GetDictEntry(self, tag)


    def PrintXML(self) -> "void":
        """
        void
        gdcm::PrivateDict::PrintXML() const 
        """
        return _gdcmswig.PrivateDict_PrintXML(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::PrivateDict::IsEmpty() const 
        """
        return _gdcmswig.PrivateDict_IsEmpty(self)

PrivateDict_swigregister = _gdcmswig.PrivateDict_swigregister
PrivateDict_swigregister(PrivateDict)

class CSAHeaderDictException(_object):
    """
    C++ includes:
    gdcmCSAHeaderDict.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSAHeaderDictException, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSAHeaderDictException, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _gdcmswig.new_CSAHeaderDictException()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_CSAHeaderDictException
    __del__ = lambda self: None
CSAHeaderDictException_swigregister = _gdcmswig.CSAHeaderDictException_swigregister
CSAHeaderDictException_swigregister(CSAHeaderDictException)

class CSAHeaderDict(_object):
    """


    Class to represent a map of CSAHeaderDictEntry.

    C++ includes: gdcmCSAHeaderDict.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CSAHeaderDict, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CSAHeaderDict, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::CSAHeaderDict::CSAHeaderDict() """
        this = _gdcmswig.new_CSAHeaderDict()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Begin(self) -> "gdcm::CSAHeaderDict::ConstIterator":
        """
        ConstIterator
        gdcm::CSAHeaderDict::Begin() const 
        """
        return _gdcmswig.CSAHeaderDict_Begin(self)


    def End(self) -> "gdcm::CSAHeaderDict::ConstIterator":
        """
        ConstIterator
        gdcm::CSAHeaderDict::End() const 
        """
        return _gdcmswig.CSAHeaderDict_End(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::CSAHeaderDict::IsEmpty() const 
        """
        return _gdcmswig.CSAHeaderDict_IsEmpty(self)


    def AddCSAHeaderDictEntry(self, de: 'CSAHeaderDictEntry') -> "void":
        """
        void gdcm::CSAHeaderDict::AddCSAHeaderDictEntry(const
        CSAHeaderDictEntry &de) 
        """
        return _gdcmswig.CSAHeaderDict_AddCSAHeaderDictEntry(self, de)


    def GetCSAHeaderDictEntry(self, name: 'char const *') -> "gdcm::CSAHeaderDictEntry const &":
        """
        const CSAHeaderDictEntry&
        gdcm::CSAHeaderDict::GetCSAHeaderDictEntry(const char *name) const 
        """
        return _gdcmswig.CSAHeaderDict_GetCSAHeaderDictEntry(self, name)

    __swig_destroy__ = _gdcmswig.delete_CSAHeaderDict
    __del__ = lambda self: None
CSAHeaderDict_swigregister = _gdcmswig.CSAHeaderDict_swigregister
CSAHeaderDict_swigregister(CSAHeaderDict)

class Dicts(_object):
    """


    Class to manipulate the sum of knowledge (all the dict user load)

    bla

    C++ includes: gdcmDicts.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dicts, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Dicts, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Dicts::Dicts() """
        this = _gdcmswig.new_Dicts()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Dicts
    __del__ = lambda self: None

    def GetDictEntry(self, *args) -> "gdcm::DictEntry const &":
        """
        const DictEntry&
        gdcm::Dicts::GetDictEntry(const PrivateTag &tag) const 
        """
        return _gdcmswig.Dicts_GetDictEntry(self, *args)


    def GetPublicDict(self) -> "gdcm::Dict const &":
        """
        const Dict&
        gdcm::Dicts::GetPublicDict() const 
        """
        return _gdcmswig.Dicts_GetPublicDict(self)


    def GetPrivateDict(self, *args) -> "gdcm::PrivateDict &":
        """
        PrivateDict&
        gdcm::Dicts::GetPrivateDict() 
        """
        return _gdcmswig.Dicts_GetPrivateDict(self, *args)


    def GetCSAHeaderDict(self) -> "gdcm::CSAHeaderDict const &":
        """
        const
        CSAHeaderDict& gdcm::Dicts::GetCSAHeaderDict() const 
        """
        return _gdcmswig.Dicts_GetCSAHeaderDict(self)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Dicts::IsEmpty() const 
        """
        return _gdcmswig.Dicts_IsEmpty(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.Dicts___str__(self)
Dicts_swigregister = _gdcmswig.Dicts_swigregister
Dicts_swigregister(Dicts)

class TagSetType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagSetType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TagSetType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.TagSetType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.TagSetType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.TagSetType___bool__(self)

    def __len__(self) -> "std::set< gdcm::Tag >::size_type":
        return _gdcmswig.TagSetType___len__(self)

    def append(self, x: 'Tag') -> "void":
        return _gdcmswig.TagSetType_append(self, x)

    def __contains__(self, x: 'Tag') -> "bool":
        return _gdcmswig.TagSetType___contains__(self, x)

    def __getitem__(self, i: 'std::set< gdcm::Tag >::difference_type') -> "std::set< gdcm::Tag >::value_type":
        return _gdcmswig.TagSetType___getitem__(self, i)

    def add(self, x: 'Tag') -> "void":
        return _gdcmswig.TagSetType_add(self, x)

    def discard(self, x: 'Tag') -> "void":
        return _gdcmswig.TagSetType_discard(self, x)

    def __init__(self, *args):
        this = _gdcmswig.new_TagSetType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _gdcmswig.TagSetType_empty(self)

    def size(self) -> "std::set< gdcm::Tag >::size_type":
        return _gdcmswig.TagSetType_size(self)

    def clear(self) -> "void":
        return _gdcmswig.TagSetType_clear(self)

    def swap(self, v: 'TagSetType') -> "void":
        return _gdcmswig.TagSetType_swap(self, v)

    def count(self, x: 'Tag') -> "std::set< gdcm::Tag >::size_type":
        return _gdcmswig.TagSetType_count(self, x)

    def begin(self) -> "std::set< gdcm::Tag >::iterator":
        return _gdcmswig.TagSetType_begin(self)

    def end(self) -> "std::set< gdcm::Tag >::iterator":
        return _gdcmswig.TagSetType_end(self)

    def rbegin(self) -> "std::set< gdcm::Tag >::reverse_iterator":
        return _gdcmswig.TagSetType_rbegin(self)

    def rend(self) -> "std::set< gdcm::Tag >::reverse_iterator":
        return _gdcmswig.TagSetType_rend(self)

    def erase(self, *args) -> "void":
        return _gdcmswig.TagSetType_erase(self, *args)

    def find(self, x: 'Tag') -> "std::set< gdcm::Tag >::iterator":
        return _gdcmswig.TagSetType_find(self, x)

    def lower_bound(self, x: 'Tag') -> "std::set< gdcm::Tag >::iterator":
        return _gdcmswig.TagSetType_lower_bound(self, x)

    def upper_bound(self, x: 'Tag') -> "std::set< gdcm::Tag >::iterator":
        return _gdcmswig.TagSetType_upper_bound(self, x)

    def equal_range(self, x: 'Tag') -> "std::pair< std::set< gdcm::Tag >::iterator,std::set< gdcm::Tag >::iterator >":
        return _gdcmswig.TagSetType_equal_range(self, x)

    def insert(self, __x: 'Tag') -> "std::pair< std::set< gdcm::Tag >::iterator,bool >":
        return _gdcmswig.TagSetType_insert(self, __x)
    __swig_destroy__ = _gdcmswig.delete_TagSetType
    __del__ = lambda self: None
TagSetType_swigregister = _gdcmswig.TagSetType_swigregister
TagSetType_swigregister(TagSetType)

class Reader(_object):
    """


    Reader ala DOM (Document Object Model)

    This class is a non-validating reader, it will only performs well-
    formedness check only, and to some extent catch known error (non well-
    formed document).

    Detailled description here

    A DataSet DOES NOT contains group 0x0002 (see FileMetaInformation)

    This is really a DataSet reader. This will not make sure the dataset
    conform to any IOD at all. This is a completely different step. The
    reasoning was that user could control the IOD there lib would handle
    and thus we would not be able to read a DataSet if the IOD was not
    found Instead we separate the reading from the validation.

    From GDCM1.x. Users will realize that one feature is missing from this
    DOM implementation. In GDCM 1.x user used to be able to control the
    size of the Value to be read. By default it was 0xfff. The main author
    of GDCM2 thought this was too dangerous and harmful and therefore this
    feature did not make it into GDCM2

    WARNING:  GDCM will not produce warning for unorder (non-alphabetical
    order).

    See:   Writer FileMetaInformation DataSet File

    C++ includes: gdcmReader.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Reader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Reader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Reader::Reader()

        """
        this = _gdcmswig.new_Reader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Reader
    __del__ = lambda self: None

    def Read(self) -> "bool":
        """
        virtual bool
        gdcm::Reader::Read()

        Main function to read a file. 
        """
        return _gdcmswig.Reader_Read(self)


    def SetFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::Reader::SetFileName(const char *filename_native)

        Set the filename to open. This will create a std::ifstream internally
        See SetStream if you are dealing with different std::istream object 
        """
        return _gdcmswig.Reader_SetFileName(self, filename_native)


    def GetFile(self, *args) -> "gdcm::File &":
        """
        File&
        gdcm::Reader::GetFile()

        Set/Get File. 
        """
        return _gdcmswig.Reader_GetFile(self, *args)


    def SetFile(self, file: 'File') -> "void":
        """
        void
        gdcm::Reader::SetFile(File &file)

        Set/Get File. 
        """
        return _gdcmswig.Reader_SetFile(self, file)


    def ReadUpToTag(self, *args) -> "bool":
        """
        bool
        gdcm::Reader::ReadUpToTag(const Tag &tag, std::set< Tag > const
        &skiptags=std::set< Tag >())

        Will read only up to Tag

        Parameters:
        -----------

        tag:  and skipping any tag specified in

        skiptags:  
        """
        return _gdcmswig.Reader_ReadUpToTag(self, *args)


    def ReadSelectedTags(self, tags: 'TagSetType', readvalues: 'bool'=True) -> "bool":
        """
        bool
        gdcm::Reader::ReadSelectedTags(std::set< Tag > const &tags, bool
        readvalues=true)

        Will only read the specified selected tags. 
        """
        return _gdcmswig.Reader_ReadSelectedTags(self, tags, readvalues)


    def ReadSelectedPrivateTags(self, ptags: 'std::set< gdcm::PrivateTag,std::less< gdcm::PrivateTag >,std::allocator< gdcm::PrivateTag > > const &', readvalues: 'bool'=True) -> "bool":
        """
        bool
        gdcm::Reader::ReadSelectedPrivateTags(std::set< PrivateTag > const
        &ptags, bool readvalues=true)

        Will only read the specified selected private tags. 
        """
        return _gdcmswig.Reader_ReadSelectedPrivateTags(self, ptags, readvalues)


    def CanRead(self) -> "bool":
        """
        bool
        gdcm::Reader::CanRead() const

        Test whether this is a DICOM file WARNING:  need to call either
        SetFileName or SetStream first 
        """
        return _gdcmswig.Reader_CanRead(self)


    def GetStreamCurrentPosition(self) -> "size_t":
        """
        size_t
        gdcm::Reader::GetStreamCurrentPosition() const

        For wrapped language. return type is compatible with System::FileSize
        return type Use native std::streampos / std::streamoff directly from
        the stream from C++ 
        """
        return _gdcmswig.Reader_GetStreamCurrentPosition(self)

Reader_swigregister = _gdcmswig.Reader_swigregister
Reader_swigregister(Reader)

class PixmapReader(Reader):
    """


    PixmapReader.

    its role is to convert the DICOM DataSet into a Pixmap representation
    By default it is also loading the lookup table and overlay when found
    as they impact the rendering or the image  See PS 3.3-2008, Table
    C.7-11b IMAGE PIXEL MACRO ATTRIBUTES for the list of attribute that
    belong to what gdcm calls a ' Pixmap'

    WARNING:  the API ReadUpToTag and ReadSelectedTag

    See:   Pixmap

    C++ includes: gdcmPixmapReader.h 
    """

    __swig_setmethods__ = {}
    for _s in [Reader]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixmapReader, name, value)
    __swig_getmethods__ = {}
    for _s in [Reader]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PixmapReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PixmapReader::PixmapReader() """
        this = _gdcmswig.new_PixmapReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PixmapReader
    __del__ = lambda self: None

    def Read(self) -> "bool":
        """
        virtual bool
        gdcm::PixmapReader::Read()

        Read the DICOM image. There are two reason for failure: The input
        filename is not DICOM

        The input DICOM file does not contains an Pixmap. 
        """
        return _gdcmswig.PixmapReader_Read(self)


    def GetPixmap(self, *args) -> "gdcm::Pixmap &":
        """
        Pixmap&
        gdcm::PixmapReader::GetPixmap() 
        """
        return _gdcmswig.PixmapReader_GetPixmap(self, *args)

PixmapReader_swigregister = _gdcmswig.PixmapReader_swigregister
PixmapReader_swigregister(PixmapReader)

class ImageReader(PixmapReader):
    """


    ImageReader.

    its role is to convert the DICOM DataSet into a Image representation
    Image is different from Pixmap has it has a position and a direction
    in Space.

    See:   Image

    C++ includes: gdcmImageReader.h 
    """

    __swig_setmethods__ = {}
    for _s in [PixmapReader]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageReader, name, value)
    __swig_getmethods__ = {}
    for _s in [PixmapReader]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageReader::ImageReader() """
        this = _gdcmswig.new_ImageReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageReader
    __del__ = lambda self: None

    def Read(self) -> "bool":
        """
        virtual bool
        gdcm::ImageReader::Read()

        Read the DICOM image. There are two reason for failure: The input
        filename is not DICOM

        The input DICOM file does not contains an Image. 
        """
        return _gdcmswig.ImageReader_Read(self)


    def GetImage(self, *args) -> "gdcm::Image &":
        """
        Image&
        gdcm::ImageReader::GetImage() 
        """
        return _gdcmswig.ImageReader_GetImage(self, *args)

ImageReader_swigregister = _gdcmswig.ImageReader_swigregister
ImageReader_swigregister(ImageReader)

class Writer(_object):
    """


    Writer ala DOM (Document Object Model)

    This class is a non-validating writer, it will only performs well-
    formedness check only.

    Detailled description here To avoid GDCM being yet another broken
    DICOM lib we try to be user level and avoid writing illegal stuff (odd
    length, non-zero value for Item start/end length ...) Therefore you
    cannot (well unless you are really smart) write DICOM with even length
    tag. All the checks are consider basics: Correct Meta Information
    Header (see gdcm::FileMetaInformation)

    Zero value for Item Length (0xfffe, 0xe00d/0xe0dd)

    Even length for any elements

    Alphabetical order for elements (garanteed by design of internals)

    32bits VR will be rewritten with 00

    WARNING:   gdcm::Writer cannot write a DataSet if no SOP Instance UID
    (0008,0018) is found, unless a DICOMDIR is being written out

    See:   Reader DataSet File

    C++ includes: gdcmWriter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Writer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Writer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Writer::Writer()

        """
        this = _gdcmswig.new_Writer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Writer
    __del__ = lambda self: None

    def Write(self) -> "bool":
        """
        virtual bool
        gdcm::Writer::Write()

        Main function to tell the writer to write. 
        """
        return _gdcmswig.Writer_Write(self)


    def SetFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::Writer::SetFileName(const char *filename_native)

        Set the filename of DICOM file to write: 
        """
        return _gdcmswig.Writer_SetFileName(self, filename_native)


    def SetStream(self, output_stream: 'std::ostream &') -> "void":
        """
        void
        gdcm::Writer::SetStream(std::ostream &output_stream)

        Set user ostream buffer. 
        """
        return _gdcmswig.Writer_SetStream(self, output_stream)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::Writer::SetFile(const File &f)

        Set/Get the DICOM file ( DataSet + Header) 
        """
        return _gdcmswig.Writer_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """
        File&
        gdcm::Writer::GetFile() 
        """
        return _gdcmswig.Writer_GetFile(self)


    def SetCheckFileMetaInformation(self, b: 'bool') -> "void":
        """
        void gdcm::Writer::SetCheckFileMetaInformation(bool b)

        Undocumented function, do not use (= leave default) 
        """
        return _gdcmswig.Writer_SetCheckFileMetaInformation(self, b)


    def CheckFileMetaInformationOff(self) -> "void":
        """void gdcm::Writer::CheckFileMetaInformationOff() """
        return _gdcmswig.Writer_CheckFileMetaInformationOff(self)


    def CheckFileMetaInformationOn(self) -> "void":
        """
        void
        gdcm::Writer::CheckFileMetaInformationOn() 
        """
        return _gdcmswig.Writer_CheckFileMetaInformationOn(self)

Writer_swigregister = _gdcmswig.Writer_swigregister
Writer_swigregister(Writer)

class PixmapWriter(Writer):
    """


    PixmapWriter.

    This class will takes two inputs: The DICOM DataSet

    The Image input It will override any info from the Image over the
    DataSet.

    For instance when one read in a lossy compressed image and write out
    as unencapsulated (ie implicitely lossless) then some attribute are
    definitely needed to mark this dataset as Lossy (typically 0028,2114)

    C++ includes: gdcmPixmapWriter.h 
    """

    __swig_setmethods__ = {}
    for _s in [Writer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixmapWriter, name, value)
    __swig_getmethods__ = {}
    for _s in [Writer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PixmapWriter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PixmapWriter::PixmapWriter() """
        this = _gdcmswig.new_PixmapWriter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PixmapWriter
    __del__ = lambda self: None

    def GetPixmap(self, *args) -> "gdcm::Pixmap &":
        """
        Pixmap&
        gdcm::PixmapWriter::GetPixmap() 
        """
        return _gdcmswig.PixmapWriter_GetPixmap(self, *args)


    def SetPixmap(self, img: 'Pixmap') -> "void":
        """
        void
        gdcm::PixmapWriter::SetPixmap(Pixmap const &img) 
        """
        return _gdcmswig.PixmapWriter_SetPixmap(self, img)


    def GetImage(self, *args) -> "gdcm::Pixmap &":
        """
        virtual Pixmap&
        gdcm::PixmapWriter::GetImage() 
        """
        return _gdcmswig.PixmapWriter_GetImage(self, *args)


    def SetImage(self, img: 'Pixmap') -> "void":
        """
        virtual void
        gdcm::PixmapWriter::SetImage(Pixmap const &img) 
        """
        return _gdcmswig.PixmapWriter_SetImage(self, img)


    def Write(self) -> "bool":
        """
        bool
        gdcm::PixmapWriter::Write()

        Write. 
        """
        return _gdcmswig.PixmapWriter_Write(self)

PixmapWriter_swigregister = _gdcmswig.PixmapWriter_swigregister
PixmapWriter_swigregister(PixmapWriter)

class ImageWriter(PixmapWriter):
    """


    ImageWriter.

    C++ includes: gdcmImageWriter.h 
    """

    __swig_setmethods__ = {}
    for _s in [PixmapWriter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageWriter, name, value)
    __swig_getmethods__ = {}
    for _s in [PixmapWriter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageWriter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageWriter::ImageWriter() """
        this = _gdcmswig.new_ImageWriter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageWriter
    __del__ = lambda self: None

    def GetImage(self, *args) -> "gdcm::Image &":
        """
        Image&
        gdcm::ImageWriter::GetImage() 
        """
        return _gdcmswig.ImageWriter_GetImage(self, *args)


    def Write(self) -> "bool":
        """
        bool
        gdcm::ImageWriter::Write()

        Write. 
        """
        return _gdcmswig.ImageWriter_Write(self)


    def ComputeTargetMediaStorage(self) -> "gdcm::MediaStorage":
        """
        MediaStorage gdcm::ImageWriter::ComputeTargetMediaStorage()

        internal function used to compute a target MediaStorage the most
        appropriate User may want to call this function ahead of time (before
        Write) 
        """
        return _gdcmswig.ImageWriter_ComputeTargetMediaStorage(self)

ImageWriter_swigregister = _gdcmswig.ImageWriter_swigregister
ImageWriter_swigregister(ImageWriter)

class PairString(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PairString, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PairString, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _gdcmswig.new_PairString(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _gdcmswig.PairString_first_set
    __swig_getmethods__["first"] = _gdcmswig.PairString_first_get
    if _newclass:
        first = _swig_property(_gdcmswig.PairString_first_get, _gdcmswig.PairString_first_set)
    __swig_setmethods__["second"] = _gdcmswig.PairString_second_set
    __swig_getmethods__["second"] = _gdcmswig.PairString_second_get
    if _newclass:
        second = _swig_property(_gdcmswig.PairString_second_get, _gdcmswig.PairString_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _gdcmswig.delete_PairString
    __del__ = lambda self: None
PairString_swigregister = _gdcmswig.PairString_swigregister
PairString_swigregister(PairString)

class StringFilter(_object):
    """


    StringFilter.

    StringFilter is the class that make gdcm2.x looks more like gdcm1 and
    transform the binary blob contained in a DataElement into a string,
    typically this is a nice feature to have for wrapped language

    C++ includes: gdcmStringFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StringFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StringFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::StringFilter::StringFilter() """
        this = _gdcmswig.new_StringFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_StringFilter
    __del__ = lambda self: None

    def UseDictAlways(self, arg2: 'bool') -> "void":
        """
        void
        gdcm::StringFilter::UseDictAlways(bool) 
        """
        return _gdcmswig.StringFilter_UseDictAlways(self, arg2)


    def SetDicts(self, dicts: 'Dicts') -> "void":
        """
        void
        gdcm::StringFilter::SetDicts(const Dicts &dicts)

        Allow user to pass in there own dicts. 
        """
        return _gdcmswig.StringFilter_SetDicts(self, dicts)


    def ToString(self, *args) -> "std::string":
        """
        std::string
        gdcm::StringFilter::ToString(const Tag &t) const

        Directly from a Tag: 
        """
        return _gdcmswig.StringFilter_ToString(self, *args)


    def ToStringPair(self, *args) -> "std::pair< std::string,std::string >":
        """
        std::pair<std::string, std::string>
        gdcm::StringFilter::ToStringPair(const Tag &t) const

        Directly from a Tag: 
        """
        return _gdcmswig.StringFilter_ToStringPair(self, *args)


    def FromString(self, t: 'Tag', value: 'char const *', len: 'size_t') -> "std::string":
        """
        std::string
        gdcm::StringFilter::FromString(const Tag &t, const char *value, size_t
        len)

        Convert to string the char array defined by the pair (value,len) 
        """
        return _gdcmswig.StringFilter_FromString(self, t, value, len)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::StringFilter::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.StringFilter_SetFile(self, f)


    def GetFile(self, *args) -> "gdcm::File const &":
        """
        const File&
        gdcm::StringFilter::GetFile() const 
        """
        return _gdcmswig.StringFilter_GetFile(self, *args)


    def ExecuteQuery(self, query: 'std::string const &', value: 'std::string &') -> "bool":
        """
        bool
        gdcm::StringFilter::ExecuteQuery(std::string const &query, std::string
        &value) const

        Execute the XPATH query to find a value (as string) return false when
        attribute is not found (or an error in the XPATH query) You need to
        make sure that your XPATH query is syntatically correct 
        """
        return _gdcmswig.StringFilter_ExecuteQuery(self, query, value)

StringFilter_swigregister = _gdcmswig.StringFilter_swigregister
StringFilter_swigregister(StringFilter)

class UIDGenerator(_object):
    """


    Class for generating unique UID.

    bla Usage: When constructing a Series or Study UID, user has to keep
    around the UID, otherwise the UID Generator will simply forget the
    value and create a new UID.

    C++ includes: gdcmUIDGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIDGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UIDGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::UIDGenerator::UIDGenerator()

        By default the root of a UID is a GDCM Root... 
        """
        this = _gdcmswig.new_UIDGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        SetRoot = staticmethod(_gdcmswig.UIDGenerator_SetRoot)
    else:
        SetRoot = _gdcmswig.UIDGenerator_SetRoot
    if _newclass:
        GetRoot = staticmethod(_gdcmswig.UIDGenerator_GetRoot)
    else:
        GetRoot = _gdcmswig.UIDGenerator_GetRoot

    def Generate(self) -> "char const *":
        """
        const char*
        gdcm::UIDGenerator::Generate()

        Internally uses a std::string, so two calls have the same pointer !
        save into a std::string In summary do not write code like that: const
        char *uid1 = uid.Generate(); const char *uid2 = uid.Generate(); since
        uid1 == uid2 
        """
        return _gdcmswig.UIDGenerator_Generate(self)

    if _newclass:
        IsValid = staticmethod(_gdcmswig.UIDGenerator_IsValid)
    else:
        IsValid = _gdcmswig.UIDGenerator_IsValid
    if _newclass:
        GetGDCMUID = staticmethod(_gdcmswig.UIDGenerator_GetGDCMUID)
    else:
        GetGDCMUID = _gdcmswig.UIDGenerator_GetGDCMUID
    __swig_destroy__ = _gdcmswig.delete_UIDGenerator
    __del__ = lambda self: None
UIDGenerator_swigregister = _gdcmswig.UIDGenerator_swigregister
UIDGenerator_swigregister(UIDGenerator)

def UIDGenerator_SetRoot(root: 'char const *') -> "void":
    return _gdcmswig.UIDGenerator_SetRoot(root)
UIDGenerator_SetRoot = _gdcmswig.UIDGenerator_SetRoot

def UIDGenerator_GetRoot() -> "char const *":
    return _gdcmswig.UIDGenerator_GetRoot()
UIDGenerator_GetRoot = _gdcmswig.UIDGenerator_GetRoot

def UIDGenerator_IsValid(uid: 'char const *') -> "bool":
    return _gdcmswig.UIDGenerator_IsValid(uid)
UIDGenerator_IsValid = _gdcmswig.UIDGenerator_IsValid

def UIDGenerator_GetGDCMUID() -> "char const *":
    return _gdcmswig.UIDGenerator_GetGDCMUID()
UIDGenerator_GetGDCMUID = _gdcmswig.UIDGenerator_GetGDCMUID

class UUIDGenerator(_object):
    """


    Class for generating unique UUID.

    generate DCE 1.1 uid

    C++ includes: gdcmUUIDGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UUIDGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UUIDGenerator, name)
    __repr__ = _swig_repr

    def Generate(self) -> "char const *":
        """
        const char*
        gdcm::UUIDGenerator::Generate()

        Return the generated uuid NOT THREAD SAFE 
        """
        return _gdcmswig.UUIDGenerator_Generate(self)

    if _newclass:
        IsValid = staticmethod(_gdcmswig.UUIDGenerator_IsValid)
    else:
        IsValid = _gdcmswig.UUIDGenerator_IsValid

    def __init__(self):
        this = _gdcmswig.new_UUIDGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_UUIDGenerator
    __del__ = lambda self: None
UUIDGenerator_swigregister = _gdcmswig.UUIDGenerator_swigregister
UUIDGenerator_swigregister(UUIDGenerator)

def UUIDGenerator_IsValid(uid: 'char const *') -> "bool":
    return _gdcmswig.UUIDGenerator_IsValid(uid)
UUIDGenerator_IsValid = _gdcmswig.UUIDGenerator_IsValid

class ValuesType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ValuesType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ValuesType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.ValuesType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.ValuesType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.ValuesType___bool__(self)

    def __len__(self) -> "std::set< std::string >::size_type":
        return _gdcmswig.ValuesType___len__(self)

    def append(self, x: 'std::set< std::string >::value_type') -> "void":
        return _gdcmswig.ValuesType_append(self, x)

    def __contains__(self, x: 'std::set< std::string >::value_type') -> "bool":
        return _gdcmswig.ValuesType___contains__(self, x)

    def __getitem__(self, i: 'std::set< std::string >::difference_type') -> "std::set< std::string >::value_type":
        return _gdcmswig.ValuesType___getitem__(self, i)

    def add(self, x: 'std::set< std::string >::value_type') -> "void":
        return _gdcmswig.ValuesType_add(self, x)

    def discard(self, x: 'std::set< std::string >::value_type') -> "void":
        return _gdcmswig.ValuesType_discard(self, x)

    def __init__(self, *args):
        this = _gdcmswig.new_ValuesType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def empty(self) -> "bool":
        return _gdcmswig.ValuesType_empty(self)

    def size(self) -> "std::set< std::string >::size_type":
        return _gdcmswig.ValuesType_size(self)

    def clear(self) -> "void":
        return _gdcmswig.ValuesType_clear(self)

    def swap(self, v: 'ValuesType') -> "void":
        return _gdcmswig.ValuesType_swap(self, v)

    def count(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::size_type":
        return _gdcmswig.ValuesType_count(self, x)

    def begin(self) -> "std::set< std::string >::iterator":
        return _gdcmswig.ValuesType_begin(self)

    def end(self) -> "std::set< std::string >::iterator":
        return _gdcmswig.ValuesType_end(self)

    def rbegin(self) -> "std::set< std::string >::reverse_iterator":
        return _gdcmswig.ValuesType_rbegin(self)

    def rend(self) -> "std::set< std::string >::reverse_iterator":
        return _gdcmswig.ValuesType_rend(self)

    def erase(self, *args) -> "void":
        return _gdcmswig.ValuesType_erase(self, *args)

    def find(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _gdcmswig.ValuesType_find(self, x)

    def lower_bound(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _gdcmswig.ValuesType_lower_bound(self, x)

    def upper_bound(self, x: 'std::set< std::string >::key_type const &') -> "std::set< std::string >::iterator":
        return _gdcmswig.ValuesType_upper_bound(self, x)

    def equal_range(self, x: 'std::set< std::string >::key_type const &') -> "std::pair< std::set< std::string >::iterator,std::set< std::string >::iterator >":
        return _gdcmswig.ValuesType_equal_range(self, x)

    def insert(self, __x: 'std::set< std::string >::value_type const &') -> "std::pair< std::set< std::string >::iterator,bool >":
        return _gdcmswig.ValuesType_insert(self, __x)
    __swig_destroy__ = _gdcmswig.delete_ValuesType
    __del__ = lambda self: None
ValuesType_swigregister = _gdcmswig.ValuesType_swigregister
ValuesType_swigregister(ValuesType)

class Subject(Object):
    """


    Subject.

    See:   Command Event

    C++ includes: gdcmSubject.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Subject, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Subject, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Subject::Subject() """
        this = _gdcmswig.new_Subject()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Subject
    __del__ = lambda self: None

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.Subject_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.Subject_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.Subject_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.Subject_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.Subject_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.Subject_HasObserver(self, event)

Subject_swigregister = _gdcmswig.Subject_swigregister
Subject_swigregister(Subject)

class Command(Subject):
    """


    Command superclass for callback/observer methods.

    See:   Subject

    C++ includes: gdcmCommand.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Command, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Command, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def Execute(self, *args) -> "void":
        """
        virtual void
        gdcm::Command::Execute(const Subject *caller, const Event &event)=0

        Abstract method that defines the action to be taken by the command.
        This variant is expected to be used when requests comes from a const
        Object 
        """
        return _gdcmswig.Command_Execute(self, *args)

Command_swigregister = _gdcmswig.Command_swigregister
Command_swigregister(Command)

class SmartPtrScan(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrScan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrScan, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrScan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrScan
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::Scanner *":
        return _gdcmswig.SmartPtrScan___deref__(self)

    def __ref__(self) -> "gdcm::Scanner &":
        return _gdcmswig.SmartPtrScan___ref__(self)

    def GetPointer(self) -> "gdcm::Scanner *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrScan_GetPointer(self)


    def AddTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::Scanner::AddTag(Tag const &t)

        Add a tag that will need to be read. Those are root level tags. 
        """
        return _gdcmswig.SmartPtrScan_AddTag(self, t)


    def ClearTags(self) -> "void":
        """
        void
        gdcm::Scanner::ClearTags() 
        """
        return _gdcmswig.SmartPtrScan_ClearTags(self)


    def AddPrivateTag(self, t: 'PrivateTag') -> "void":
        """
        void
        gdcm::Scanner::AddPrivateTag(PrivateTag const &t) 
        """
        return _gdcmswig.SmartPtrScan_AddPrivateTag(self, t)


    def AddSkipTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::Scanner::AddSkipTag(Tag const &t)

        Add a tag that will need to be skipped. Those are root level skip
        tags. 
        """
        return _gdcmswig.SmartPtrScan_AddSkipTag(self, t)


    def ClearSkipTags(self) -> "void":
        """
        void
        gdcm::Scanner::ClearSkipTags() 
        """
        return _gdcmswig.SmartPtrScan_ClearSkipTags(self)


    def Scan(self, filenames: 'FilenamesType') -> "bool":
        """
        bool
        gdcm::Scanner::Scan(Directory::FilenamesType const &filenames)

        Start the scan ! 
        """
        return _gdcmswig.SmartPtrScan_Scan(self, filenames)


    def GetFilenames(self) -> "gdcm::Directory::FilenamesType const &":
        """Directory::FilenamesType const& gdcm::Scanner::GetFilenames() const """
        return _gdcmswig.SmartPtrScan_GetFilenames(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Scanner::Print(std::ostream &os) const

        Print result. 
        """
        return _gdcmswig.SmartPtrScan_Print(self, os)


    def IsKey(self, filename: 'char const *') -> "bool":
        """
        bool
        gdcm::Scanner::IsKey(const char *filename) const

        Check if filename is a key in the Mapping table. returns true only of
        file can be found, which means the file was indeed a DICOM file that
        could be processed 
        """
        return _gdcmswig.SmartPtrScan_IsKey(self, filename)


    def GetKeys(self) -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::Scanner::GetKeys() const

        Return the list of filename that are key in the internal map, which
        means those filename were properly parsed 
        """
        return _gdcmswig.SmartPtrScan_GetKeys(self)


    def GetValues(self, *args) -> "gdcm::Scanner::ValuesType":
        """
        ValuesType
        gdcm::Scanner::GetValues(Tag const &t) const

        Get all the values found (in lexicographic order) associated with Tag
        't'. 
        """
        return _gdcmswig.SmartPtrScan_GetValues(self, *args)


    def GetOrderedValues(self, t: 'Tag') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::Scanner::GetOrderedValues(Tag const &t)
        const

        Get all the values found (in a vector) associated with Tag 't' This
        function is identical to GetValues, but is accessible from the wrapped
        layer (python, C#, java) 
        """
        return _gdcmswig.SmartPtrScan_GetOrderedValues(self, t)


    def Begin(self) -> "gdcm::Scanner::ConstIterator":
        """
        ConstIterator
        gdcm::Scanner::Begin() const 
        """
        return _gdcmswig.SmartPtrScan_Begin(self)


    def End(self) -> "gdcm::Scanner::ConstIterator":
        """
        ConstIterator
        gdcm::Scanner::End() const 
        """
        return _gdcmswig.SmartPtrScan_End(self)


    def GetMappings(self) -> "gdcm::Scanner::MappingType const &":
        """
        MappingType const&
        gdcm::Scanner::GetMappings() const

        Mappings are the mapping from a particular tag to the map, mapping
        filename to value: 
        """
        return _gdcmswig.SmartPtrScan_GetMappings(self)


    def GetMapping(self, filename: 'char const *') -> "gdcm::Scanner::TagToValue const &":
        """
        TagToValue const&
        gdcm::Scanner::GetMapping(const char *filename) const

        Get the std::map mapping filenames to value for file 'filename'. 
        """
        return _gdcmswig.SmartPtrScan_GetMapping(self, filename)


    def GetFilenameFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "char const *":
        """
        const char* gdcm::Scanner::GetFilenameFromTagToValue(Tag const &t,
        const char *valueref) const

        Will loop over all files and return the first file where value match
        the reference value 'valueref' 
        """
        return _gdcmswig.SmartPtrScan_GetFilenameFromTagToValue(self, t, valueref)


    def GetAllFilenamesFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType
        gdcm::Scanner::GetAllFilenamesFromTagToValue(Tag const &t, const char
        *valueref) const

        Will loop over all files and return a vector of std::strings of
        filenames where value match the reference value 'valueref' 
        """
        return _gdcmswig.SmartPtrScan_GetAllFilenamesFromTagToValue(self, t, valueref)


    def GetMappingFromTagToValue(self, t: 'Tag', value: 'char const *') -> "gdcm::Scanner::TagToValue const &":
        """
        TagToValue const& gdcm::Scanner::GetMappingFromTagToValue(Tag const
        &t, const char *value) const

        See GetFilenameFromTagToValue(). This is simply
        GetFilenameFromTagToValue followed. 
        """
        return _gdcmswig.SmartPtrScan_GetMappingFromTagToValue(self, t, value)


    def GetValue(self, filename: 'char const *', t: 'Tag') -> "char const *":
        """
        const char*
        gdcm::Scanner::GetValue(const char *filename, Tag const &t) const

        Retrieve the value found for tag: t associated with file: filename
        This is meant for a single short call. If multiple calls (multiple
        tags) should be done, prefer the GetMapping function, and then reuse
        the TagToValue hash table. WARNING:   Tag 't' should have been added
        via AddTag() prior to the Scan() call ! 
        """
        return _gdcmswig.SmartPtrScan_GetValue(self, filename, t)


    def New(self) -> "gdcm::SmartPointer< gdcm::Scanner >":
        return _gdcmswig.SmartPtrScan_New(self)

    def __str__(self) -> "char const *":
        return _gdcmswig.SmartPtrScan___str__(self)

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.SmartPtrScan_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.SmartPtrScan_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.SmartPtrScan_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.SmartPtrScan_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.SmartPtrScan_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.SmartPtrScan_HasObserver(self, event)

SmartPtrScan_swigregister = _gdcmswig.SmartPtrScan_swigregister
SmartPtrScan_swigregister(SmartPtrScan)

class Scanner(Subject):
    """


    Scanner.

    This filter is meant for quickly browsing a FileSet (a set of files on
    disk). Special consideration are taken so as to read the mimimum
    amount of information in each file in order to retrieve the user
    specified set of DICOM Attribute.

    This filter is dealing with both VRASCII and VRBINARY element, thanks
    to the help of StringFilter

    WARNING:  IMPORTANT In case of file where tags are not ordered
    (illegal as per DICOM specification), the output will be missing
    information

    implementation details. All values are stored in a std::set of
    std::string. Then the address of the cstring underlying the
    std::string is used in the std::map.  This class implement the
    Subject/Observer pattern trigger the following events:  ProgressEvent

    StartEvent

    EndEvent

    C++ includes: gdcmScanner.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Scanner, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Scanner, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Scanner::Scanner() """
        this = _gdcmswig.new_Scanner()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Scanner
    __del__ = lambda self: None

    def AddTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::Scanner::AddTag(Tag const &t)

        Add a tag that will need to be read. Those are root level tags. 
        """
        return _gdcmswig.Scanner_AddTag(self, t)


    def ClearTags(self) -> "void":
        """
        void
        gdcm::Scanner::ClearTags() 
        """
        return _gdcmswig.Scanner_ClearTags(self)


    def AddPrivateTag(self, t: 'PrivateTag') -> "void":
        """
        void
        gdcm::Scanner::AddPrivateTag(PrivateTag const &t) 
        """
        return _gdcmswig.Scanner_AddPrivateTag(self, t)


    def AddSkipTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::Scanner::AddSkipTag(Tag const &t)

        Add a tag that will need to be skipped. Those are root level skip
        tags. 
        """
        return _gdcmswig.Scanner_AddSkipTag(self, t)


    def ClearSkipTags(self) -> "void":
        """
        void
        gdcm::Scanner::ClearSkipTags() 
        """
        return _gdcmswig.Scanner_ClearSkipTags(self)


    def Scan(self, filenames: 'FilenamesType') -> "bool":
        """
        bool
        gdcm::Scanner::Scan(Directory::FilenamesType const &filenames)

        Start the scan ! 
        """
        return _gdcmswig.Scanner_Scan(self, filenames)


    def GetFilenames(self) -> "gdcm::Directory::FilenamesType const &":
        """Directory::FilenamesType const& gdcm::Scanner::GetFilenames() const """
        return _gdcmswig.Scanner_GetFilenames(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Scanner::Print(std::ostream &os) const

        Print result. 
        """
        return _gdcmswig.Scanner_Print(self, os)


    def IsKey(self, filename: 'char const *') -> "bool":
        """
        bool
        gdcm::Scanner::IsKey(const char *filename) const

        Check if filename is a key in the Mapping table. returns true only of
        file can be found, which means the file was indeed a DICOM file that
        could be processed 
        """
        return _gdcmswig.Scanner_IsKey(self, filename)


    def GetKeys(self) -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::Scanner::GetKeys() const

        Return the list of filename that are key in the internal map, which
        means those filename were properly parsed 
        """
        return _gdcmswig.Scanner_GetKeys(self)


    def GetValues(self, *args) -> "gdcm::Scanner::ValuesType":
        """
        ValuesType
        gdcm::Scanner::GetValues(Tag const &t) const

        Get all the values found (in lexicographic order) associated with Tag
        't'. 
        """
        return _gdcmswig.Scanner_GetValues(self, *args)


    def GetOrderedValues(self, t: 'Tag') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::Scanner::GetOrderedValues(Tag const &t)
        const

        Get all the values found (in a vector) associated with Tag 't' This
        function is identical to GetValues, but is accessible from the wrapped
        layer (python, C#, java) 
        """
        return _gdcmswig.Scanner_GetOrderedValues(self, t)


    def Begin(self) -> "gdcm::Scanner::ConstIterator":
        """
        ConstIterator
        gdcm::Scanner::Begin() const 
        """
        return _gdcmswig.Scanner_Begin(self)


    def End(self) -> "gdcm::Scanner::ConstIterator":
        """
        ConstIterator
        gdcm::Scanner::End() const 
        """
        return _gdcmswig.Scanner_End(self)


    def GetMappings(self) -> "gdcm::Scanner::MappingType const &":
        """
        MappingType const&
        gdcm::Scanner::GetMappings() const

        Mappings are the mapping from a particular tag to the map, mapping
        filename to value: 
        """
        return _gdcmswig.Scanner_GetMappings(self)


    def GetMapping(self, filename: 'char const *') -> "gdcm::Scanner::TagToValue const &":
        """
        TagToValue const&
        gdcm::Scanner::GetMapping(const char *filename) const

        Get the std::map mapping filenames to value for file 'filename'. 
        """
        return _gdcmswig.Scanner_GetMapping(self, filename)


    def GetFilenameFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "char const *":
        """
        const char* gdcm::Scanner::GetFilenameFromTagToValue(Tag const &t,
        const char *valueref) const

        Will loop over all files and return the first file where value match
        the reference value 'valueref' 
        """
        return _gdcmswig.Scanner_GetFilenameFromTagToValue(self, t, valueref)


    def GetAllFilenamesFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType
        gdcm::Scanner::GetAllFilenamesFromTagToValue(Tag const &t, const char
        *valueref) const

        Will loop over all files and return a vector of std::strings of
        filenames where value match the reference value 'valueref' 
        """
        return _gdcmswig.Scanner_GetAllFilenamesFromTagToValue(self, t, valueref)


    def GetMappingFromTagToValue(self, t: 'Tag', value: 'char const *') -> "gdcm::Scanner::TagToValue const &":
        """
        TagToValue const& gdcm::Scanner::GetMappingFromTagToValue(Tag const
        &t, const char *value) const

        See GetFilenameFromTagToValue(). This is simply
        GetFilenameFromTagToValue followed. 
        """
        return _gdcmswig.Scanner_GetMappingFromTagToValue(self, t, value)


    def GetValue(self, filename: 'char const *', t: 'Tag') -> "char const *":
        """
        const char*
        gdcm::Scanner::GetValue(const char *filename, Tag const &t) const

        Retrieve the value found for tag: t associated with file: filename
        This is meant for a single short call. If multiple calls (multiple
        tags) should be done, prefer the GetMapping function, and then reuse
        the TagToValue hash table. WARNING:   Tag 't' should have been added
        via AddTag() prior to the Scan() call ! 
        """
        return _gdcmswig.Scanner_GetValue(self, filename, t)

    if _newclass:
        New = staticmethod(_gdcmswig.Scanner_New)
    else:
        New = _gdcmswig.Scanner_New

    def __str__(self) -> "char const *":
        return _gdcmswig.Scanner___str__(self)
Scanner_swigregister = _gdcmswig.Scanner_swigregister
Scanner_swigregister(Scanner)

def Scanner_New() -> "gdcm::SmartPointer< gdcm::Scanner >":
    return _gdcmswig.Scanner_New()
Scanner_New = _gdcmswig.Scanner_New

class PythonTagToValue(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonTagToValue, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonTagToValue, name)
    __repr__ = _swig_repr

    def __init__(self, t2v: 'gdcm::Scanner::TagToValue const &'):
        this = _gdcmswig.new_PythonTagToValue(t2v)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetCurrent(self) -> "gdcm::Scanner::TagToValueValueType const &":
        return _gdcmswig.PythonTagToValue_GetCurrent(self)

    def GetCurrentTag(self) -> "gdcm::Tag const &":
        return _gdcmswig.PythonTagToValue_GetCurrentTag(self)

    def GetCurrentValue(self) -> "char const *":
        return _gdcmswig.PythonTagToValue_GetCurrentValue(self)

    def Start(self) -> "void":
        return _gdcmswig.PythonTagToValue_Start(self)

    def IsAtEnd(self) -> "bool":
        return _gdcmswig.PythonTagToValue_IsAtEnd(self)

    def Next(self) -> "void":
        return _gdcmswig.PythonTagToValue_Next(self)
    __swig_destroy__ = _gdcmswig.delete_PythonTagToValue
    __del__ = lambda self: None
PythonTagToValue_swigregister = _gdcmswig.PythonTagToValue_swigregister
PythonTagToValue_swigregister(PythonTagToValue)

class SmartPtrStrictScan(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrStrictScan, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrStrictScan, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrStrictScan(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrStrictScan
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::StrictScanner *":
        return _gdcmswig.SmartPtrStrictScan___deref__(self)

    def __ref__(self) -> "gdcm::StrictScanner &":
        return _gdcmswig.SmartPtrStrictScan___ref__(self)

    def GetPointer(self) -> "gdcm::StrictScanner *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrStrictScan_GetPointer(self)


    def AddTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::StrictScanner::AddTag(Tag const &t)

        Add a tag that will need to be read. Those are root level skip tags.

        """
        return _gdcmswig.SmartPtrStrictScan_AddTag(self, t)


    def ClearTags(self) -> "void":
        """
        void
        gdcm::StrictScanner::ClearTags() 
        """
        return _gdcmswig.SmartPtrStrictScan_ClearTags(self)


    def AddPrivateTag(self, t: 'PrivateTag') -> "void":
        """
        void
        gdcm::StrictScanner::AddPrivateTag(PrivateTag const &t) 
        """
        return _gdcmswig.SmartPtrStrictScan_AddPrivateTag(self, t)


    def AddSkipTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::StrictScanner::AddSkipTag(Tag const &t)

        Add a tag that will need to be skipped. Those are root level skip
        tags. 
        """
        return _gdcmswig.SmartPtrStrictScan_AddSkipTag(self, t)


    def ClearSkipTags(self) -> "void":
        """
        void
        gdcm::StrictScanner::ClearSkipTags() 
        """
        return _gdcmswig.SmartPtrStrictScan_ClearSkipTags(self)


    def Scan(self, filenames: 'FilenamesType') -> "bool":
        """
        bool
        gdcm::StrictScanner::Scan(Directory::FilenamesType const &filenames)

        Start the scan ! 
        """
        return _gdcmswig.SmartPtrStrictScan_Scan(self, filenames)


    def GetFilenames(self) -> "gdcm::Directory::FilenamesType const &":
        """
        Directory::FilenamesType const& gdcm::StrictScanner::GetFilenames()
        const 
        """
        return _gdcmswig.SmartPtrStrictScan_GetFilenames(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::StrictScanner::Print(std::ostream &os) const

        Print result. 
        """
        return _gdcmswig.SmartPtrStrictScan_Print(self, os)


    def IsKey(self, filename: 'char const *') -> "bool":
        """
        bool
        gdcm::StrictScanner::IsKey(const char *filename) const

        Check if filename is a key in the Mapping table. returns true only of
        file can be found, which means the file was indeed a DICOM file that
        could be processed 
        """
        return _gdcmswig.SmartPtrStrictScan_IsKey(self, filename)


    def GetKeys(self) -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::StrictScanner::GetKeys() const

        Return the list of filename that are key in the internal map, which
        means those filename were properly parsed 
        """
        return _gdcmswig.SmartPtrStrictScan_GetKeys(self)


    def GetValues(self, *args) -> "gdcm::StrictScanner::ValuesType":
        """
        ValuesType
        gdcm::StrictScanner::GetValues(Tag const &t) const

        Get all the values found (in lexicographic order) associated with Tag
        't'. 
        """
        return _gdcmswig.SmartPtrStrictScan_GetValues(self, *args)


    def GetOrderedValues(self, t: 'Tag') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::StrictScanner::GetOrderedValues(Tag
        const &t) const

        Get all the values found (in a vector) associated with Tag 't' This
        function is identical to GetValues, but is accessible from the wrapped
        layer (python, C#, java) 
        """
        return _gdcmswig.SmartPtrStrictScan_GetOrderedValues(self, t)


    def Begin(self) -> "gdcm::StrictScanner::ConstIterator":
        """
        ConstIterator
        gdcm::StrictScanner::Begin() const 
        """
        return _gdcmswig.SmartPtrStrictScan_Begin(self)


    def End(self) -> "gdcm::StrictScanner::ConstIterator":
        """
        ConstIterator
        gdcm::StrictScanner::End() const 
        """
        return _gdcmswig.SmartPtrStrictScan_End(self)


    def GetMappings(self) -> "gdcm::StrictScanner::MappingType const &":
        """
        MappingType
        const& gdcm::StrictScanner::GetMappings() const

        Mappings are the mapping from a particular tag to the map, mapping
        filename to value: 
        """
        return _gdcmswig.SmartPtrStrictScan_GetMappings(self)


    def GetMapping(self, filename: 'char const *') -> "gdcm::StrictScanner::TagToValue const &":
        """
        TagToValue
        const& gdcm::StrictScanner::GetMapping(const char *filename) const

        Get the std::map mapping filenames to value for file 'filename'. 
        """
        return _gdcmswig.SmartPtrStrictScan_GetMapping(self, filename)


    def GetFilenameFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "char const *":
        """
        const char* gdcm::StrictScanner::GetFilenameFromTagToValue(Tag const
        &t, const char *valueref) const

        Will loop over all files and return the first file where value match
        the reference value 'valueref' 
        """
        return _gdcmswig.SmartPtrStrictScan_GetFilenameFromTagToValue(self, t, valueref)


    def GetAllFilenamesFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType
        gdcm::StrictScanner::GetAllFilenamesFromTagToValue(Tag const &t, const
        char *valueref) const

        Will loop over all files and return a vector of std::strings of
        filenames where value match the reference value 'valueref' 
        """
        return _gdcmswig.SmartPtrStrictScan_GetAllFilenamesFromTagToValue(self, t, valueref)


    def GetMappingFromTagToValue(self, t: 'Tag', value: 'char const *') -> "gdcm::StrictScanner::TagToValue const &":
        """
        TagToValue const& gdcm::StrictScanner::GetMappingFromTagToValue(Tag
        const &t, const char *value) const

        See GetFilenameFromTagToValue(). This is simply
        GetFilenameFromTagToValue followed. 
        """
        return _gdcmswig.SmartPtrStrictScan_GetMappingFromTagToValue(self, t, value)


    def GetValue(self, filename: 'char const *', t: 'Tag') -> "char const *":
        """
        const char*
        gdcm::StrictScanner::GetValue(const char *filename, Tag const &t)
        const

        Retrieve the value found for tag: t associated with file: filename
        This is meant for a single short call. If multiple calls (multiple
        tags) should be done, prefer the GetMapping function, and then reuse
        the TagToValue hash table. WARNING:   Tag 't' should have been added
        via AddTag() prior to the Scan() call ! 
        """
        return _gdcmswig.SmartPtrStrictScan_GetValue(self, filename, t)


    def New(self) -> "gdcm::SmartPointer< gdcm::StrictScanner >":
        return _gdcmswig.SmartPtrStrictScan_New(self)

    def __str__(self) -> "char const *":
        return _gdcmswig.SmartPtrStrictScan___str__(self)

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.SmartPtrStrictScan_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.SmartPtrStrictScan_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.SmartPtrStrictScan_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.SmartPtrStrictScan_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.SmartPtrStrictScan_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.SmartPtrStrictScan_HasObserver(self, event)

SmartPtrStrictScan_swigregister = _gdcmswig.SmartPtrStrictScan_swigregister
SmartPtrStrictScan_swigregister(SmartPtrStrictScan)

class StrictScanner(Subject):
    """


    StrictScanner.

    This filter is meant for quickly browsing a FileSet (a set of files on
    disk). Special consideration are taken so as to read the mimimum
    amount of information in each file in order to retrieve the user
    specified set of DICOM Attribute.

    This filter is dealing with both VRASCII and VRBINARY element, thanks
    to the help of StringFilter

    WARNING:  IMPORTANT In case of file where tags are not ordered
    (illegal as per DICOM specification), the output will be missing
    information

    implementation details. All values are stored in a std::set of
    std::string. Then the address of the cstring underlying the
    std::string is used in the std::map.  This class implement the
    Subject/Observer pattern trigger the following events:  ProgressEvent

    StartEvent

    EndEvent

    C++ includes: gdcmStrictScanner.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, StrictScanner, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, StrictScanner, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::StrictScanner::StrictScanner() """
        this = _gdcmswig.new_StrictScanner()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_StrictScanner
    __del__ = lambda self: None

    def AddTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::StrictScanner::AddTag(Tag const &t)

        Add a tag that will need to be read. Those are root level skip tags.

        """
        return _gdcmswig.StrictScanner_AddTag(self, t)


    def ClearTags(self) -> "void":
        """
        void
        gdcm::StrictScanner::ClearTags() 
        """
        return _gdcmswig.StrictScanner_ClearTags(self)


    def AddPrivateTag(self, t: 'PrivateTag') -> "void":
        """
        void
        gdcm::StrictScanner::AddPrivateTag(PrivateTag const &t) 
        """
        return _gdcmswig.StrictScanner_AddPrivateTag(self, t)


    def AddSkipTag(self, t: 'Tag') -> "void":
        """
        void
        gdcm::StrictScanner::AddSkipTag(Tag const &t)

        Add a tag that will need to be skipped. Those are root level skip
        tags. 
        """
        return _gdcmswig.StrictScanner_AddSkipTag(self, t)


    def ClearSkipTags(self) -> "void":
        """
        void
        gdcm::StrictScanner::ClearSkipTags() 
        """
        return _gdcmswig.StrictScanner_ClearSkipTags(self)


    def Scan(self, filenames: 'FilenamesType') -> "bool":
        """
        bool
        gdcm::StrictScanner::Scan(Directory::FilenamesType const &filenames)

        Start the scan ! 
        """
        return _gdcmswig.StrictScanner_Scan(self, filenames)


    def GetFilenames(self) -> "gdcm::Directory::FilenamesType const &":
        """
        Directory::FilenamesType const& gdcm::StrictScanner::GetFilenames()
        const 
        """
        return _gdcmswig.StrictScanner_GetFilenames(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::StrictScanner::Print(std::ostream &os) const

        Print result. 
        """
        return _gdcmswig.StrictScanner_Print(self, os)


    def IsKey(self, filename: 'char const *') -> "bool":
        """
        bool
        gdcm::StrictScanner::IsKey(const char *filename) const

        Check if filename is a key in the Mapping table. returns true only of
        file can be found, which means the file was indeed a DICOM file that
        could be processed 
        """
        return _gdcmswig.StrictScanner_IsKey(self, filename)


    def GetKeys(self) -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::StrictScanner::GetKeys() const

        Return the list of filename that are key in the internal map, which
        means those filename were properly parsed 
        """
        return _gdcmswig.StrictScanner_GetKeys(self)


    def GetValues(self, *args) -> "gdcm::StrictScanner::ValuesType":
        """
        ValuesType
        gdcm::StrictScanner::GetValues(Tag const &t) const

        Get all the values found (in lexicographic order) associated with Tag
        't'. 
        """
        return _gdcmswig.StrictScanner_GetValues(self, *args)


    def GetOrderedValues(self, t: 'Tag') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType gdcm::StrictScanner::GetOrderedValues(Tag
        const &t) const

        Get all the values found (in a vector) associated with Tag 't' This
        function is identical to GetValues, but is accessible from the wrapped
        layer (python, C#, java) 
        """
        return _gdcmswig.StrictScanner_GetOrderedValues(self, t)


    def Begin(self) -> "gdcm::StrictScanner::ConstIterator":
        """
        ConstIterator
        gdcm::StrictScanner::Begin() const 
        """
        return _gdcmswig.StrictScanner_Begin(self)


    def End(self) -> "gdcm::StrictScanner::ConstIterator":
        """
        ConstIterator
        gdcm::StrictScanner::End() const 
        """
        return _gdcmswig.StrictScanner_End(self)


    def GetMappings(self) -> "gdcm::StrictScanner::MappingType const &":
        """
        MappingType
        const& gdcm::StrictScanner::GetMappings() const

        Mappings are the mapping from a particular tag to the map, mapping
        filename to value: 
        """
        return _gdcmswig.StrictScanner_GetMappings(self)


    def GetMapping(self, filename: 'char const *') -> "gdcm::StrictScanner::TagToValue const &":
        """
        TagToValue
        const& gdcm::StrictScanner::GetMapping(const char *filename) const

        Get the std::map mapping filenames to value for file 'filename'. 
        """
        return _gdcmswig.StrictScanner_GetMapping(self, filename)


    def GetFilenameFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "char const *":
        """
        const char* gdcm::StrictScanner::GetFilenameFromTagToValue(Tag const
        &t, const char *valueref) const

        Will loop over all files and return the first file where value match
        the reference value 'valueref' 
        """
        return _gdcmswig.StrictScanner_GetFilenameFromTagToValue(self, t, valueref)


    def GetAllFilenamesFromTagToValue(self, t: 'Tag', valueref: 'char const *') -> "gdcm::Directory::FilenamesType":
        """
        Directory::FilenamesType
        gdcm::StrictScanner::GetAllFilenamesFromTagToValue(Tag const &t, const
        char *valueref) const

        Will loop over all files and return a vector of std::strings of
        filenames where value match the reference value 'valueref' 
        """
        return _gdcmswig.StrictScanner_GetAllFilenamesFromTagToValue(self, t, valueref)


    def GetMappingFromTagToValue(self, t: 'Tag', value: 'char const *') -> "gdcm::StrictScanner::TagToValue const &":
        """
        TagToValue const& gdcm::StrictScanner::GetMappingFromTagToValue(Tag
        const &t, const char *value) const

        See GetFilenameFromTagToValue(). This is simply
        GetFilenameFromTagToValue followed. 
        """
        return _gdcmswig.StrictScanner_GetMappingFromTagToValue(self, t, value)


    def GetValue(self, filename: 'char const *', t: 'Tag') -> "char const *":
        """
        const char*
        gdcm::StrictScanner::GetValue(const char *filename, Tag const &t)
        const

        Retrieve the value found for tag: t associated with file: filename
        This is meant for a single short call. If multiple calls (multiple
        tags) should be done, prefer the GetMapping function, and then reuse
        the TagToValue hash table. WARNING:   Tag 't' should have been added
        via AddTag() prior to the Scan() call ! 
        """
        return _gdcmswig.StrictScanner_GetValue(self, filename, t)

    if _newclass:
        New = staticmethod(_gdcmswig.StrictScanner_New)
    else:
        New = _gdcmswig.StrictScanner_New

    def __str__(self) -> "char const *":
        return _gdcmswig.StrictScanner___str__(self)
StrictScanner_swigregister = _gdcmswig.StrictScanner_swigregister
StrictScanner_swigregister(StrictScanner)

def StrictScanner_New() -> "gdcm::SmartPointer< gdcm::StrictScanner >":
    return _gdcmswig.StrictScanner_New()
StrictScanner_New = _gdcmswig.StrictScanner_New

class SmartPtrAno(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrAno, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrAno, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrAno(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrAno
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::Anonymizer *":
        return _gdcmswig.SmartPtrAno___deref__(self)

    def __ref__(self) -> "gdcm::Anonymizer &":
        return _gdcmswig.SmartPtrAno___ref__(self)

    def GetPointer(self) -> "gdcm::Anonymizer *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrAno_GetPointer(self)


    def Empty(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Anonymizer::Empty(Tag const &t)

        Make Tag t empty (if not found tag will be created) Warning: does not
        handle SQ element 
        """
        return _gdcmswig.SmartPtrAno_Empty(self, t)


    def Remove(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Anonymizer::Remove(Tag const &t)

        remove a tag (even a SQ can be removed) Return code is false when tag
        t cannot be found 
        """
        return _gdcmswig.SmartPtrAno_Remove(self, t)


    def Replace(self, *args) -> "bool":
        """
        bool
        gdcm::Anonymizer::Replace(Tag const &t, const char *value, VL const
        &vl)

        when the value contains \\0, it is a good idea to specify the
        length. This function is required when dealing with VRBINARY tag 
        """
        return _gdcmswig.SmartPtrAno_Replace(self, *args)


    def RemovePrivateTags(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemovePrivateTags()

        Main function that loop over all elements and remove private tags. 
        """
        return _gdcmswig.SmartPtrAno_RemovePrivateTags(self)


    def RemoveGroupLength(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemoveGroupLength()

        Main function that loop over all elements and remove group length. 
        """
        return _gdcmswig.SmartPtrAno_RemoveGroupLength(self)


    def RemoveRetired(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemoveRetired()

        Main function that loop over all elements and remove retired element.

        """
        return _gdcmswig.SmartPtrAno_RemoveRetired(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::Anonymizer::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.SmartPtrAno_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """
        File&
        gdcm::Anonymizer::GetFile() 
        """
        return _gdcmswig.SmartPtrAno_GetFile(self)


    def BasicApplicationLevelConfidentialityProfile(self, deidentify: 'bool'=True) -> "bool":
        """
        bool
        gdcm::Anonymizer::BasicApplicationLevelConfidentialityProfile(bool
        deidentify=true)

        PS 3.15 / E.1.1 De-Identifier An Application may claim conformance to
        the Basic Application Level Confidentiality Profile as a deidentifier
        if it protects all Attributes that might be used by unauthorized
        entities to identify the patient. NOT THREAD SAFE 
        """
        return _gdcmswig.SmartPtrAno_BasicApplicationLevelConfidentialityProfile(self, deidentify)


    def SetCryptographicMessageSyntax(self, cms: 'CryptographicMessageSyntax') -> "void":
        """
        void
        gdcm::Anonymizer::SetCryptographicMessageSyntax(CryptographicMessageSyntax
        *cms)

        Set/Get CMS key that will be used to encrypt the dataset within
        BasicApplicationLevelConfidentialityProfile. 
        """
        return _gdcmswig.SmartPtrAno_SetCryptographicMessageSyntax(self, cms)


    def GetCryptographicMessageSyntax(self) -> "gdcm::CryptographicMessageSyntax const *":
        """
        const CryptographicMessageSyntax*
        gdcm::Anonymizer::GetCryptographicMessageSyntax() const 
        """
        return _gdcmswig.SmartPtrAno_GetCryptographicMessageSyntax(self)


    def New(self) -> "gdcm::SmartPointer< gdcm::Anonymizer >":
        return _gdcmswig.SmartPtrAno_New(self)

    def GetBasicApplicationLevelConfidentialityProfileAttributes(self) -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        return _gdcmswig.SmartPtrAno_GetBasicApplicationLevelConfidentialityProfileAttributes(self)

    def ClearInternalUIDs(self) -> "void":
        return _gdcmswig.SmartPtrAno_ClearInternalUIDs(self)

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.SmartPtrAno_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.SmartPtrAno_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.SmartPtrAno_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.SmartPtrAno_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.SmartPtrAno_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.SmartPtrAno_HasObserver(self, event)


    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        virtual void
        gdcm::Object::Print(std::ostream &) const 
        """
        return _gdcmswig.SmartPtrAno_Print(self, arg2)

SmartPtrAno_swigregister = _gdcmswig.SmartPtrAno_swigregister
SmartPtrAno_swigregister(SmartPtrAno)

class Anonymizer(Subject):
    """


    Anonymizer.

    This class is a multi purpose anonymizer. It can work in 2 mode: Full
    (irreversible) anonymizer (aka dumb mode)

    reversible de-identifier/re-identifier (aka smart mode). This
    implements the Basic Application Level Confidentiality Profile, DICOM
    PS 3.15-2009

    dumb mode This is a dumb anonymizer implementation. All it allows user
    is simple operation such as:

    Tag based functions: complete removal of DICOM attribute (Remove)

    make a tag empty, ie make it's length 0 (Empty)

    replace with another string-based value (Replace)

    DataSet based functions: Remove all group length attribute from a
    DICOM dataset (Group Length element are deprecated, DICOM 2008)

    Remove all private attributes

    Remove all retired attributes

    All function calls actually execute the user specified request.
    Previous implementation were calling a general Anonymize function but
    traversing a std::set is O(n) operation, while a simple user specified
    request is O(log(n)) operation. So 'm' user interaction is O(m*log(n))
    which is < O(n) complexity.

    smart mode this mode implements the Basic Application Level
    Confidentiality Profile (DICOM PS 3.15-2008) In this case, it is
    extremely important to use the same Anonymizer class when anonymizing
    a FileSet. Once the Anonymizer is destroyed its memory of known
    (already processed) UIDs will be lost. which will make the anonymizer
    behaves incorrectly for attributes such as Series UID Study UID where
    user want some consistency. When attribute is Type 1 / Type 1C, a
    dummy generator will take in the existing value and produce a dummy
    value (a sha1 representation). sha1 algorithm is considered to be
    cryptographically strong (compared to md5sum) so that we meet the
    following two conditions: Produce the same dummy value for the same
    input value

    do not provide an easy way to retrieve the original value from the
    sha1 generated value

    This class implement the Subject/Observer pattern trigger the
    following event:  AnonymizeEvent

    IterationEvent

    StartEvent

    EndEvent

    See:   CryptographicMessageSyntax

    C++ includes: gdcmAnonymizer.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Anonymizer, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Anonymizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Anonymizer::Anonymizer() """
        this = _gdcmswig.new_Anonymizer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Anonymizer
    __del__ = lambda self: None

    def Empty(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Anonymizer::Empty(Tag const &t)

        Make Tag t empty (if not found tag will be created) Warning: does not
        handle SQ element 
        """
        return _gdcmswig.Anonymizer_Empty(self, t)


    def Remove(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::Anonymizer::Remove(Tag const &t)

        remove a tag (even a SQ can be removed) Return code is false when tag
        t cannot be found 
        """
        return _gdcmswig.Anonymizer_Remove(self, t)


    def Replace(self, *args) -> "bool":
        """
        bool
        gdcm::Anonymizer::Replace(Tag const &t, const char *value, VL const
        &vl)

        when the value contains \\0, it is a good idea to specify the
        length. This function is required when dealing with VRBINARY tag 
        """
        return _gdcmswig.Anonymizer_Replace(self, *args)


    def RemovePrivateTags(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemovePrivateTags()

        Main function that loop over all elements and remove private tags. 
        """
        return _gdcmswig.Anonymizer_RemovePrivateTags(self)


    def RemoveGroupLength(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemoveGroupLength()

        Main function that loop over all elements and remove group length. 
        """
        return _gdcmswig.Anonymizer_RemoveGroupLength(self)


    def RemoveRetired(self) -> "bool":
        """
        bool
        gdcm::Anonymizer::RemoveRetired()

        Main function that loop over all elements and remove retired element.

        """
        return _gdcmswig.Anonymizer_RemoveRetired(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::Anonymizer::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.Anonymizer_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """
        File&
        gdcm::Anonymizer::GetFile() 
        """
        return _gdcmswig.Anonymizer_GetFile(self)


    def BasicApplicationLevelConfidentialityProfile(self, deidentify: 'bool'=True) -> "bool":
        """
        bool
        gdcm::Anonymizer::BasicApplicationLevelConfidentialityProfile(bool
        deidentify=true)

        PS 3.15 / E.1.1 De-Identifier An Application may claim conformance to
        the Basic Application Level Confidentiality Profile as a deidentifier
        if it protects all Attributes that might be used by unauthorized
        entities to identify the patient. NOT THREAD SAFE 
        """
        return _gdcmswig.Anonymizer_BasicApplicationLevelConfidentialityProfile(self, deidentify)


    def SetCryptographicMessageSyntax(self, cms: 'CryptographicMessageSyntax') -> "void":
        """
        void
        gdcm::Anonymizer::SetCryptographicMessageSyntax(CryptographicMessageSyntax
        *cms)

        Set/Get CMS key that will be used to encrypt the dataset within
        BasicApplicationLevelConfidentialityProfile. 
        """
        return _gdcmswig.Anonymizer_SetCryptographicMessageSyntax(self, cms)


    def GetCryptographicMessageSyntax(self) -> "gdcm::CryptographicMessageSyntax const *":
        """
        const CryptographicMessageSyntax*
        gdcm::Anonymizer::GetCryptographicMessageSyntax() const 
        """
        return _gdcmswig.Anonymizer_GetCryptographicMessageSyntax(self)

    if _newclass:
        New = staticmethod(_gdcmswig.Anonymizer_New)
    else:
        New = _gdcmswig.Anonymizer_New
    if _newclass:
        GetBasicApplicationLevelConfidentialityProfileAttributes = staticmethod(_gdcmswig.Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes)
    else:
        GetBasicApplicationLevelConfidentialityProfileAttributes = _gdcmswig.Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes
    if _newclass:
        ClearInternalUIDs = staticmethod(_gdcmswig.Anonymizer_ClearInternalUIDs)
    else:
        ClearInternalUIDs = _gdcmswig.Anonymizer_ClearInternalUIDs
Anonymizer_swigregister = _gdcmswig.Anonymizer_swigregister
Anonymizer_swigregister(Anonymizer)

def Anonymizer_New() -> "gdcm::SmartPointer< gdcm::Anonymizer >":
    return _gdcmswig.Anonymizer_New()
Anonymizer_New = _gdcmswig.Anonymizer_New

def Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes() -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
    return _gdcmswig.Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes()
Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes = _gdcmswig.Anonymizer_GetBasicApplicationLevelConfidentialityProfileAttributes

def Anonymizer_ClearInternalUIDs() -> "void":
    return _gdcmswig.Anonymizer_ClearInternalUIDs()
Anonymizer_ClearInternalUIDs = _gdcmswig.Anonymizer_ClearInternalUIDs

class FileAnonymizer(Subject):
    """


    FileAnonymizer.

    This Anonymizer is a file-based Anonymizer. It requires a valid DICOM
    file and will use the Value Length to skip over any information.

    It will not load the DICOM dataset taken from SetInputFileName() into
    memory and should consume much less memory than Anonymizer.

    WARNING:  : Each time you call Replace() with a value. This value will
    copied, and stored in memory. The behavior is not ideal for extremely
    large data (larger than memory size). This class is really meant to
    take a large DICOM input file and then only changed some small
    attribute.  caveats: This class will NOT work with unordered
    attributes in a DICOM File,

    This class does neither recompute nor update the Group Length element,

    This class currently does not update the File Meta Information header.

    Only strict inplace Replace operation is supported when input and
    output file are the same.

    C++ includes: gdcmFileAnonymizer.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileAnonymizer, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileAnonymizer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileAnonymizer::FileAnonymizer() """
        this = _gdcmswig.new_FileAnonymizer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileAnonymizer
    __del__ = lambda self: None

    def Empty(self, t: 'Tag') -> "void":
        """
        void
        gdcm::FileAnonymizer::Empty(Tag const &t)

        Make Tag t empty Warning: does not handle SQ element 
        """
        return _gdcmswig.FileAnonymizer_Empty(self, t)


    def Remove(self, t: 'Tag') -> "void":
        """
        void
        gdcm::FileAnonymizer::Remove(Tag const &t)

        remove a tag (even a SQ can be removed) 
        """
        return _gdcmswig.FileAnonymizer_Remove(self, t)


    def Replace(self, *args) -> "void":
        """
        void
        gdcm::FileAnonymizer::Replace(Tag const &t, const char *value_data, VL
        const &vl)

        when the value contains \\0, it is a good idea to specify the
        length. This function is required when dealing with VRBINARY tag 
        """
        return _gdcmswig.FileAnonymizer_Replace(self, *args)


    def SetInputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileAnonymizer::SetInputFileName(const char *filename_native)

        Set input filename. 
        """
        return _gdcmswig.FileAnonymizer_SetInputFileName(self, filename_native)


    def SetOutputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileAnonymizer::SetOutputFileName(const char *filename_native)

        Set output filename. 
        """
        return _gdcmswig.FileAnonymizer_SetOutputFileName(self, filename_native)


    def Write(self) -> "bool":
        """
        bool
        gdcm::FileAnonymizer::Write()

        Write the output file. 
        """
        return _gdcmswig.FileAnonymizer_Write(self)

FileAnonymizer_swigregister = _gdcmswig.FileAnonymizer_swigregister
FileAnonymizer_swigregister(FileAnonymizer)

class SmartPtrFStreamer(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrFStreamer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrFStreamer, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrFStreamer(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrFStreamer
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::FileStreamer *":
        return _gdcmswig.SmartPtrFStreamer___deref__(self)

    def __ref__(self) -> "gdcm::FileStreamer &":
        return _gdcmswig.SmartPtrFStreamer___ref__(self)

    def GetPointer(self) -> "gdcm::FileStreamer *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrFStreamer_GetPointer(self)


    def SetTemplateFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileStreamer::SetTemplateFileName(const char *filename_native)

        Set input DICOM template filename. 
        """
        return _gdcmswig.SmartPtrFStreamer_SetTemplateFileName(self, filename_native)


    def CheckTemplateFileName(self, check: 'bool') -> "void":
        """
        void gdcm::FileStreamer::CheckTemplateFileName(bool check)

        Instead of simply blindly copying the input DICOM Template file, GDCM
        will be used to check the input file, and correct any issues
        recognized within the file. Only use if you do not have control over
        the input template file. 
        """
        return _gdcmswig.SmartPtrFStreamer_CheckTemplateFileName(self, check)


    def SetOutputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileStreamer::SetOutputFileName(const char *filename_native)

        Set output filename (target file) 
        """
        return _gdcmswig.SmartPtrFStreamer_SetOutputFileName(self, filename_native)


    def CheckDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::CheckDataElement(const Tag &t)

        Decide to check the Data Element to be written (default: off) The
        implementation has default strategy for checking validity of
        DataElement. Currently it only support checking for the following
        tags: (7fe0,0010) Pixel Data 
        """
        return _gdcmswig.SmartPtrFStreamer_CheckDataElement(self, t)


    def StartDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StartDataElement(const Tag &t)

        Start Single Data Element Operation This will delete any existing Tag
        t. Need to call it only once. 
        """
        return _gdcmswig.SmartPtrFStreamer_StartDataElement(self, t)


    def AppendToDataElement(self, t: 'Tag', array: 'char const *', len: 'size_t') -> "bool":
        """
        bool
        gdcm::FileStreamer::AppendToDataElement(const Tag &t, const char
        *array, size_t len)

        Append to previously started Tag t. 
        """
        return _gdcmswig.SmartPtrFStreamer_AppendToDataElement(self, t, array, len)


    def StopDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StopDataElement(const Tag &t)

        Stop appending to tag t. This will compute the proper attribute
        length. 
        """
        return _gdcmswig.SmartPtrFStreamer_StopDataElement(self, t)


    def ReserveDataElement(self, len: 'size_t') -> "bool":
        """
        bool
        gdcm::FileStreamer::ReserveDataElement(size_t len)

        Add a hint on the final size of the dataelement. When optimally
        chosen, this reduce the number of file in-place copying. Should be
        called before StartDataElement 
        """
        return _gdcmswig.SmartPtrFStreamer_ReserveDataElement(self, len)


    def StartGroupDataElement(self, pt: 'PrivateTag', maxsizede: 'size_t'=0, startoffset: 'uint8_t'=0) -> "bool":
        """
        bool gdcm::FileStreamer::StartGroupDataElement(const PrivateTag &pt,
        size_t maxsizede=0, uint8_t startoffset=0)

        Start Private Group (multiple DataElement) Operation. Each newly added
        DataElement will have a length lower than

        Parameters:
        -----------

        maxsizede:  . When not specified, maxsizede is set to maximum size
        allowed by DICOM (= 2^32). startoffset can be used to specify the very
        first element you want to start with (instead of the first possible).
        Value should be in [0x0, 0xff] This will find the first available
        private creator. 
        """
        return _gdcmswig.SmartPtrFStreamer_StartGroupDataElement(self, pt, maxsizede, startoffset)


    def AppendToGroupDataElement(self, pt: 'PrivateTag', array: 'char const *', len: 'size_t') -> "bool":
        """
        bool gdcm::FileStreamer::AppendToGroupDataElement(const PrivateTag
        &pt, const char *array, size_t len)

        Append to previously started private creator. 
        """
        return _gdcmswig.SmartPtrFStreamer_AppendToGroupDataElement(self, pt, array, len)


    def StopGroupDataElement(self, pt: 'PrivateTag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StopGroupDataElement(const PrivateTag &pt)

        Stop appending to private creator. 
        """
        return _gdcmswig.SmartPtrFStreamer_StopGroupDataElement(self, pt)


    def ReserveGroupDataElement(self, ndataelement: 'unsigned short') -> "bool":
        """
        bool gdcm::FileStreamer::ReserveGroupDataElement(unsigned short
        ndataelement)

        Optimisation: pre-allocate the number of dataelement within the
        private group (ndataelement <= 256). Should be called before
        StartGroupDataElement 
        """
        return _gdcmswig.SmartPtrFStreamer_ReserveGroupDataElement(self, ndataelement)


    def New(self) -> "gdcm::SmartPointer< gdcm::FileStreamer >":
        return _gdcmswig.SmartPtrFStreamer_New(self)

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.SmartPtrFStreamer_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.SmartPtrFStreamer_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.SmartPtrFStreamer_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.SmartPtrFStreamer_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.SmartPtrFStreamer_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.SmartPtrFStreamer_HasObserver(self, event)


    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        virtual void
        gdcm::Object::Print(std::ostream &) const 
        """
        return _gdcmswig.SmartPtrFStreamer_Print(self, arg2)

SmartPtrFStreamer_swigregister = _gdcmswig.SmartPtrFStreamer_swigregister
SmartPtrFStreamer_swigregister(SmartPtrFStreamer)

class FileStreamer(Subject):
    """


    FileStreamer.

    This class let a user create a massive DICOM DataSet from a template
    DICOM file, by appending chunks of data.

    This class support two mode of operation: Creating a single
    DataElement by appending chunk after chunk of data.

    Creating a set of DataElement within the same group, using a private
    creator for start. New DataElement are added any time the user defined
    maximum size for data element is reached.

    WARNING:  any existing DataElement is removed, pick carefully which
    DataElement to add.

    C++ includes: gdcmFileStreamer.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileStreamer, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileStreamer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileStreamer::FileStreamer() """
        this = _gdcmswig.new_FileStreamer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileStreamer
    __del__ = lambda self: None

    def SetTemplateFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileStreamer::SetTemplateFileName(const char *filename_native)

        Set input DICOM template filename. 
        """
        return _gdcmswig.FileStreamer_SetTemplateFileName(self, filename_native)


    def CheckTemplateFileName(self, check: 'bool') -> "void":
        """
        void gdcm::FileStreamer::CheckTemplateFileName(bool check)

        Instead of simply blindly copying the input DICOM Template file, GDCM
        will be used to check the input file, and correct any issues
        recognized within the file. Only use if you do not have control over
        the input template file. 
        """
        return _gdcmswig.FileStreamer_CheckTemplateFileName(self, check)


    def SetOutputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileStreamer::SetOutputFileName(const char *filename_native)

        Set output filename (target file) 
        """
        return _gdcmswig.FileStreamer_SetOutputFileName(self, filename_native)


    def CheckDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::CheckDataElement(const Tag &t)

        Decide to check the Data Element to be written (default: off) The
        implementation has default strategy for checking validity of
        DataElement. Currently it only support checking for the following
        tags: (7fe0,0010) Pixel Data 
        """
        return _gdcmswig.FileStreamer_CheckDataElement(self, t)


    def StartDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StartDataElement(const Tag &t)

        Start Single Data Element Operation This will delete any existing Tag
        t. Need to call it only once. 
        """
        return _gdcmswig.FileStreamer_StartDataElement(self, t)


    def AppendToDataElement(self, t: 'Tag', array: 'char const *', len: 'size_t') -> "bool":
        """
        bool
        gdcm::FileStreamer::AppendToDataElement(const Tag &t, const char
        *array, size_t len)

        Append to previously started Tag t. 
        """
        return _gdcmswig.FileStreamer_AppendToDataElement(self, t, array, len)


    def StopDataElement(self, t: 'Tag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StopDataElement(const Tag &t)

        Stop appending to tag t. This will compute the proper attribute
        length. 
        """
        return _gdcmswig.FileStreamer_StopDataElement(self, t)


    def ReserveDataElement(self, len: 'size_t') -> "bool":
        """
        bool
        gdcm::FileStreamer::ReserveDataElement(size_t len)

        Add a hint on the final size of the dataelement. When optimally
        chosen, this reduce the number of file in-place copying. Should be
        called before StartDataElement 
        """
        return _gdcmswig.FileStreamer_ReserveDataElement(self, len)


    def StartGroupDataElement(self, pt: 'PrivateTag', maxsizede: 'size_t'=0, startoffset: 'uint8_t'=0) -> "bool":
        """
        bool gdcm::FileStreamer::StartGroupDataElement(const PrivateTag &pt,
        size_t maxsizede=0, uint8_t startoffset=0)

        Start Private Group (multiple DataElement) Operation. Each newly added
        DataElement will have a length lower than

        Parameters:
        -----------

        maxsizede:  . When not specified, maxsizede is set to maximum size
        allowed by DICOM (= 2^32). startoffset can be used to specify the very
        first element you want to start with (instead of the first possible).
        Value should be in [0x0, 0xff] This will find the first available
        private creator. 
        """
        return _gdcmswig.FileStreamer_StartGroupDataElement(self, pt, maxsizede, startoffset)


    def AppendToGroupDataElement(self, pt: 'PrivateTag', array: 'char const *', len: 'size_t') -> "bool":
        """
        bool gdcm::FileStreamer::AppendToGroupDataElement(const PrivateTag
        &pt, const char *array, size_t len)

        Append to previously started private creator. 
        """
        return _gdcmswig.FileStreamer_AppendToGroupDataElement(self, pt, array, len)


    def StopGroupDataElement(self, pt: 'PrivateTag') -> "bool":
        """
        bool
        gdcm::FileStreamer::StopGroupDataElement(const PrivateTag &pt)

        Stop appending to private creator. 
        """
        return _gdcmswig.FileStreamer_StopGroupDataElement(self, pt)


    def ReserveGroupDataElement(self, ndataelement: 'unsigned short') -> "bool":
        """
        bool gdcm::FileStreamer::ReserveGroupDataElement(unsigned short
        ndataelement)

        Optimisation: pre-allocate the number of dataelement within the
        private group (ndataelement <= 256). Should be called before
        StartGroupDataElement 
        """
        return _gdcmswig.FileStreamer_ReserveGroupDataElement(self, ndataelement)

    if _newclass:
        New = staticmethod(_gdcmswig.FileStreamer_New)
    else:
        New = _gdcmswig.FileStreamer_New
FileStreamer_swigregister = _gdcmswig.FileStreamer_swigregister
FileStreamer_swigregister(FileStreamer)

def FileStreamer_New() -> "gdcm::SmartPointer< gdcm::FileStreamer >":
    return _gdcmswig.FileStreamer_New()
FileStreamer_New = _gdcmswig.FileStreamer_New

class System(_object):
    """


    Class to do system operation.

    OS independent functionalities

    C++ includes: gdcmSystem.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, System, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, System, name)
    __repr__ = _swig_repr
    if _newclass:
        MakeDirectory = staticmethod(_gdcmswig.System_MakeDirectory)
    else:
        MakeDirectory = _gdcmswig.System_MakeDirectory
    if _newclass:
        FileExists = staticmethod(_gdcmswig.System_FileExists)
    else:
        FileExists = _gdcmswig.System_FileExists
    if _newclass:
        FileIsDirectory = staticmethod(_gdcmswig.System_FileIsDirectory)
    else:
        FileIsDirectory = _gdcmswig.System_FileIsDirectory
    if _newclass:
        FileIsSymlink = staticmethod(_gdcmswig.System_FileIsSymlink)
    else:
        FileIsSymlink = _gdcmswig.System_FileIsSymlink
    if _newclass:
        RemoveFile = staticmethod(_gdcmswig.System_RemoveFile)
    else:
        RemoveFile = _gdcmswig.System_RemoveFile
    if _newclass:
        DeleteDirectory = staticmethod(_gdcmswig.System_DeleteDirectory)
    else:
        DeleteDirectory = _gdcmswig.System_DeleteDirectory
    if _newclass:
        GetLastSystemError = staticmethod(_gdcmswig.System_GetLastSystemError)
    else:
        GetLastSystemError = _gdcmswig.System_GetLastSystemError
    if _newclass:
        FileSize = staticmethod(_gdcmswig.System_FileSize)
    else:
        FileSize = _gdcmswig.System_FileSize
    if _newclass:
        FileTime = staticmethod(_gdcmswig.System_FileTime)
    else:
        FileTime = _gdcmswig.System_FileTime
    if _newclass:
        GetCurrentProcessFileName = staticmethod(_gdcmswig.System_GetCurrentProcessFileName)
    else:
        GetCurrentProcessFileName = _gdcmswig.System_GetCurrentProcessFileName
    if _newclass:
        GetCurrentModuleFileName = staticmethod(_gdcmswig.System_GetCurrentModuleFileName)
    else:
        GetCurrentModuleFileName = _gdcmswig.System_GetCurrentModuleFileName
    if _newclass:
        GetCurrentResourcesDirectory = staticmethod(_gdcmswig.System_GetCurrentResourcesDirectory)
    else:
        GetCurrentResourcesDirectory = _gdcmswig.System_GetCurrentResourcesDirectory
    if _newclass:
        GetHostName = staticmethod(_gdcmswig.System_GetHostName)
    else:
        GetHostName = _gdcmswig.System_GetHostName
    if _newclass:
        GetCurrentDateTime = staticmethod(_gdcmswig.System_GetCurrentDateTime)
    else:
        GetCurrentDateTime = _gdcmswig.System_GetCurrentDateTime
    if _newclass:
        FormatDateTime = staticmethod(_gdcmswig.System_FormatDateTime)
    else:
        FormatDateTime = _gdcmswig.System_FormatDateTime
    if _newclass:
        ParseDateTime = staticmethod(_gdcmswig.System_ParseDateTime)
    else:
        ParseDateTime = _gdcmswig.System_ParseDateTime
    if _newclass:
        GetTimezoneOffsetFromUTC = staticmethod(_gdcmswig.System_GetTimezoneOffsetFromUTC)
    else:
        GetTimezoneOffsetFromUTC = _gdcmswig.System_GetTimezoneOffsetFromUTC
    if _newclass:
        EncodeBytes = staticmethod(_gdcmswig.System_EncodeBytes)
    else:
        EncodeBytes = _gdcmswig.System_EncodeBytes
    if _newclass:
        StrCaseCmp = staticmethod(_gdcmswig.System_StrCaseCmp)
    else:
        StrCaseCmp = _gdcmswig.System_StrCaseCmp
    if _newclass:
        StrNCaseCmp = staticmethod(_gdcmswig.System_StrNCaseCmp)
    else:
        StrNCaseCmp = _gdcmswig.System_StrNCaseCmp
    if _newclass:
        GetCWD = staticmethod(_gdcmswig.System_GetCWD)
    else:
        GetCWD = _gdcmswig.System_GetCWD
    if _newclass:
        StrTokR = staticmethod(_gdcmswig.System_StrTokR)
    else:
        StrTokR = _gdcmswig.System_StrTokR
    if _newclass:
        StrSep = staticmethod(_gdcmswig.System_StrSep)
    else:
        StrSep = _gdcmswig.System_StrSep
    if _newclass:
        GetLocaleCharset = staticmethod(_gdcmswig.System_GetLocaleCharset)
    else:
        GetLocaleCharset = _gdcmswig.System_GetLocaleCharset

    def __init__(self):
        this = _gdcmswig.new_System()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_System
    __del__ = lambda self: None
System_swigregister = _gdcmswig.System_swigregister
System_swigregister(System)

def System_MakeDirectory(path: 'char const *') -> "bool":
    return _gdcmswig.System_MakeDirectory(path)
System_MakeDirectory = _gdcmswig.System_MakeDirectory

def System_FileExists(filename: 'char const *') -> "bool":
    return _gdcmswig.System_FileExists(filename)
System_FileExists = _gdcmswig.System_FileExists

def System_FileIsDirectory(name: 'char const *') -> "bool":
    return _gdcmswig.System_FileIsDirectory(name)
System_FileIsDirectory = _gdcmswig.System_FileIsDirectory

def System_FileIsSymlink(name: 'char const *') -> "bool":
    return _gdcmswig.System_FileIsSymlink(name)
System_FileIsSymlink = _gdcmswig.System_FileIsSymlink

def System_RemoveFile(source: 'char const *') -> "bool":
    return _gdcmswig.System_RemoveFile(source)
System_RemoveFile = _gdcmswig.System_RemoveFile

def System_DeleteDirectory(source: 'char const *') -> "bool":
    return _gdcmswig.System_DeleteDirectory(source)
System_DeleteDirectory = _gdcmswig.System_DeleteDirectory

def System_GetLastSystemError() -> "char const *":
    return _gdcmswig.System_GetLastSystemError()
System_GetLastSystemError = _gdcmswig.System_GetLastSystemError

def System_FileSize(filename: 'char const *') -> "size_t":
    return _gdcmswig.System_FileSize(filename)
System_FileSize = _gdcmswig.System_FileSize

def System_FileTime(filename: 'char const *') -> "time_t":
    return _gdcmswig.System_FileTime(filename)
System_FileTime = _gdcmswig.System_FileTime

def System_GetCurrentProcessFileName() -> "char const *":
    return _gdcmswig.System_GetCurrentProcessFileName()
System_GetCurrentProcessFileName = _gdcmswig.System_GetCurrentProcessFileName

def System_GetCurrentModuleFileName() -> "char const *":
    return _gdcmswig.System_GetCurrentModuleFileName()
System_GetCurrentModuleFileName = _gdcmswig.System_GetCurrentModuleFileName

def System_GetCurrentResourcesDirectory() -> "char const *":
    return _gdcmswig.System_GetCurrentResourcesDirectory()
System_GetCurrentResourcesDirectory = _gdcmswig.System_GetCurrentResourcesDirectory

def System_GetHostName(hostname: 'char [255]') -> "bool":
    return _gdcmswig.System_GetHostName(hostname)
System_GetHostName = _gdcmswig.System_GetHostName

def System_GetCurrentDateTime(date: 'char [22]') -> "bool":
    return _gdcmswig.System_GetCurrentDateTime(date)
System_GetCurrentDateTime = _gdcmswig.System_GetCurrentDateTime

def System_FormatDateTime(date: 'char [22]', t: 'time_t', milliseconds: 'long'=0) -> "bool":
    return _gdcmswig.System_FormatDateTime(date, t, milliseconds)
System_FormatDateTime = _gdcmswig.System_FormatDateTime

def System_ParseDateTime(*args) -> "bool":
    return _gdcmswig.System_ParseDateTime(*args)
System_ParseDateTime = _gdcmswig.System_ParseDateTime

def System_GetTimezoneOffsetFromUTC() -> "char const *":
    return _gdcmswig.System_GetTimezoneOffsetFromUTC()
System_GetTimezoneOffsetFromUTC = _gdcmswig.System_GetTimezoneOffsetFromUTC

def System_EncodeBytes(out: 'char *', data: 'unsigned char const *', size: 'int') -> "size_t":
    return _gdcmswig.System_EncodeBytes(out, data, size)
System_EncodeBytes = _gdcmswig.System_EncodeBytes

def System_StrCaseCmp(s1: 'char const *', s2: 'char const *') -> "int":
    return _gdcmswig.System_StrCaseCmp(s1, s2)
System_StrCaseCmp = _gdcmswig.System_StrCaseCmp

def System_StrNCaseCmp(s1: 'char const *', s2: 'char const *', n: 'size_t') -> "int":
    return _gdcmswig.System_StrNCaseCmp(s1, s2, n)
System_StrNCaseCmp = _gdcmswig.System_StrNCaseCmp

def System_GetCWD() -> "char const *":
    return _gdcmswig.System_GetCWD()
System_GetCWD = _gdcmswig.System_GetCWD

def System_StrTokR(ptr: 'char *', sep: 'char const *', end: 'char **') -> "char *":
    return _gdcmswig.System_StrTokR(ptr, sep, end)
System_StrTokR = _gdcmswig.System_StrTokR

def System_StrSep(stringp: 'char **', delim: 'char const *') -> "char *":
    return _gdcmswig.System_StrSep(stringp, delim)
System_StrSep = _gdcmswig.System_StrSep

def System_GetLocaleCharset() -> "char const *":
    return _gdcmswig.System_GetLocaleCharset()
System_GetLocaleCharset = _gdcmswig.System_GetLocaleCharset

class Trace(_object):
    """


    Trace.

    Debug / Warning and Error are encapsulated in this class by default
    the Trace class will redirect any debug/warning/error to std::cerr.
    Unless SetStream was specified with another (open) stream or
    SetStreamToFile was specified to a writable file on the system.

    WARNING:  All string messages are removed during compilation time when
    compiled with CMAKE_BUILD_TYPE being set to either: Release

    MinSizeRel It is recommended to compile with RelWithDebInfo and/or
    Debug during prototyping of applications.

    C++ includes: gdcmTrace.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Trace, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Trace, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Trace::Trace() """
        this = _gdcmswig.new_Trace()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Trace
    __del__ = lambda self: None
    if _newclass:
        SetStream = staticmethod(_gdcmswig.Trace_SetStream)
    else:
        SetStream = _gdcmswig.Trace_SetStream
    if _newclass:
        GetStream = staticmethod(_gdcmswig.Trace_GetStream)
    else:
        GetStream = _gdcmswig.Trace_GetStream
    if _newclass:
        SetDebugStream = staticmethod(_gdcmswig.Trace_SetDebugStream)
    else:
        SetDebugStream = _gdcmswig.Trace_SetDebugStream
    if _newclass:
        GetDebugStream = staticmethod(_gdcmswig.Trace_GetDebugStream)
    else:
        GetDebugStream = _gdcmswig.Trace_GetDebugStream
    if _newclass:
        SetWarningStream = staticmethod(_gdcmswig.Trace_SetWarningStream)
    else:
        SetWarningStream = _gdcmswig.Trace_SetWarningStream
    if _newclass:
        GetWarningStream = staticmethod(_gdcmswig.Trace_GetWarningStream)
    else:
        GetWarningStream = _gdcmswig.Trace_GetWarningStream
    if _newclass:
        SetErrorStream = staticmethod(_gdcmswig.Trace_SetErrorStream)
    else:
        SetErrorStream = _gdcmswig.Trace_SetErrorStream
    if _newclass:
        GetErrorStream = staticmethod(_gdcmswig.Trace_GetErrorStream)
    else:
        GetErrorStream = _gdcmswig.Trace_GetErrorStream
    if _newclass:
        SetStreamToFile = staticmethod(_gdcmswig.Trace_SetStreamToFile)
    else:
        SetStreamToFile = _gdcmswig.Trace_SetStreamToFile
    if _newclass:
        SetDebug = staticmethod(_gdcmswig.Trace_SetDebug)
    else:
        SetDebug = _gdcmswig.Trace_SetDebug
    if _newclass:
        DebugOn = staticmethod(_gdcmswig.Trace_DebugOn)
    else:
        DebugOn = _gdcmswig.Trace_DebugOn
    if _newclass:
        DebugOff = staticmethod(_gdcmswig.Trace_DebugOff)
    else:
        DebugOff = _gdcmswig.Trace_DebugOff
    if _newclass:
        GetDebugFlag = staticmethod(_gdcmswig.Trace_GetDebugFlag)
    else:
        GetDebugFlag = _gdcmswig.Trace_GetDebugFlag
    if _newclass:
        SetWarning = staticmethod(_gdcmswig.Trace_SetWarning)
    else:
        SetWarning = _gdcmswig.Trace_SetWarning
    if _newclass:
        WarningOn = staticmethod(_gdcmswig.Trace_WarningOn)
    else:
        WarningOn = _gdcmswig.Trace_WarningOn
    if _newclass:
        WarningOff = staticmethod(_gdcmswig.Trace_WarningOff)
    else:
        WarningOff = _gdcmswig.Trace_WarningOff
    if _newclass:
        GetWarningFlag = staticmethod(_gdcmswig.Trace_GetWarningFlag)
    else:
        GetWarningFlag = _gdcmswig.Trace_GetWarningFlag
    if _newclass:
        SetError = staticmethod(_gdcmswig.Trace_SetError)
    else:
        SetError = _gdcmswig.Trace_SetError
    if _newclass:
        ErrorOn = staticmethod(_gdcmswig.Trace_ErrorOn)
    else:
        ErrorOn = _gdcmswig.Trace_ErrorOn
    if _newclass:
        ErrorOff = staticmethod(_gdcmswig.Trace_ErrorOff)
    else:
        ErrorOff = _gdcmswig.Trace_ErrorOff
    if _newclass:
        GetErrorFlag = staticmethod(_gdcmswig.Trace_GetErrorFlag)
    else:
        GetErrorFlag = _gdcmswig.Trace_GetErrorFlag
Trace_swigregister = _gdcmswig.Trace_swigregister
Trace_swigregister(Trace)

def Trace_SetStream(os: 'std::ostream &') -> "void":
    return _gdcmswig.Trace_SetStream(os)
Trace_SetStream = _gdcmswig.Trace_SetStream

def Trace_GetStream() -> "std::ostream &":
    return _gdcmswig.Trace_GetStream()
Trace_GetStream = _gdcmswig.Trace_GetStream

def Trace_SetDebugStream(os: 'std::ostream &') -> "void":
    return _gdcmswig.Trace_SetDebugStream(os)
Trace_SetDebugStream = _gdcmswig.Trace_SetDebugStream

def Trace_GetDebugStream() -> "std::ostream &":
    return _gdcmswig.Trace_GetDebugStream()
Trace_GetDebugStream = _gdcmswig.Trace_GetDebugStream

def Trace_SetWarningStream(os: 'std::ostream &') -> "void":
    return _gdcmswig.Trace_SetWarningStream(os)
Trace_SetWarningStream = _gdcmswig.Trace_SetWarningStream

def Trace_GetWarningStream() -> "std::ostream &":
    return _gdcmswig.Trace_GetWarningStream()
Trace_GetWarningStream = _gdcmswig.Trace_GetWarningStream

def Trace_SetErrorStream(os: 'std::ostream &') -> "void":
    return _gdcmswig.Trace_SetErrorStream(os)
Trace_SetErrorStream = _gdcmswig.Trace_SetErrorStream

def Trace_GetErrorStream() -> "std::ostream &":
    return _gdcmswig.Trace_GetErrorStream()
Trace_GetErrorStream = _gdcmswig.Trace_GetErrorStream

def Trace_SetStreamToFile(filename: 'char const *') -> "void":
    return _gdcmswig.Trace_SetStreamToFile(filename)
Trace_SetStreamToFile = _gdcmswig.Trace_SetStreamToFile

def Trace_SetDebug(debug: 'bool') -> "void":
    return _gdcmswig.Trace_SetDebug(debug)
Trace_SetDebug = _gdcmswig.Trace_SetDebug

def Trace_DebugOn() -> "void":
    return _gdcmswig.Trace_DebugOn()
Trace_DebugOn = _gdcmswig.Trace_DebugOn

def Trace_DebugOff() -> "void":
    return _gdcmswig.Trace_DebugOff()
Trace_DebugOff = _gdcmswig.Trace_DebugOff

def Trace_GetDebugFlag() -> "bool":
    return _gdcmswig.Trace_GetDebugFlag()
Trace_GetDebugFlag = _gdcmswig.Trace_GetDebugFlag

def Trace_SetWarning(debug: 'bool') -> "void":
    return _gdcmswig.Trace_SetWarning(debug)
Trace_SetWarning = _gdcmswig.Trace_SetWarning

def Trace_WarningOn() -> "void":
    return _gdcmswig.Trace_WarningOn()
Trace_WarningOn = _gdcmswig.Trace_WarningOn

def Trace_WarningOff() -> "void":
    return _gdcmswig.Trace_WarningOff()
Trace_WarningOff = _gdcmswig.Trace_WarningOff

def Trace_GetWarningFlag() -> "bool":
    return _gdcmswig.Trace_GetWarningFlag()
Trace_GetWarningFlag = _gdcmswig.Trace_GetWarningFlag

def Trace_SetError(debug: 'bool') -> "void":
    return _gdcmswig.Trace_SetError(debug)
Trace_SetError = _gdcmswig.Trace_SetError

def Trace_ErrorOn() -> "void":
    return _gdcmswig.Trace_ErrorOn()
Trace_ErrorOn = _gdcmswig.Trace_ErrorOn

def Trace_ErrorOff() -> "void":
    return _gdcmswig.Trace_ErrorOff()
Trace_ErrorOff = _gdcmswig.Trace_ErrorOff

def Trace_GetErrorFlag() -> "bool":
    return _gdcmswig.Trace_GetErrorFlag()
Trace_GetErrorFlag = _gdcmswig.Trace_GetErrorFlag

class UIDs(_object):
    """


    all known uids

    C++ includes: gdcmUIDs.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIDs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UIDs, name)
    __repr__ = _swig_repr
    uid_1_2_840_10008_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_1
    uid_1_2_840_10008_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2
    uid_1_2_840_10008_1_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_1
    uid_1_2_840_10008_1_2_1_99 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_1_99
    uid_1_2_840_10008_1_2_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_2
    uid_1_2_840_10008_1_2_4_50 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_50
    uid_1_2_840_10008_1_2_4_51 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_51
    uid_1_2_840_10008_1_2_4_52 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_52
    uid_1_2_840_10008_1_2_4_53 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_53
    uid_1_2_840_10008_1_2_4_54 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_54
    uid_1_2_840_10008_1_2_4_55 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_55
    uid_1_2_840_10008_1_2_4_56 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_56
    uid_1_2_840_10008_1_2_4_57 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_57
    uid_1_2_840_10008_1_2_4_58 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_58
    uid_1_2_840_10008_1_2_4_59 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_59
    uid_1_2_840_10008_1_2_4_60 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_60
    uid_1_2_840_10008_1_2_4_61 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_61
    uid_1_2_840_10008_1_2_4_62 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_62
    uid_1_2_840_10008_1_2_4_63 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_63
    uid_1_2_840_10008_1_2_4_64 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_64
    uid_1_2_840_10008_1_2_4_65 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_65
    uid_1_2_840_10008_1_2_4_66 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_66
    uid_1_2_840_10008_1_2_4_70 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_70
    uid_1_2_840_10008_1_2_4_80 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_80
    uid_1_2_840_10008_1_2_4_81 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_81
    uid_1_2_840_10008_1_2_4_90 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_90
    uid_1_2_840_10008_1_2_4_91 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_91
    uid_1_2_840_10008_1_2_4_92 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_92
    uid_1_2_840_10008_1_2_4_93 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_93
    uid_1_2_840_10008_1_2_4_94 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_94
    uid_1_2_840_10008_1_2_4_95 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_95
    uid_1_2_840_10008_1_2_4_100 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_100
    uid_1_2_840_10008_1_2_5 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_5
    uid_1_2_840_10008_1_2_6_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_6_1
    uid_1_2_840_10008_1_2_6_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_6_2
    uid_1_2_840_10008_1_3_10 = _gdcmswig.UIDs_uid_1_2_840_10008_1_3_10
    uid_1_2_840_10008_1_4_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_1
    uid_1_2_840_10008_1_4_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_2
    uid_1_2_840_10008_1_4_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_3
    uid_1_2_840_10008_1_4_1_4 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_4
    uid_1_2_840_10008_1_4_1_5 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_5
    uid_1_2_840_10008_1_4_1_6 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_6
    uid_1_2_840_10008_1_4_1_7 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_7
    uid_1_2_840_10008_1_4_1_8 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_8
    uid_1_2_840_10008_1_4_1_9 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_9
    uid_1_2_840_10008_1_4_1_10 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_10
    uid_1_2_840_10008_1_4_1_11 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_11
    uid_1_2_840_10008_1_4_1_12 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_12
    uid_1_2_840_10008_1_4_1_13 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_13
    uid_1_2_840_10008_1_4_1_14 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_14
    uid_1_2_840_10008_1_4_1_15 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_15
    uid_1_2_840_10008_1_4_1_16 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_16
    uid_1_2_840_10008_1_4_1_17 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_17
    uid_1_2_840_10008_1_4_1_18 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_1_18
    uid_1_2_840_10008_1_4_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_2_1
    uid_1_2_840_10008_1_4_2_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_4_2_2
    uid_1_2_840_10008_1_9 = _gdcmswig.UIDs_uid_1_2_840_10008_1_9
    uid_1_2_840_10008_1_20_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_20_1
    uid_1_2_840_10008_1_20_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_20_1_1
    uid_1_2_840_10008_1_20_2 = _gdcmswig.UIDs_uid_1_2_840_10008_1_20_2
    uid_1_2_840_10008_1_20_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_20_2_1
    uid_1_2_840_10008_1_40 = _gdcmswig.UIDs_uid_1_2_840_10008_1_40
    uid_1_2_840_10008_1_40_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_40_1
    uid_1_2_840_10008_1_42 = _gdcmswig.UIDs_uid_1_2_840_10008_1_42
    uid_1_2_840_10008_1_42_1 = _gdcmswig.UIDs_uid_1_2_840_10008_1_42_1
    uid_1_2_840_10008_2_6_1 = _gdcmswig.UIDs_uid_1_2_840_10008_2_6_1
    uid_1_2_840_10008_2_16_4 = _gdcmswig.UIDs_uid_1_2_840_10008_2_16_4
    uid_1_2_840_10008_3_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_1_1
    uid_1_2_840_10008_3_1_2_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_1_1
    uid_1_2_840_10008_3_1_2_1_4 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_1_4
    uid_1_2_840_10008_3_1_2_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_2_1
    uid_1_2_840_10008_3_1_2_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_3_1
    uid_1_2_840_10008_3_1_2_3_2 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_3_2
    uid_1_2_840_10008_3_1_2_3_3 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_3_3
    uid_1_2_840_10008_3_1_2_3_4 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_3_4
    uid_1_2_840_10008_3_1_2_3_5 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_3_5
    uid_1_2_840_10008_3_1_2_5_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_5_1
    uid_1_2_840_10008_3_1_2_5_4 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_5_4
    uid_1_2_840_10008_3_1_2_5_5 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_5_5
    uid_1_2_840_10008_3_1_2_6_1 = _gdcmswig.UIDs_uid_1_2_840_10008_3_1_2_6_1
    uid_1_2_840_10008_4_2 = _gdcmswig.UIDs_uid_1_2_840_10008_4_2
    uid_1_2_840_10008_5_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_1
    uid_1_2_840_10008_5_1_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_2
    uid_1_2_840_10008_5_1_1_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_4
    uid_1_2_840_10008_5_1_1_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_4_1
    uid_1_2_840_10008_5_1_1_4_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_4_2
    uid_1_2_840_10008_5_1_1_9 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_9
    uid_1_2_840_10008_5_1_1_9_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_9_1
    uid_1_2_840_10008_5_1_1_14 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_14
    uid_1_2_840_10008_5_1_1_15 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_15
    uid_1_2_840_10008_5_1_1_16 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_16
    uid_1_2_840_10008_5_1_1_16_376 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_16_376
    uid_1_2_840_10008_5_1_1_17 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_17
    uid_1_2_840_10008_5_1_1_17_376 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_17_376
    uid_1_2_840_10008_5_1_1_18 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_18
    uid_1_2_840_10008_5_1_1_18_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_18_1
    uid_1_2_840_10008_5_1_1_22 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_22
    uid_1_2_840_10008_5_1_1_23 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_23
    uid_1_2_840_10008_5_1_1_24 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_24
    uid_1_2_840_10008_5_1_1_24_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_24_1
    uid_1_2_840_10008_5_1_1_25 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_25
    uid_1_2_840_10008_5_1_1_26 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_26
    uid_1_2_840_10008_5_1_1_27 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_27
    uid_1_2_840_10008_5_1_1_29 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_29
    uid_1_2_840_10008_5_1_1_30 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_30
    uid_1_2_840_10008_5_1_1_31 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_31
    uid_1_2_840_10008_5_1_1_32 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_32
    uid_1_2_840_10008_5_1_1_33 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_1_33
    uid_1_2_840_10008_5_1_4_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1
    uid_1_2_840_10008_5_1_4_1_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_1
    uid_1_2_840_10008_5_1_4_1_1_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_1_1
    uid_1_2_840_10008_5_1_4_1_1_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_2
    uid_1_2_840_10008_5_1_4_1_1_1_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_2_1
    uid_1_2_840_10008_5_1_4_1_1_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_3
    uid_1_2_840_10008_5_1_4_1_1_1_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_1_3_1
    uid_1_2_840_10008_5_1_4_1_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_2
    uid_1_2_840_10008_5_1_4_1_1_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_2_1
    uid_1_2_840_10008_5_1_4_1_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_3
    uid_1_2_840_10008_5_1_4_1_1_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_3_1
    uid_1_2_840_10008_5_1_4_1_1_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_4
    uid_1_2_840_10008_5_1_4_1_1_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_4_1
    uid_1_2_840_10008_5_1_4_1_1_4_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_4_2
    uid_1_2_840_10008_5_1_4_1_1_5 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_5
    uid_1_2_840_10008_5_1_4_1_1_6 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_6
    uid_1_2_840_10008_5_1_4_1_1_6_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_6_1
    uid_1_2_840_10008_5_1_4_1_1_7 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_7
    uid_1_2_840_10008_5_1_4_1_1_7_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_7_1
    uid_1_2_840_10008_5_1_4_1_1_7_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_7_2
    uid_1_2_840_10008_5_1_4_1_1_7_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_7_3
    uid_1_2_840_10008_5_1_4_1_1_7_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_7_4
    uid_1_2_840_10008_5_1_4_1_1_8 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_8
    uid_1_2_840_10008_5_1_4_1_1_9 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9
    uid_1_2_840_10008_5_1_4_1_1_9_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_1
    uid_1_2_840_10008_5_1_4_1_1_9_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_1_1
    uid_1_2_840_10008_5_1_4_1_1_9_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_1_2
    uid_1_2_840_10008_5_1_4_1_1_9_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_1_3
    uid_1_2_840_10008_5_1_4_1_1_9_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_2_1
    uid_1_2_840_10008_5_1_4_1_1_9_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_3_1
    uid_1_2_840_10008_5_1_4_1_1_9_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_9_4_1
    uid_1_2_840_10008_5_1_4_1_1_10 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_10
    uid_1_2_840_10008_5_1_4_1_1_11 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_11
    uid_1_2_840_10008_5_1_4_1_1_11_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_11_1
    uid_1_2_840_10008_5_1_4_1_1_11_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_11_2
    uid_1_2_840_10008_5_1_4_1_1_11_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_11_3
    uid_1_2_840_10008_5_1_4_1_1_11_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_11_4
    uid_1_2_840_10008_5_1_4_1_1_12_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_12_1
    uid_1_2_840_10008_5_1_4_1_1_12_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_12_1_1
    uid_1_2_840_10008_5_1_4_1_1_12_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_12_2
    uid_1_2_840_10008_5_1_4_1_1_12_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_12_2_1
    uid_1_2_840_10008_5_1_4_1_1_13_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_13_1_1
    uid_1_2_840_10008_5_1_4_1_1_13_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_13_1_2
    uid_1_2_840_10008_5_1_4_1_1_12_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_12_3
    uid_1_2_840_10008_5_1_4_1_1_20 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_20
    uid_1_2_840_10008_5_1_4_1_1_66 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66
    uid_1_2_840_10008_5_1_4_1_1_66_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66_1
    uid_1_2_840_10008_5_1_4_1_1_66_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66_2
    uid_1_2_840_10008_5_1_4_1_1_66_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66_3
    uid_1_2_840_10008_5_1_4_1_1_66_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66_4
    uid_1_2_840_10008_5_1_4_1_1_67 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_67
    uid_1_2_840_10008_5_1_4_1_1_77_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1
    uid_1_2_840_10008_5_1_4_1_1_77_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_2
    uid_1_2_840_10008_5_1_4_1_1_77_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_1
    uid_1_2_840_10008_5_1_4_1_1_77_1_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_1_1
    uid_1_2_840_10008_5_1_4_1_1_77_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_2
    uid_1_2_840_10008_5_1_4_1_1_77_1_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_2_1
    uid_1_2_840_10008_5_1_4_1_1_77_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_3
    uid_1_2_840_10008_5_1_4_1_1_77_1_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_4
    uid_1_2_840_10008_5_1_4_1_1_77_1_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_4_1
    uid_1_2_840_10008_5_1_4_1_1_77_1_5_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_5_1
    uid_1_2_840_10008_5_1_4_1_1_77_1_5_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_5_2
    uid_1_2_840_10008_5_1_4_1_1_77_1_5_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_5_3
    uid_1_2_840_10008_5_1_4_1_1_77_1_5_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_5_4
    uid_1_2_840_10008_5_1_4_1_1_88_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_1
    uid_1_2_840_10008_5_1_4_1_1_88_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_2
    uid_1_2_840_10008_5_1_4_1_1_88_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_3
    uid_1_2_840_10008_5_1_4_1_1_88_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_4
    uid_1_2_840_10008_5_1_4_1_1_88_11 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_11
    uid_1_2_840_10008_5_1_4_1_1_88_22 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_22
    uid_1_2_840_10008_5_1_4_1_1_88_33 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_33
    uid_1_2_840_10008_5_1_4_1_1_88_40 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_40
    uid_1_2_840_10008_5_1_4_1_1_88_50 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_50
    uid_1_2_840_10008_5_1_4_1_1_88_59 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_59
    uid_1_2_840_10008_5_1_4_1_1_88_65 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_65
    uid_1_2_840_10008_5_1_4_1_1_88_67 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_88_67
    uid_1_2_840_10008_5_1_4_1_1_104_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_104_1
    uid_1_2_840_10008_5_1_4_1_1_104_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_104_2
    uid_1_2_840_10008_5_1_4_1_1_128 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_128
    uid_1_2_840_10008_5_1_4_1_1_129 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_129
    uid_1_2_840_10008_5_1_4_1_1_481_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_1
    uid_1_2_840_10008_5_1_4_1_1_481_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_2
    uid_1_2_840_10008_5_1_4_1_1_481_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_3
    uid_1_2_840_10008_5_1_4_1_1_481_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_4
    uid_1_2_840_10008_5_1_4_1_1_481_5 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_5
    uid_1_2_840_10008_5_1_4_1_1_481_6 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_6
    uid_1_2_840_10008_5_1_4_1_1_481_7 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_7
    uid_1_2_840_10008_5_1_4_1_1_481_8 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_8
    uid_1_2_840_10008_5_1_4_1_1_481_9 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_481_9
    uid_1_2_840_10008_5_1_4_1_2_1_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_1_1
    uid_1_2_840_10008_5_1_4_1_2_1_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_1_2
    uid_1_2_840_10008_5_1_4_1_2_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_1_3
    uid_1_2_840_10008_5_1_4_1_2_2_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_2_1
    uid_1_2_840_10008_5_1_4_1_2_2_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_2_2
    uid_1_2_840_10008_5_1_4_1_2_2_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_2_3
    uid_1_2_840_10008_5_1_4_1_2_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_3_1
    uid_1_2_840_10008_5_1_4_1_2_3_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_3_2
    uid_1_2_840_10008_5_1_4_1_2_3_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_2_3_3
    uid_1_2_840_10008_5_1_4_31 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_31
    uid_1_2_840_10008_5_1_4_32_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_32_1
    uid_1_2_840_10008_5_1_4_32_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_32_2
    uid_1_2_840_10008_5_1_4_32_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_32_3
    uid_1_2_840_10008_5_1_4_32 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_32
    uid_1_2_840_10008_5_1_4_33 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_33
    uid_1_2_840_10008_5_1_4_34_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_1
    uid_1_2_840_10008_5_1_4_34_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_2
    uid_1_2_840_10008_5_1_4_34_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_3
    uid_1_2_840_10008_5_1_4_34_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_4
    uid_1_2_840_10008_5_1_4_34_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_4_1
    uid_1_2_840_10008_5_1_4_34_4_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_4_2
    uid_1_2_840_10008_5_1_4_34_4_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_4_3
    uid_1_2_840_10008_5_1_4_34_4_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_4_4
    uid_1_2_840_10008_5_1_4_34_5 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_34_5
    uid_1_2_840_10008_5_1_4_37_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_37_1
    uid_1_2_840_10008_5_1_4_37_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_37_2
    uid_1_2_840_10008_5_1_4_37_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_37_3
    uid_1_2_840_10008_5_1_4_38_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_38_1
    uid_1_2_840_10008_5_1_4_38_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_38_2
    uid_1_2_840_10008_5_1_4_38_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_38_3
    uid_1_2_840_10008_5_1_4_41 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_41
    uid_1_2_840_10008_5_1_4_42 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_42
    uid_1_2_840_10008_15_0_3_1 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_1
    uid_1_2_840_10008_15_0_3_2 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_2
    uid_1_2_840_10008_15_0_3_3 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_3
    uid_1_2_840_10008_15_0_3_4 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_4
    uid_1_2_840_10008_15_0_3_5 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_5
    uid_1_2_840_10008_15_0_3_6 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_6
    uid_1_2_840_10008_15_0_3_7 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_7
    uid_1_2_840_10008_15_0_3_8 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_8
    uid_1_2_840_10008_15_0_3_9 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_9
    uid_1_2_840_10008_15_0_3_10 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_10
    uid_1_2_840_10008_15_0_3_11 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_11
    uid_1_2_840_10008_15_0_3_12 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_12
    uid_1_2_840_10008_15_0_3_13 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_13
    uid_1_2_840_10008_15_0_3_14 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_14
    uid_1_2_840_10008_15_0_3_15 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_15
    uid_1_2_840_10008_15_0_3_16 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_16
    uid_1_2_840_10008_15_0_3_17 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_17
    uid_1_2_840_10008_15_0_3_18 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_18
    uid_1_2_840_10008_15_0_3_19 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_19
    uid_1_2_840_10008_15_0_3_20 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_20
    uid_1_2_840_10008_15_0_3_21 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_21
    uid_1_2_840_10008_15_0_3_22 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_22
    uid_1_2_840_10008_15_0_3_23 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_23
    uid_1_2_840_10008_15_0_3_24 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_24
    uid_1_2_840_10008_15_0_3_25 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_25
    uid_1_2_840_10008_15_0_3_26 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_26
    uid_1_2_840_10008_15_0_3_27 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_27
    uid_1_2_840_10008_15_0_3_28 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_28
    uid_1_2_840_10008_15_0_3_29 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_29
    uid_1_2_840_10008_15_0_3_30 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_30
    uid_1_2_840_10008_15_0_3_31 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_3_31
    uid_1_2_840_10008_15_0_4_1 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_1
    uid_1_2_840_10008_15_0_4_2 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_2
    uid_1_2_840_10008_15_0_4_3 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_3
    uid_1_2_840_10008_15_0_4_4 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_4
    uid_1_2_840_10008_15_0_4_5 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_5
    uid_1_2_840_10008_15_0_4_6 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_6
    uid_1_2_840_10008_15_0_4_7 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_7
    uid_1_2_840_10008_15_0_4_8 = _gdcmswig.UIDs_uid_1_2_840_10008_15_0_4_8
    uid_1_2_840_10008_5_1_4_1_1_77_1_6 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_77_1_6
    uid_1_2_840_10008_5_1_4_1_1_6_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_6_2
    uid_1_2_840_10008_5_1_4_1_1_66_5 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_66_5
    uid_1_2_840_10008_5_1_4_1_1_13_1_3 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_13_1_3
    uid_1_2_840_10008_5_1_4_1_1_2_2 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_2_2
    uid_1_2_840_10008_5_1_4_1_1_4_4 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_4_4
    uid_1_2_840_10008_5_1_4_1_1_128_1 = _gdcmswig.UIDs_uid_1_2_840_10008_5_1_4_1_1_128_1
    uid_1_2_840_10008_1_2_4_101 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_101
    uid_1_2_840_10008_1_2_4_102 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_102
    uid_1_2_840_10008_1_2_4_103 = _gdcmswig.UIDs_uid_1_2_840_10008_1_2_4_103
    VerificationSOPClass = _gdcmswig.UIDs_VerificationSOPClass
    ImplicitVRLittleEndianDefaultTransferSyntaxforDICOM = _gdcmswig.UIDs_ImplicitVRLittleEndianDefaultTransferSyntaxforDICOM
    ExplicitVRLittleEndian = _gdcmswig.UIDs_ExplicitVRLittleEndian
    DeflatedExplicitVRLittleEndian = _gdcmswig.UIDs_DeflatedExplicitVRLittleEndian
    ExplicitVRBigEndian = _gdcmswig.UIDs_ExplicitVRBigEndian
    JPEGBaselineProcess1DefaultTransferSyntaxforLossyJPEG8BitImageCompression = _gdcmswig.UIDs_JPEGBaselineProcess1DefaultTransferSyntaxforLossyJPEG8BitImageCompression
    JPEGExtendedProcess24DefaultTransferSyntaxforLossyJPEG12BitImageCompressionProcess4only = _gdcmswig.UIDs_JPEGExtendedProcess24DefaultTransferSyntaxforLossyJPEG12BitImageCompressionProcess4only
    JPEGExtendedProcess35Retired = _gdcmswig.UIDs_JPEGExtendedProcess35Retired
    JPEGSpectralSelectionNonHierarchicalProcess68Retired = _gdcmswig.UIDs_JPEGSpectralSelectionNonHierarchicalProcess68Retired
    JPEGSpectralSelectionNonHierarchicalProcess79Retired = _gdcmswig.UIDs_JPEGSpectralSelectionNonHierarchicalProcess79Retired
    JPEGFullProgressionNonHierarchicalProcess1012Retired = _gdcmswig.UIDs_JPEGFullProgressionNonHierarchicalProcess1012Retired
    JPEGFullProgressionNonHierarchicalProcess1113Retired = _gdcmswig.UIDs_JPEGFullProgressionNonHierarchicalProcess1113Retired
    JPEGLosslessNonHierarchicalProcess14 = _gdcmswig.UIDs_JPEGLosslessNonHierarchicalProcess14
    JPEGLosslessNonHierarchicalProcess15Retired = _gdcmswig.UIDs_JPEGLosslessNonHierarchicalProcess15Retired
    JPEGExtendedHierarchicalProcess1618Retired = _gdcmswig.UIDs_JPEGExtendedHierarchicalProcess1618Retired
    JPEGExtendedHierarchicalProcess1719Retired = _gdcmswig.UIDs_JPEGExtendedHierarchicalProcess1719Retired
    JPEGSpectralSelectionHierarchicalProcess2022Retired = _gdcmswig.UIDs_JPEGSpectralSelectionHierarchicalProcess2022Retired
    JPEGSpectralSelectionHierarchicalProcess2123Retired = _gdcmswig.UIDs_JPEGSpectralSelectionHierarchicalProcess2123Retired
    JPEGFullProgressionHierarchicalProcess2426Retired = _gdcmswig.UIDs_JPEGFullProgressionHierarchicalProcess2426Retired
    JPEGFullProgressionHierarchicalProcess2527Retired = _gdcmswig.UIDs_JPEGFullProgressionHierarchicalProcess2527Retired
    JPEGLosslessHierarchicalProcess28Retired = _gdcmswig.UIDs_JPEGLosslessHierarchicalProcess28Retired
    JPEGLosslessHierarchicalProcess29Retired = _gdcmswig.UIDs_JPEGLosslessHierarchicalProcess29Retired
    JPEGLosslessNonHierarchicalFirstOrderPredictionProcess14SelectionValue1DefaultTransferSyntaxforLosslessJPEGImageCompression = _gdcmswig.UIDs_JPEGLosslessNonHierarchicalFirstOrderPredictionProcess14SelectionValue1DefaultTransferSyntaxforLosslessJPEGImageCompression
    JPEGLSLosslessImageCompression = _gdcmswig.UIDs_JPEGLSLosslessImageCompression
    JPEGLSLossyNearLosslessImageCompression = _gdcmswig.UIDs_JPEGLSLossyNearLosslessImageCompression
    JPEG2000ImageCompressionLosslessOnly = _gdcmswig.UIDs_JPEG2000ImageCompressionLosslessOnly
    JPEG2000ImageCompression = _gdcmswig.UIDs_JPEG2000ImageCompression
    JPEG2000Part2MulticomponentImageCompressionLosslessOnly = _gdcmswig.UIDs_JPEG2000Part2MulticomponentImageCompressionLosslessOnly
    JPEG2000Part2MulticomponentImageCompression = _gdcmswig.UIDs_JPEG2000Part2MulticomponentImageCompression
    JPIPReferenced = _gdcmswig.UIDs_JPIPReferenced
    JPIPReferencedDeflate = _gdcmswig.UIDs_JPIPReferencedDeflate
    MPEG2MainProfileMainLevel = _gdcmswig.UIDs_MPEG2MainProfileMainLevel
    RLELossless = _gdcmswig.UIDs_RLELossless
    RFC2557MIMEencapsulation = _gdcmswig.UIDs_RFC2557MIMEencapsulation
    XMLEncoding = _gdcmswig.UIDs_XMLEncoding
    MediaStorageDirectoryStorage = _gdcmswig.UIDs_MediaStorageDirectoryStorage
    TalairachBrainAtlasFrameofReference = _gdcmswig.UIDs_TalairachBrainAtlasFrameofReference
    SPM2T1FrameofReference = _gdcmswig.UIDs_SPM2T1FrameofReference
    SPM2T2FrameofReference = _gdcmswig.UIDs_SPM2T2FrameofReference
    SPM2PDFrameofReference = _gdcmswig.UIDs_SPM2PDFrameofReference
    SPM2EPIFrameofReference = _gdcmswig.UIDs_SPM2EPIFrameofReference
    SPM2FILT1FrameofReference = _gdcmswig.UIDs_SPM2FILT1FrameofReference
    SPM2PETFrameofReference = _gdcmswig.UIDs_SPM2PETFrameofReference
    SPM2TRANSMFrameofReference = _gdcmswig.UIDs_SPM2TRANSMFrameofReference
    SPM2SPECTFrameofReference = _gdcmswig.UIDs_SPM2SPECTFrameofReference
    SPM2GRAYFrameofReference = _gdcmswig.UIDs_SPM2GRAYFrameofReference
    SPM2WHITEFrameofReference = _gdcmswig.UIDs_SPM2WHITEFrameofReference
    SPM2CSFFrameofReference = _gdcmswig.UIDs_SPM2CSFFrameofReference
    SPM2BRAINMASKFrameofReference = _gdcmswig.UIDs_SPM2BRAINMASKFrameofReference
    SPM2AVG305T1FrameofReference = _gdcmswig.UIDs_SPM2AVG305T1FrameofReference
    SPM2AVG152T1FrameofReference = _gdcmswig.UIDs_SPM2AVG152T1FrameofReference
    SPM2AVG152T2FrameofReference = _gdcmswig.UIDs_SPM2AVG152T2FrameofReference
    SPM2AVG152PDFrameofReference = _gdcmswig.UIDs_SPM2AVG152PDFrameofReference
    SPM2SINGLESUBJT1FrameofReference = _gdcmswig.UIDs_SPM2SINGLESUBJT1FrameofReference
    ICBM452T1FrameofReference = _gdcmswig.UIDs_ICBM452T1FrameofReference
    ICBMSingleSubjectMRIFrameofReference = _gdcmswig.UIDs_ICBMSingleSubjectMRIFrameofReference
    BasicStudyContentNotificationSOPClassRetired = _gdcmswig.UIDs_BasicStudyContentNotificationSOPClassRetired
    StorageCommitmentPushModelSOPClass = _gdcmswig.UIDs_StorageCommitmentPushModelSOPClass
    StorageCommitmentPushModelSOPInstance = _gdcmswig.UIDs_StorageCommitmentPushModelSOPInstance
    StorageCommitmentPullModelSOPClassRetired = _gdcmswig.UIDs_StorageCommitmentPullModelSOPClassRetired
    StorageCommitmentPullModelSOPInstanceRetired = _gdcmswig.UIDs_StorageCommitmentPullModelSOPInstanceRetired
    ProceduralEventLoggingSOPClass = _gdcmswig.UIDs_ProceduralEventLoggingSOPClass
    ProceduralEventLoggingSOPInstance = _gdcmswig.UIDs_ProceduralEventLoggingSOPInstance
    SubstanceAdministrationLoggingSOPClass = _gdcmswig.UIDs_SubstanceAdministrationLoggingSOPClass
    SubstanceAdministrationLoggingSOPInstance = _gdcmswig.UIDs_SubstanceAdministrationLoggingSOPInstance
    DICOMUIDRegistry = _gdcmswig.UIDs_DICOMUIDRegistry
    DICOMControlledTerminology = _gdcmswig.UIDs_DICOMControlledTerminology
    DICOMApplicationContextName = _gdcmswig.UIDs_DICOMApplicationContextName
    DetachedPatientManagementSOPClassRetired = _gdcmswig.UIDs_DetachedPatientManagementSOPClassRetired
    DetachedPatientManagementMetaSOPClassRetired = _gdcmswig.UIDs_DetachedPatientManagementMetaSOPClassRetired
    DetachedVisitManagementSOPClassRetired = _gdcmswig.UIDs_DetachedVisitManagementSOPClassRetired
    DetachedStudyManagementSOPClassRetired = _gdcmswig.UIDs_DetachedStudyManagementSOPClassRetired
    StudyComponentManagementSOPClassRetired = _gdcmswig.UIDs_StudyComponentManagementSOPClassRetired
    ModalityPerformedProcedureStepSOPClass = _gdcmswig.UIDs_ModalityPerformedProcedureStepSOPClass
    ModalityPerformedProcedureStepRetrieveSOPClass = _gdcmswig.UIDs_ModalityPerformedProcedureStepRetrieveSOPClass
    ModalityPerformedProcedureStepNotificationSOPClass = _gdcmswig.UIDs_ModalityPerformedProcedureStepNotificationSOPClass
    DetachedResultsManagementSOPClassRetired = _gdcmswig.UIDs_DetachedResultsManagementSOPClassRetired
    DetachedResultsManagementMetaSOPClassRetired = _gdcmswig.UIDs_DetachedResultsManagementMetaSOPClassRetired
    DetachedStudyManagementMetaSOPClassRetired = _gdcmswig.UIDs_DetachedStudyManagementMetaSOPClassRetired
    DetachedInterpretationManagementSOPClassRetired = _gdcmswig.UIDs_DetachedInterpretationManagementSOPClassRetired
    StorageServiceClass = _gdcmswig.UIDs_StorageServiceClass
    BasicFilmSessionSOPClass = _gdcmswig.UIDs_BasicFilmSessionSOPClass
    BasicFilmBoxSOPClass = _gdcmswig.UIDs_BasicFilmBoxSOPClass
    BasicGrayscaleImageBoxSOPClass = _gdcmswig.UIDs_BasicGrayscaleImageBoxSOPClass
    BasicColorImageBoxSOPClass = _gdcmswig.UIDs_BasicColorImageBoxSOPClass
    ReferencedImageBoxSOPClassRetired = _gdcmswig.UIDs_ReferencedImageBoxSOPClassRetired
    BasicGrayscalePrintManagementMetaSOPClass = _gdcmswig.UIDs_BasicGrayscalePrintManagementMetaSOPClass
    ReferencedGrayscalePrintManagementMetaSOPClassRetired = _gdcmswig.UIDs_ReferencedGrayscalePrintManagementMetaSOPClassRetired
    PrintJobSOPClass = _gdcmswig.UIDs_PrintJobSOPClass
    BasicAnnotationBoxSOPClass = _gdcmswig.UIDs_BasicAnnotationBoxSOPClass
    PrinterSOPClass = _gdcmswig.UIDs_PrinterSOPClass
    PrinterConfigurationRetrievalSOPClass = _gdcmswig.UIDs_PrinterConfigurationRetrievalSOPClass
    PrinterSOPInstance = _gdcmswig.UIDs_PrinterSOPInstance
    PrinterConfigurationRetrievalSOPInstance = _gdcmswig.UIDs_PrinterConfigurationRetrievalSOPInstance
    BasicColorPrintManagementMetaSOPClass = _gdcmswig.UIDs_BasicColorPrintManagementMetaSOPClass
    ReferencedColorPrintManagementMetaSOPClassRetired = _gdcmswig.UIDs_ReferencedColorPrintManagementMetaSOPClassRetired
    VOILUTBoxSOPClass = _gdcmswig.UIDs_VOILUTBoxSOPClass
    PresentationLUTSOPClass = _gdcmswig.UIDs_PresentationLUTSOPClass
    ImageOverlayBoxSOPClassRetired = _gdcmswig.UIDs_ImageOverlayBoxSOPClassRetired
    BasicPrintImageOverlayBoxSOPClassRetired = _gdcmswig.UIDs_BasicPrintImageOverlayBoxSOPClassRetired
    PrintQueueSOPInstanceRetired = _gdcmswig.UIDs_PrintQueueSOPInstanceRetired
    PrintQueueManagementSOPClassRetired = _gdcmswig.UIDs_PrintQueueManagementSOPClassRetired
    StoredPrintStorageSOPClassRetired = _gdcmswig.UIDs_StoredPrintStorageSOPClassRetired
    HardcopyGrayscaleImageStorageSOPClassRetired = _gdcmswig.UIDs_HardcopyGrayscaleImageStorageSOPClassRetired
    HardcopyColorImageStorageSOPClassRetired = _gdcmswig.UIDs_HardcopyColorImageStorageSOPClassRetired
    PullPrintRequestSOPClassRetired = _gdcmswig.UIDs_PullPrintRequestSOPClassRetired
    PullStoredPrintManagementMetaSOPClassRetired = _gdcmswig.UIDs_PullStoredPrintManagementMetaSOPClassRetired
    MediaCreationManagementSOPClassUID = _gdcmswig.UIDs_MediaCreationManagementSOPClassUID
    ComputedRadiographyImageStorage = _gdcmswig.UIDs_ComputedRadiographyImageStorage
    DigitalXRayImageStorageForPresentation = _gdcmswig.UIDs_DigitalXRayImageStorageForPresentation
    DigitalXRayImageStorageForProcessing = _gdcmswig.UIDs_DigitalXRayImageStorageForProcessing
    DigitalMammographyXRayImageStorageForPresentation = _gdcmswig.UIDs_DigitalMammographyXRayImageStorageForPresentation
    DigitalMammographyXRayImageStorageForProcessing = _gdcmswig.UIDs_DigitalMammographyXRayImageStorageForProcessing
    DigitalIntraoralXRayImageStorageForPresentation = _gdcmswig.UIDs_DigitalIntraoralXRayImageStorageForPresentation
    DigitalIntraoralXRayImageStorageForProcessing = _gdcmswig.UIDs_DigitalIntraoralXRayImageStorageForProcessing
    CTImageStorage = _gdcmswig.UIDs_CTImageStorage
    EnhancedCTImageStorage = _gdcmswig.UIDs_EnhancedCTImageStorage
    UltrasoundMultiframeImageStorageRetired = _gdcmswig.UIDs_UltrasoundMultiframeImageStorageRetired
    UltrasoundMultiframeImageStorage = _gdcmswig.UIDs_UltrasoundMultiframeImageStorage
    MRImageStorage = _gdcmswig.UIDs_MRImageStorage
    EnhancedMRImageStorage = _gdcmswig.UIDs_EnhancedMRImageStorage
    MRSpectroscopyStorage = _gdcmswig.UIDs_MRSpectroscopyStorage
    NuclearMedicineImageStorageRetired = _gdcmswig.UIDs_NuclearMedicineImageStorageRetired
    UltrasoundImageStorageRetired = _gdcmswig.UIDs_UltrasoundImageStorageRetired
    UltrasoundImageStorage = _gdcmswig.UIDs_UltrasoundImageStorage
    SecondaryCaptureImageStorage = _gdcmswig.UIDs_SecondaryCaptureImageStorage
    MultiframeSingleBitSecondaryCaptureImageStorage = _gdcmswig.UIDs_MultiframeSingleBitSecondaryCaptureImageStorage
    MultiframeGrayscaleByteSecondaryCaptureImageStorage = _gdcmswig.UIDs_MultiframeGrayscaleByteSecondaryCaptureImageStorage
    MultiframeGrayscaleWordSecondaryCaptureImageStorage = _gdcmswig.UIDs_MultiframeGrayscaleWordSecondaryCaptureImageStorage
    MultiframeTrueColorSecondaryCaptureImageStorage = _gdcmswig.UIDs_MultiframeTrueColorSecondaryCaptureImageStorage
    StandaloneOverlayStorageRetired = _gdcmswig.UIDs_StandaloneOverlayStorageRetired
    StandaloneCurveStorageRetired = _gdcmswig.UIDs_StandaloneCurveStorageRetired
    WaveformStorageTrialRetired = _gdcmswig.UIDs_WaveformStorageTrialRetired
    GeneralECGWaveformStorage = _gdcmswig.UIDs_GeneralECGWaveformStorage
    AmbulatoryECGWaveformStorage = _gdcmswig.UIDs_AmbulatoryECGWaveformStorage
    HemodynamicWaveformStorage = _gdcmswig.UIDs_HemodynamicWaveformStorage
    CardiacElectrophysiologyWaveformStorage = _gdcmswig.UIDs_CardiacElectrophysiologyWaveformStorage
    BasicVoiceAudioWaveformStorage = _gdcmswig.UIDs_BasicVoiceAudioWaveformStorage
    StandaloneModalityLUTStorageRetired = _gdcmswig.UIDs_StandaloneModalityLUTStorageRetired
    StandaloneVOILUTStorageRetired = _gdcmswig.UIDs_StandaloneVOILUTStorageRetired
    GrayscaleSoftcopyPresentationStateStorageSOPClass = _gdcmswig.UIDs_GrayscaleSoftcopyPresentationStateStorageSOPClass
    ColorSoftcopyPresentationStateStorageSOPClass = _gdcmswig.UIDs_ColorSoftcopyPresentationStateStorageSOPClass
    PseudoColorSoftcopyPresentationStateStorageSOPClass = _gdcmswig.UIDs_PseudoColorSoftcopyPresentationStateStorageSOPClass
    BlendingSoftcopyPresentationStateStorageSOPClass = _gdcmswig.UIDs_BlendingSoftcopyPresentationStateStorageSOPClass
    XRayAngiographicImageStorage = _gdcmswig.UIDs_XRayAngiographicImageStorage
    EnhancedXAImageStorage = _gdcmswig.UIDs_EnhancedXAImageStorage
    XRayRadiofluoroscopicImageStorage = _gdcmswig.UIDs_XRayRadiofluoroscopicImageStorage
    EnhancedXRFImageStorage = _gdcmswig.UIDs_EnhancedXRFImageStorage
    XRay3DAngiographicImageStorage = _gdcmswig.UIDs_XRay3DAngiographicImageStorage
    XRay3DCraniofacialImageStorage = _gdcmswig.UIDs_XRay3DCraniofacialImageStorage
    XRayAngiographicBiPlaneImageStorageRetired = _gdcmswig.UIDs_XRayAngiographicBiPlaneImageStorageRetired
    NuclearMedicineImageStorage = _gdcmswig.UIDs_NuclearMedicineImageStorage
    RawDataStorage = _gdcmswig.UIDs_RawDataStorage
    SpatialRegistrationStorage = _gdcmswig.UIDs_SpatialRegistrationStorage
    SpatialFiducialsStorage = _gdcmswig.UIDs_SpatialFiducialsStorage
    DeformableSpatialRegistrationStorage = _gdcmswig.UIDs_DeformableSpatialRegistrationStorage
    SegmentationStorage = _gdcmswig.UIDs_SegmentationStorage
    RealWorldValueMappingStorage = _gdcmswig.UIDs_RealWorldValueMappingStorage
    VLImageStorageTrialRetired = _gdcmswig.UIDs_VLImageStorageTrialRetired
    VLMultiframeImageStorageTrialRetired = _gdcmswig.UIDs_VLMultiframeImageStorageTrialRetired
    VLEndoscopicImageStorage = _gdcmswig.UIDs_VLEndoscopicImageStorage
    VideoEndoscopicImageStorage = _gdcmswig.UIDs_VideoEndoscopicImageStorage
    VLMicroscopicImageStorage = _gdcmswig.UIDs_VLMicroscopicImageStorage
    VideoMicroscopicImageStorage = _gdcmswig.UIDs_VideoMicroscopicImageStorage
    VLSlideCoordinatesMicroscopicImageStorage = _gdcmswig.UIDs_VLSlideCoordinatesMicroscopicImageStorage
    VLPhotographicImageStorage = _gdcmswig.UIDs_VLPhotographicImageStorage
    VideoPhotographicImageStorage = _gdcmswig.UIDs_VideoPhotographicImageStorage
    OphthalmicPhotography8BitImageStorage = _gdcmswig.UIDs_OphthalmicPhotography8BitImageStorage
    OphthalmicPhotography16BitImageStorage = _gdcmswig.UIDs_OphthalmicPhotography16BitImageStorage
    StereometricRelationshipStorage = _gdcmswig.UIDs_StereometricRelationshipStorage
    OphthalmicTomographyImageStorage = _gdcmswig.UIDs_OphthalmicTomographyImageStorage
    TextSRStorageTrialRetired = _gdcmswig.UIDs_TextSRStorageTrialRetired
    AudioSRStorageTrialRetired = _gdcmswig.UIDs_AudioSRStorageTrialRetired
    DetailSRStorageTrialRetired = _gdcmswig.UIDs_DetailSRStorageTrialRetired
    ComprehensiveSRStorageTrialRetired = _gdcmswig.UIDs_ComprehensiveSRStorageTrialRetired
    BasicTextSRStorage = _gdcmswig.UIDs_BasicTextSRStorage
    EnhancedSRStorage = _gdcmswig.UIDs_EnhancedSRStorage
    ComprehensiveSRStorage = _gdcmswig.UIDs_ComprehensiveSRStorage
    ProcedureLogStorage = _gdcmswig.UIDs_ProcedureLogStorage
    MammographyCADSRStorage = _gdcmswig.UIDs_MammographyCADSRStorage
    KeyObjectSelectionDocumentStorage = _gdcmswig.UIDs_KeyObjectSelectionDocumentStorage
    ChestCADSRStorage = _gdcmswig.UIDs_ChestCADSRStorage
    XRayRadiationDoseSRStorage = _gdcmswig.UIDs_XRayRadiationDoseSRStorage
    EncapsulatedPDFStorage = _gdcmswig.UIDs_EncapsulatedPDFStorage
    EncapsulatedCDAStorage = _gdcmswig.UIDs_EncapsulatedCDAStorage
    PositronEmissionTomographyImageStorage = _gdcmswig.UIDs_PositronEmissionTomographyImageStorage
    StandalonePETCurveStorageRetired = _gdcmswig.UIDs_StandalonePETCurveStorageRetired
    RTImageStorage = _gdcmswig.UIDs_RTImageStorage
    RTDoseStorage = _gdcmswig.UIDs_RTDoseStorage
    RTStructureSetStorage = _gdcmswig.UIDs_RTStructureSetStorage
    RTBeamsTreatmentRecordStorage = _gdcmswig.UIDs_RTBeamsTreatmentRecordStorage
    RTPlanStorage = _gdcmswig.UIDs_RTPlanStorage
    RTBrachyTreatmentRecordStorage = _gdcmswig.UIDs_RTBrachyTreatmentRecordStorage
    RTTreatmentSummaryRecordStorage = _gdcmswig.UIDs_RTTreatmentSummaryRecordStorage
    RTIonPlanStorage = _gdcmswig.UIDs_RTIonPlanStorage
    RTIonBeamsTreatmentRecordStorage = _gdcmswig.UIDs_RTIonBeamsTreatmentRecordStorage
    PatientRootQueryRetrieveInformationModelFIND = _gdcmswig.UIDs_PatientRootQueryRetrieveInformationModelFIND
    PatientRootQueryRetrieveInformationModelMOVE = _gdcmswig.UIDs_PatientRootQueryRetrieveInformationModelMOVE
    PatientRootQueryRetrieveInformationModelGET = _gdcmswig.UIDs_PatientRootQueryRetrieveInformationModelGET
    StudyRootQueryRetrieveInformationModelFIND = _gdcmswig.UIDs_StudyRootQueryRetrieveInformationModelFIND
    StudyRootQueryRetrieveInformationModelMOVE = _gdcmswig.UIDs_StudyRootQueryRetrieveInformationModelMOVE
    StudyRootQueryRetrieveInformationModelGET = _gdcmswig.UIDs_StudyRootQueryRetrieveInformationModelGET
    PatientStudyOnlyQueryRetrieveInformationModelFINDRetired = _gdcmswig.UIDs_PatientStudyOnlyQueryRetrieveInformationModelFINDRetired
    PatientStudyOnlyQueryRetrieveInformationModelMOVERetired = _gdcmswig.UIDs_PatientStudyOnlyQueryRetrieveInformationModelMOVERetired
    PatientStudyOnlyQueryRetrieveInformationModelGETRetired = _gdcmswig.UIDs_PatientStudyOnlyQueryRetrieveInformationModelGETRetired
    ModalityWorklistInformationModelFIND = _gdcmswig.UIDs_ModalityWorklistInformationModelFIND
    GeneralPurposeWorklistInformationModelFIND = _gdcmswig.UIDs_GeneralPurposeWorklistInformationModelFIND
    GeneralPurposeScheduledProcedureStepSOPClass = _gdcmswig.UIDs_GeneralPurposeScheduledProcedureStepSOPClass
    GeneralPurposePerformedProcedureStepSOPClass = _gdcmswig.UIDs_GeneralPurposePerformedProcedureStepSOPClass
    GeneralPurposeWorklistManagementMetaSOPClass = _gdcmswig.UIDs_GeneralPurposeWorklistManagementMetaSOPClass
    InstanceAvailabilityNotificationSOPClass = _gdcmswig.UIDs_InstanceAvailabilityNotificationSOPClass
    RTBeamsDeliveryInstructionStorageSupplement74FrozenDraft = _gdcmswig.UIDs_RTBeamsDeliveryInstructionStorageSupplement74FrozenDraft
    RTConventionalMachineVerificationSupplement74FrozenDraft = _gdcmswig.UIDs_RTConventionalMachineVerificationSupplement74FrozenDraft
    RTIonMachineVerificationSupplement74FrozenDraft = _gdcmswig.UIDs_RTIonMachineVerificationSupplement74FrozenDraft
    UnifiedWorklistandProcedureStepServiceClass = _gdcmswig.UIDs_UnifiedWorklistandProcedureStepServiceClass
    UnifiedProcedureStepPushSOPClass = _gdcmswig.UIDs_UnifiedProcedureStepPushSOPClass
    UnifiedProcedureStepWatchSOPClass = _gdcmswig.UIDs_UnifiedProcedureStepWatchSOPClass
    UnifiedProcedureStepPullSOPClass = _gdcmswig.UIDs_UnifiedProcedureStepPullSOPClass
    UnifiedProcedureStepEventSOPClass = _gdcmswig.UIDs_UnifiedProcedureStepEventSOPClass
    UnifiedWorklistandProcedureStepSOPInstance = _gdcmswig.UIDs_UnifiedWorklistandProcedureStepSOPInstance
    GeneralRelevantPatientInformationQuery = _gdcmswig.UIDs_GeneralRelevantPatientInformationQuery
    BreastImagingRelevantPatientInformationQuery = _gdcmswig.UIDs_BreastImagingRelevantPatientInformationQuery
    CardiacRelevantPatientInformationQuery = _gdcmswig.UIDs_CardiacRelevantPatientInformationQuery
    HangingProtocolStorage = _gdcmswig.UIDs_HangingProtocolStorage
    HangingProtocolInformationModelFIND = _gdcmswig.UIDs_HangingProtocolInformationModelFIND
    HangingProtocolInformationModelMOVE = _gdcmswig.UIDs_HangingProtocolInformationModelMOVE
    ProductCharacteristicsQuerySOPClass = _gdcmswig.UIDs_ProductCharacteristicsQuerySOPClass
    SubstanceApprovalQuerySOPClass = _gdcmswig.UIDs_SubstanceApprovalQuerySOPClass
    dicomDeviceName = _gdcmswig.UIDs_dicomDeviceName
    dicomDescription = _gdcmswig.UIDs_dicomDescription
    dicomManufacturer = _gdcmswig.UIDs_dicomManufacturer
    dicomManufacturerModelName = _gdcmswig.UIDs_dicomManufacturerModelName
    dicomSoftwareVersion = _gdcmswig.UIDs_dicomSoftwareVersion
    dicomVendorData = _gdcmswig.UIDs_dicomVendorData
    dicomAETitle = _gdcmswig.UIDs_dicomAETitle
    dicomNetworkConnectionReference = _gdcmswig.UIDs_dicomNetworkConnectionReference
    dicomApplicationCluster = _gdcmswig.UIDs_dicomApplicationCluster
    dicomAssociationInitiator = _gdcmswig.UIDs_dicomAssociationInitiator
    dicomAssociationAcceptor = _gdcmswig.UIDs_dicomAssociationAcceptor
    dicomHostname = _gdcmswig.UIDs_dicomHostname
    dicomPort = _gdcmswig.UIDs_dicomPort
    dicomSOPClass = _gdcmswig.UIDs_dicomSOPClass
    dicomTransferRole = _gdcmswig.UIDs_dicomTransferRole
    dicomTransferSyntax = _gdcmswig.UIDs_dicomTransferSyntax
    dicomPrimaryDeviceType = _gdcmswig.UIDs_dicomPrimaryDeviceType
    dicomRelatedDeviceReference = _gdcmswig.UIDs_dicomRelatedDeviceReference
    dicomPreferredCalledAETitle = _gdcmswig.UIDs_dicomPreferredCalledAETitle
    dicomTLSCyphersuite = _gdcmswig.UIDs_dicomTLSCyphersuite
    dicomAuthorizedNodeCertificateReference = _gdcmswig.UIDs_dicomAuthorizedNodeCertificateReference
    dicomThisNodeCertificateReference = _gdcmswig.UIDs_dicomThisNodeCertificateReference
    dicomInstalled = _gdcmswig.UIDs_dicomInstalled
    dicomStationName = _gdcmswig.UIDs_dicomStationName
    dicomDeviceSerialNumber = _gdcmswig.UIDs_dicomDeviceSerialNumber
    dicomInstitutionName = _gdcmswig.UIDs_dicomInstitutionName
    dicomInstitutionAddress = _gdcmswig.UIDs_dicomInstitutionAddress
    dicomInstitutionDepartmentName = _gdcmswig.UIDs_dicomInstitutionDepartmentName
    dicomIssuerOfPatientID = _gdcmswig.UIDs_dicomIssuerOfPatientID
    dicomPreferredCallingAETitle = _gdcmswig.UIDs_dicomPreferredCallingAETitle
    dicomSupportedCharacterSet = _gdcmswig.UIDs_dicomSupportedCharacterSet
    dicomConfigurationRoot = _gdcmswig.UIDs_dicomConfigurationRoot
    dicomDevicesRoot = _gdcmswig.UIDs_dicomDevicesRoot
    dicomUniqueAETitlesRegistryRoot = _gdcmswig.UIDs_dicomUniqueAETitlesRegistryRoot
    dicomDevice = _gdcmswig.UIDs_dicomDevice
    dicomNetworkAE = _gdcmswig.UIDs_dicomNetworkAE
    dicomNetworkConnection = _gdcmswig.UIDs_dicomNetworkConnection
    dicomUniqueAETitle = _gdcmswig.UIDs_dicomUniqueAETitle
    dicomTransferCapability = _gdcmswig.UIDs_dicomTransferCapability
    VLWholeSlideMicroscopyImageStorage = _gdcmswig.UIDs_VLWholeSlideMicroscopyImageStorage
    EnhancedUSVolumeStorage = _gdcmswig.UIDs_EnhancedUSVolumeStorage
    SurfaceSegmentationStorage = _gdcmswig.UIDs_SurfaceSegmentationStorage
    BreastTomosynthesisImageStorage = _gdcmswig.UIDs_BreastTomosynthesisImageStorage
    LegacyConvertedEnhancedCTImageStorage = _gdcmswig.UIDs_LegacyConvertedEnhancedCTImageStorage
    LegacyConvertedEnhancedMRImageStorage = _gdcmswig.UIDs_LegacyConvertedEnhancedMRImageStorage
    LegacyConvertedEnhancedPETImageStorage = _gdcmswig.UIDs_LegacyConvertedEnhancedPETImageStorage
    if _newclass:
        GetTransferSyntaxStrings = staticmethod(_gdcmswig.UIDs_GetTransferSyntaxStrings)
    else:
        GetTransferSyntaxStrings = _gdcmswig.UIDs_GetTransferSyntaxStrings
    if _newclass:
        GetTransferSyntaxString = staticmethod(_gdcmswig.UIDs_GetTransferSyntaxString)
    else:
        GetTransferSyntaxString = _gdcmswig.UIDs_GetTransferSyntaxString
    if _newclass:
        GetNumberOfTransferSyntaxStrings = staticmethod(_gdcmswig.UIDs_GetNumberOfTransferSyntaxStrings)
    else:
        GetNumberOfTransferSyntaxStrings = _gdcmswig.UIDs_GetNumberOfTransferSyntaxStrings
    if _newclass:
        GetUIDString = staticmethod(_gdcmswig.UIDs_GetUIDString)
    else:
        GetUIDString = _gdcmswig.UIDs_GetUIDString
    if _newclass:
        GetUIDName = staticmethod(_gdcmswig.UIDs_GetUIDName)
    else:
        GetUIDName = _gdcmswig.UIDs_GetUIDName

    def SetFromUID(self, str: 'char const *') -> "bool":
        """
        bool
        gdcm::UIDs::SetFromUID(const char *str)

        Initialize object from a string (a uid number) return false on error,
        and internal state is set to 0 
        """
        return _gdcmswig.UIDs_SetFromUID(self, str)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::UIDs::GetName() const

        When object is Initialize function return the well known name
        associated with uid return NULL when not initialized 
        """
        return _gdcmswig.UIDs_GetName(self)


    def GetString(self) -> "char const *":
        """
        const char*
        gdcm::UIDs::GetString() const

        When object is Initialize function return the uid return NULL when not
        initialized 
        """
        return _gdcmswig.UIDs_GetString(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.UIDs___str__(self)

    def __init__(self):
        this = _gdcmswig.new_UIDs()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_UIDs
    __del__ = lambda self: None
UIDs_swigregister = _gdcmswig.UIDs_swigregister
UIDs_swigregister(UIDs)

def UIDs_GetTransferSyntaxStrings() -> "gdcm::UIDs::TransferSyntaxStringsType":
    return _gdcmswig.UIDs_GetTransferSyntaxStrings()
UIDs_GetTransferSyntaxStrings = _gdcmswig.UIDs_GetTransferSyntaxStrings

def UIDs_GetTransferSyntaxString(ts: 'unsigned int') -> "char const *const *":
    return _gdcmswig.UIDs_GetTransferSyntaxString(ts)
UIDs_GetTransferSyntaxString = _gdcmswig.UIDs_GetTransferSyntaxString

def UIDs_GetNumberOfTransferSyntaxStrings() -> "unsigned int":
    return _gdcmswig.UIDs_GetNumberOfTransferSyntaxStrings()
UIDs_GetNumberOfTransferSyntaxStrings = _gdcmswig.UIDs_GetNumberOfTransferSyntaxStrings

def UIDs_GetUIDString(ts: 'unsigned int') -> "char const *":
    return _gdcmswig.UIDs_GetUIDString(ts)
UIDs_GetUIDString = _gdcmswig.UIDs_GetUIDString

def UIDs_GetUIDName(ts: 'unsigned int') -> "char const *":
    return _gdcmswig.UIDs_GetUIDName(ts)
UIDs_GetUIDName = _gdcmswig.UIDs_GetUIDName

class Sorter(_object):
    """


    Sorter.

    General class to do sorting using a custom function You simply need to
    provide a function of type: Sorter::SortFunction

    WARNING:  implementation details. For now there is no cache mechanism.
    Which means that everytime you call Sort, all files specified as input
    paramater are read

    See:   Scanner

    C++ includes: gdcmSorter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Sorter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Sorter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Sorter::Sorter()

        """
        this = _gdcmswig.new_Sorter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Sorter
    __del__ = lambda self: None

    def Sort(self, filenames: 'FilenamesType') -> "bool":
        """
        virtual bool
        gdcm::Sorter::Sort(std::vector< std::string > const &filenames)

        Typically the output of Directory::GetFilenames() 
        """
        return _gdcmswig.Sorter_Sort(self, filenames)


    def GetFilenames(self) -> "std::vector< std::string,std::allocator< std::string > > const &":
        """
        const
        std::vector<std::string>& gdcm::Sorter::GetFilenames() const

        Return the list of filenames as sorted by the specific algorithm used.
        Empty by default (before Sort() is called) 
        """
        return _gdcmswig.Sorter_GetFilenames(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Sorter::Print(std::ostream &os) const

        Print. 
        """
        return _gdcmswig.Sorter_Print(self, os)


    def AddSelect(self, tag: 'Tag', value: 'char const *') -> "bool":
        """
        bool
        gdcm::Sorter::AddSelect(Tag const &tag, const char *value)

        UNSUPPORTED FOR NOW. 
        """
        return _gdcmswig.Sorter_AddSelect(self, tag, value)


    def SetTagsToRead(self, tags: 'TagSetType') -> "void":
        """
        void
        gdcm::Sorter::SetTagsToRead(std::set< Tag > const &tags)

        Specify a set of tags to be read in during the sort procedure. By
        default this set is empty, in which case the entire image, including
        pixel data, is read in. 
        """
        return _gdcmswig.Sorter_SetTagsToRead(self, tags)


    def SetSortFunction(self, f: 'gdcm::Sorter::SortFunction') -> "void":
        """
        void
        gdcm::Sorter::SetSortFunction(SortFunction f) 
        """
        return _gdcmswig.Sorter_SetSortFunction(self, f)


    def StableSort(self, filenames: 'FilenamesType') -> "bool":
        """
        virtual bool
        gdcm::Sorter::StableSort(std::vector< std::string > const &filenames)

        """
        return _gdcmswig.Sorter_StableSort(self, filenames)


    def __str__(self) -> "char const *":
        return _gdcmswig.Sorter___str__(self)
Sorter_swigregister = _gdcmswig.Sorter_swigregister
Sorter_swigregister(Sorter)

class IPPSorter(Sorter):
    """


    IPPSorter.

    Implement a simple Image Position ( Patient) sorter, along the Image
    Orientation ( Patient) direction. This algorithm does NOT support
    duplicate and will FAIL in case of duplicate IPP. WARNING:  See
    special note for SetZSpacingTolerance when computing the ZSpacing from
    the IPP of each DICOM files (default tolerance for consistent spacing
    is: 1e-6mm)  For more information on Spacing, and how it is defined in
    DICOM, advanced users may refers to:

    http://gdcm.sourceforge.net/wiki/index.php/Imager_Pixel_Spacing

    Bug There are currently a couple of bugs in this implementation:

    Gantry Tilt is not considered (always an error)

    Application programmer should only sort valid DataSet (eg.
    MRImageStorage, CTImageStorage, PETImageStorage)

    C++ includes: gdcmIPPSorter.h 
    """

    __swig_setmethods__ = {}
    for _s in [Sorter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, IPPSorter, name, value)
    __swig_getmethods__ = {}
    for _s in [Sorter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, IPPSorter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::IPPSorter::IPPSorter() """
        this = _gdcmswig.new_IPPSorter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Sort(self, filenames: 'FilenamesType') -> "bool":
        """
        virtual bool
        gdcm::IPPSorter::Sort(std::vector< std::string > const &filenames)

        Main entry point to the sorter. It will execute the filter, option
        should be set before running this function (SetZSpacingTolerance, ...)
        Return value indicate if sorting could be achived. Warning this does
        NOT imply that spacing is consistent, it only means the file are
        sorted according to IPP You should check if ZSpacing is 0 or not to
        deduce if file are actually a 3D volume 
        """
        return _gdcmswig.IPPSorter_Sort(self, filenames)


    def SetComputeZSpacing(self, b: 'bool') -> "void":
        """
        void
        gdcm::IPPSorter::SetComputeZSpacing(bool b)

        Functions related to Z-Spacing computation Set to true when sort
        algorithm should also perform a regular Z-Spacing computation using
        the Image Position ( Patient) Potential reason for failure: ALL slices
        are taken into account, if one slice if missing then ZSpacing will be
        set to 0 since the spacing will not be found to be regular along the
        Series 
        """
        return _gdcmswig.IPPSorter_SetComputeZSpacing(self, b)


    def SetZSpacingTolerance(self, tol: 'double') -> "void":
        """
        void
        gdcm::IPPSorter::SetZSpacingTolerance(double tol)

        Another reason for failure is that that Z-Spacing is only slightly
        changing (eg 1e-3) along the serie, a human can determine that this is
        ok and change the tolerance from its default value: 1e-6 
        """
        return _gdcmswig.IPPSorter_SetZSpacingTolerance(self, tol)


    def GetZSpacingTolerance(self) -> "double":
        """
        double
        gdcm::IPPSorter::GetZSpacingTolerance() const 
        """
        return _gdcmswig.IPPSorter_GetZSpacingTolerance(self)


    def SetDirectionCosinesTolerance(self, tol: 'double') -> "void":
        """
        void gdcm::IPPSorter::SetDirectionCosinesTolerance(double tol)

        Sometimes IOP along a series is slightly changing for example:
        "0.999081\\\\0.0426953\\\\0.00369272\\\\-0.0419025\\\\0.955059\\\\0.293439",
        "0.999081\\\\0.0426953\\\\0.00369275\\\\-0.0419025\\\\0.955059\\\\0.293439",
        "0.999081\\\\0.0426952\\\\0.00369272\\\\-0.0419025\\\\0.955059\\\\0.293439",
        We need an API to define the tolerance which is allowed. Internally
        the cross vector of each direction cosines is computed. The tolerance
        then define the distance in between 1.0 to the dot product of those
        cross vectors. In a perfect world this dot product is of course 1.0
        which imply a DirectionCosines tolerance of exactly 0.0 (default). 
        """
        return _gdcmswig.IPPSorter_SetDirectionCosinesTolerance(self, tol)


    def GetDirectionCosinesTolerance(self) -> "double":
        """double gdcm::IPPSorter::GetDirectionCosinesTolerance() const """
        return _gdcmswig.IPPSorter_GetDirectionCosinesTolerance(self)


    def SetDropDuplicatePositions(self, b: 'bool') -> "void":
        """
        void gdcm::IPPSorter::SetDropDuplicatePositions(bool b)

        Makes the IPPSorter ignore multiple images located at the same
        position. Only the first occurrence will be kept.
        DropDuplicatePositions defaults to false. 
        """
        return _gdcmswig.IPPSorter_SetDropDuplicatePositions(self, b)


    def GetZSpacing(self) -> "double":
        """
        double
        gdcm::IPPSorter::GetZSpacing() const

        Read-only function to provide access to the computed value for the
        Z-Spacing The ComputeZSpacing must have been set to true before
        execution of sort algorithm. Call this function after calling Sort();
        Z-Spacing will be 0 on 2 occasions: Sorting simply failed, potentially
        duplicate IPP => ZSpacing = 0

        ZSpacing could not be computed (Z-Spacing is not constant, or
        ZTolerance is too low) 
        """
        return _gdcmswig.IPPSorter_GetZSpacing(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.IPPSorter___str__(self)
    __swig_destroy__ = _gdcmswig.delete_IPPSorter
    __del__ = lambda self: None
IPPSorter_swigregister = _gdcmswig.IPPSorter_swigregister
IPPSorter_swigregister(IPPSorter)

class Spectroscopy(_object):
    """


    Spectroscopy class.

    C++ includes: gdcmSpectroscopy.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spectroscopy, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Spectroscopy, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Spectroscopy::Spectroscopy() """
        this = _gdcmswig.new_Spectroscopy()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Spectroscopy
    __del__ = lambda self: None
Spectroscopy_swigregister = _gdcmswig.Spectroscopy_swigregister
Spectroscopy_swigregister(Spectroscopy)

class Printer(_object):
    """


    Printer class.

    C++ includes: gdcmPrinter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Printer, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Printer, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Printer::Printer() """
        this = _gdcmswig.new_Printer()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Printer
    __del__ = lambda self: None

    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::Printer::SetFile(File const &f)

        Set file. 
        """
        return _gdcmswig.Printer_SetFile(self, f)


    def SetColor(self, c: 'bool') -> "void":
        """
        void
        gdcm::Printer::SetColor(bool c)

        Set color mode or not. 
        """
        return _gdcmswig.Printer_SetColor(self, c)

    VERBOSE_STYLE = _gdcmswig.Printer_VERBOSE_STYLE
    CONDENSED_STYLE = _gdcmswig.Printer_CONDENSED_STYLE
    XML = _gdcmswig.Printer_XML
    CXX = _gdcmswig.Printer_CXX

    def SetStyle(self, ps: 'gdcm::Printer::PrintStyles') -> "void":
        """
        void
        gdcm::Printer::SetStyle(PrintStyles ps)

        Set PrintStyle value. 
        """
        return _gdcmswig.Printer_SetStyle(self, ps)


    def GetPrintStyle(self) -> "gdcm::Printer::PrintStyles":
        """
        PrintStyles
        gdcm::Printer::GetPrintStyle() const

        Get PrintStyle value. 
        """
        return _gdcmswig.Printer_GetPrintStyle(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Printer::Print(std::ostream &os)

        Print. 
        """
        return _gdcmswig.Printer_Print(self, os)


    def PrintDataSet(self, *args) -> "void":
        """
        void
        gdcm::Printer::PrintDataSet(const DataSet &ds, std::ostream &os, const
        std::string &s="")

        Print an individual dataset. 
        """
        return _gdcmswig.Printer_PrintDataSet(self, *args)

Printer_swigregister = _gdcmswig.Printer_swigregister
Printer_swigregister(Printer)

class XMLPrinter(_object):
    """
    C++ includes:
    gdcmXMLPrinter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, XMLPrinter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, XMLPrinter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::XMLPrinter::XMLPrinter() """
        this = _gdcmswig.new_XMLPrinter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_XMLPrinter
    __del__ = lambda self: None

    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::XMLPrinter::SetFile(File const &f) 
        """
        return _gdcmswig.XMLPrinter_SetFile(self, f)

    OnlyUUID = _gdcmswig.XMLPrinter_OnlyUUID
    LOADBULKDATA = _gdcmswig.XMLPrinter_LOADBULKDATA

    def SetStyle(self, ps: 'gdcm::XMLPrinter::PrintStyles') -> "void":
        """
        void
        gdcm::XMLPrinter::SetStyle(PrintStyles ps) 
        """
        return _gdcmswig.XMLPrinter_SetStyle(self, ps)


    def GetPrintStyle(self) -> "gdcm::XMLPrinter::PrintStyles":
        """
        PrintStyles
        gdcm::XMLPrinter::GetPrintStyle() const 
        """
        return _gdcmswig.XMLPrinter_GetPrintStyle(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::XMLPrinter::Print(std::ostream &os) 
        """
        return _gdcmswig.XMLPrinter_Print(self, os)


    def PrintDataSet(self, ds: 'DataSet', ts: 'TransferSyntax', os: 'std::ostream &') -> "void":
        """
        void
        gdcm::XMLPrinter::PrintDataSet(const DataSet &ds, const TransferSyntax
        &ts, std::ostream &os) 
        """
        return _gdcmswig.XMLPrinter_PrintDataSet(self, ds, ts, os)


    def HandleBulkData(self, uuid: 'char const *', ts: 'TransferSyntax', bulkdata: 'char const *', bulklen: 'size_t') -> "void":
        """
        virtual void
        gdcm::XMLPrinter::HandleBulkData(const char *uuid, const
        TransferSyntax &ts, const char *bulkdata, size_t bulklen)

        Virtual function mechanism to allow application programmer to override
        the default mechanism for BulkData handling. By default GDCM will
        simply discard the BulkData and only write the UUID 
        """
        return _gdcmswig.XMLPrinter_HandleBulkData(self, uuid, ts, bulkdata, bulklen)

XMLPrinter_swigregister = _gdcmswig.XMLPrinter_swigregister
XMLPrinter_swigregister(XMLPrinter)

class Dumper(Printer):
    """


    Codec class.

    Use it to simply dump value read from the file. No interpretation is
    done. But it is real fast ! Almost no overhead

    C++ includes: gdcmDumper.h 
    """

    __swig_setmethods__ = {}
    for _s in [Printer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Dumper, name, value)
    __swig_getmethods__ = {}
    for _s in [Printer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Dumper, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Dumper::Dumper()

        """
        this = _gdcmswig.new_Dumper()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Dumper
    __del__ = lambda self: None
Dumper_swigregister = _gdcmswig.Dumper_swigregister
Dumper_swigregister(Dumper)

class Orientation(_object):
    """


    class to handle Orientation

    C++ includes: gdcmOrientation.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Orientation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Orientation, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Orientation::Orientation() """
        this = _gdcmswig.new_Orientation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Orientation
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::Orientation::Print(std::ostream &) const

        Print. 
        """
        return _gdcmswig.Orientation_Print(self, arg2)

    UNKNOWN = _gdcmswig.Orientation_UNKNOWN
    AXIAL = _gdcmswig.Orientation_AXIAL
    CORONAL = _gdcmswig.Orientation_CORONAL
    SAGITTAL = _gdcmswig.Orientation_SAGITTAL
    OBLIQUE = _gdcmswig.Orientation_OBLIQUE
    if _newclass:
        GetType = staticmethod(_gdcmswig.Orientation_GetType)
    else:
        GetType = _gdcmswig.Orientation_GetType
    if _newclass:
        SetObliquityThresholdCosineValue = staticmethod(_gdcmswig.Orientation_SetObliquityThresholdCosineValue)
    else:
        SetObliquityThresholdCosineValue = _gdcmswig.Orientation_SetObliquityThresholdCosineValue
    if _newclass:
        GetObliquityThresholdCosineValue = staticmethod(_gdcmswig.Orientation_GetObliquityThresholdCosineValue)
    else:
        GetObliquityThresholdCosineValue = _gdcmswig.Orientation_GetObliquityThresholdCosineValue
    if _newclass:
        GetLabel = staticmethod(_gdcmswig.Orientation_GetLabel)
    else:
        GetLabel = _gdcmswig.Orientation_GetLabel

    def __str__(self) -> "char const *":
        return _gdcmswig.Orientation___str__(self)
Orientation_swigregister = _gdcmswig.Orientation_swigregister
Orientation_swigregister(Orientation)

def Orientation_GetType(dircos: 'double const [6]') -> "gdcm::Orientation::OrientationType":
    return _gdcmswig.Orientation_GetType(dircos)
Orientation_GetType = _gdcmswig.Orientation_GetType

def Orientation_SetObliquityThresholdCosineValue(val: 'double') -> "void":
    return _gdcmswig.Orientation_SetObliquityThresholdCosineValue(val)
Orientation_SetObliquityThresholdCosineValue = _gdcmswig.Orientation_SetObliquityThresholdCosineValue

def Orientation_GetObliquityThresholdCosineValue() -> "double":
    return _gdcmswig.Orientation_GetObliquityThresholdCosineValue()
Orientation_GetObliquityThresholdCosineValue = _gdcmswig.Orientation_GetObliquityThresholdCosineValue

def Orientation_GetLabel(type: 'gdcm::Orientation::OrientationType') -> "char const *":
    return _gdcmswig.Orientation_GetLabel(type)
Orientation_GetLabel = _gdcmswig.Orientation_GetLabel

class DirectionCosines(_object):
    """


    class to handle DirectionCosines

    C++ includes: gdcmDirectionCosines.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DirectionCosines, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DirectionCosines, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::DirectionCosines::DirectionCosines(const double dircos[6]) """
        this = _gdcmswig.new_DirectionCosines(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DirectionCosines
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::DirectionCosines::Print(std::ostream &) const

        Print. 
        """
        return _gdcmswig.DirectionCosines_Print(self, arg2)


    def Cross(self, z: 'double [3]') -> "void":
        """
        void
        gdcm::DirectionCosines::Cross(double z[3]) const

        Compute Cross product. 
        """
        return _gdcmswig.DirectionCosines_Cross(self, z)


    def Dot(*args) -> "double":
        """
        double
        gdcm::DirectionCosines::Dot() const

        Compute Dot. 
        """
        return _gdcmswig.DirectionCosines_Dot(*args)

    Dot = staticmethod(Dot)

    def Normalize(*args) -> "void":
        """
        void
        gdcm::DirectionCosines::Normalize()

        Normalize in-place. 
        """
        return _gdcmswig.DirectionCosines_Normalize(*args)

    Normalize = staticmethod(Normalize)

    def IsValid(self) -> "bool":
        """
        bool
        gdcm::DirectionCosines::IsValid() const

        Return whether or not this is a valid direction cosines. 
        """
        return _gdcmswig.DirectionCosines_IsValid(self)


    def SetFromString(self, str: 'char const *') -> "bool":
        """
        bool
        gdcm::DirectionCosines::SetFromString(const char *str)

        Initialize from string str. It requires 6 floating point separated by
        a backslash character. 
        """
        return _gdcmswig.DirectionCosines_SetFromString(self, str)


    def CrossDot(self, dc: 'DirectionCosines') -> "double":
        """
        double
        gdcm::DirectionCosines::CrossDot(DirectionCosines const &dc) const

        Compute the Dot product of the two cross vector of both
        DirectionCosines object. 
        """
        return _gdcmswig.DirectionCosines_CrossDot(self, dc)


    def ComputeDistAlongNormal(self, ipp: 'double const [3]') -> "double":
        """
        double gdcm::DirectionCosines::ComputeDistAlongNormal(const double
        ipp[3]) const

        Compute the distance along the normal. 
        """
        return _gdcmswig.DirectionCosines_ComputeDistAlongNormal(self, ipp)


    def __str__(self) -> "char const *":
        return _gdcmswig.DirectionCosines___str__(self)
DirectionCosines_swigregister = _gdcmswig.DirectionCosines_swigregister
DirectionCosines_swigregister(DirectionCosines)

def DirectionCosines_Dot(*args) -> "double":
    """
    double
    gdcm::DirectionCosines::Dot() const

    Compute Dot. 
    """
    return _gdcmswig.DirectionCosines_Dot(*args)

def DirectionCosines_Normalize(*args) -> "void":
    """
    void
    gdcm::DirectionCosines::Normalize()

    Normalize in-place. 
    """
    return _gdcmswig.DirectionCosines_Normalize(*args)

class Fiducials(_object):
    """


    Fiducials.

    C++ includes: gdcmFiducials.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Fiducials, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Fiducials, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Fiducials::Fiducials() """
        this = _gdcmswig.new_Fiducials()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Fiducials
    __del__ = lambda self: None
Fiducials_swigregister = _gdcmswig.Fiducials_swigregister
Fiducials_swigregister(Fiducials)

class Waveform(_object):
    """


    Waveform class.

    C++ includes: gdcmWaveform.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Waveform, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Waveform, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Waveform::Waveform() """
        this = _gdcmswig.new_Waveform()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Waveform
    __del__ = lambda self: None
Waveform_swigregister = _gdcmswig.Waveform_swigregister
Waveform_swigregister(Waveform)

class PersonName(_object):
    """


    PersonName class.

    C++ includes: gdcmPersonName.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PersonName, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PersonName, name)
    __repr__ = _swig_repr
    MaxNumberOfComponents = _gdcmswig.PersonName_MaxNumberOfComponents
    MaxLength = _gdcmswig.PersonName_MaxLength
    __swig_setmethods__["Component"] = _gdcmswig.PersonName_Component_set
    __swig_getmethods__["Component"] = _gdcmswig.PersonName_Component_get
    if _newclass:
        Component = _swig_property(_gdcmswig.PersonName_Component_get, _gdcmswig.PersonName_Component_set)
    Separator = _gdcmswig.PersonName_Separator
    Padding = _gdcmswig.PersonName_Padding

    def GetNumberOfComponents(self) -> "unsigned int":
        """unsigned int gdcm::PersonName::GetNumberOfComponents() const """
        return _gdcmswig.PersonName_GetNumberOfComponents(self)


    def GetMaxLength(self) -> "unsigned int":
        """
        unsigned int
        gdcm::PersonName::GetMaxLength() const 
        """
        return _gdcmswig.PersonName_GetMaxLength(self)


    def SetBlob(self, v: 'std::vector< char,std::allocator< char > > const &') -> "void":
        """
        void
        gdcm::PersonName::SetBlob(const std::vector< char > &v) 
        """
        return _gdcmswig.PersonName_SetBlob(self, v)


    def SetComponents(self, *args) -> "void":
        """
        void
        gdcm::PersonName::SetComponents(const char *components[]) 
        """
        return _gdcmswig.PersonName_SetComponents(self, *args)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::PersonName::Print(std::ostream &os) const 
        """
        return _gdcmswig.PersonName_Print(self, os)


    def __init__(self):
        this = _gdcmswig.new_PersonName()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PersonName
    __del__ = lambda self: None
PersonName_swigregister = _gdcmswig.PersonName_swigregister
PersonName_swigregister(PersonName)

class Curve(Object):
    """


    Curve class to handle element 50xx,3000 Curve Data.

    WARNING: This is deprecated and lastly defined in PS 3.3 - 2004

    Examples: GE_DLX-8-MONO2-Multiframe-Jpeg_Lossless.dcm

    GE_DLX-8-MONO2-Multiframe.dcm

    gdcmSampleData/Philips_Medical_Images/integris_HV_5000/xa_integris.dcm

    TOSHIBA-CurveData[1-3].dcm

    C++ includes: gdcmCurve.h 
    """

    __swig_setmethods__ = {}
    for _s in [Object]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, Curve, name, value)
    __swig_getmethods__ = {}
    for _s in [Object]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, Curve, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Curve
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::Curve::Print(std::ostream &) const 
        """
        return _gdcmswig.Curve_Print(self, arg2)


    def GetAsPoints(self, array: 'float *') -> "void":
        """
        void
        gdcm::Curve::GetAsPoints(float *array) const 
        """
        return _gdcmswig.Curve_GetAsPoints(self, array)

    if _newclass:
        GetNumberOfCurves = staticmethod(_gdcmswig.Curve_GetNumberOfCurves)
    else:
        GetNumberOfCurves = _gdcmswig.Curve_GetNumberOfCurves

    def Update(self, de: 'DataElement') -> "void":
        """
        void
        gdcm::Curve::Update(const DataElement &de) 
        """
        return _gdcmswig.Curve_Update(self, de)


    def SetGroup(self, group: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetGroup(unsigned short group) 
        """
        return _gdcmswig.Curve_SetGroup(self, group)


    def GetGroup(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Curve::GetGroup() const 
        """
        return _gdcmswig.Curve_GetGroup(self)


    def SetDimensions(self, dimensions: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetDimensions(unsigned short dimensions) 
        """
        return _gdcmswig.Curve_SetDimensions(self, dimensions)


    def GetDimensions(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Curve::GetDimensions() const 
        """
        return _gdcmswig.Curve_GetDimensions(self)


    def SetNumberOfPoints(self, numberofpoints: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetNumberOfPoints(unsigned short numberofpoints) 
        """
        return _gdcmswig.Curve_SetNumberOfPoints(self, numberofpoints)


    def GetNumberOfPoints(self) -> "unsigned short":
        """
        unsigned short
        gdcm::Curve::GetNumberOfPoints() const 
        """
        return _gdcmswig.Curve_GetNumberOfPoints(self)


    def SetTypeOfData(self, typeofdata: 'char const *') -> "void":
        """
        void
        gdcm::Curve::SetTypeOfData(const char *typeofdata) 
        """
        return _gdcmswig.Curve_SetTypeOfData(self, typeofdata)


    def GetTypeOfData(self) -> "char const *":
        """
        const char*
        gdcm::Curve::GetTypeOfData() const 
        """
        return _gdcmswig.Curve_GetTypeOfData(self)


    def GetTypeOfDataDescription(self) -> "char const *":
        """
        const
        char* gdcm::Curve::GetTypeOfDataDescription() const 
        """
        return _gdcmswig.Curve_GetTypeOfDataDescription(self)


    def SetCurveDescription(self, curvedescription: 'char const *') -> "void":
        """
        void
        gdcm::Curve::SetCurveDescription(const char *curvedescription) 
        """
        return _gdcmswig.Curve_SetCurveDescription(self, curvedescription)


    def SetDataValueRepresentation(self, datavaluerepresentation: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetDataValueRepresentation(unsigned short
        datavaluerepresentation) 
        """
        return _gdcmswig.Curve_SetDataValueRepresentation(self, datavaluerepresentation)


    def GetDataValueRepresentation(self) -> "unsigned short":
        """unsigned short gdcm::Curve::GetDataValueRepresentation() const """
        return _gdcmswig.Curve_GetDataValueRepresentation(self)


    def SetCurveDataDescriptor(self, values: 'uint16_t const *', num: 'size_t') -> "void":
        """
        void
        gdcm::Curve::SetCurveDataDescriptor(const uint16_t *values, size_t
        num) 
        """
        return _gdcmswig.Curve_SetCurveDataDescriptor(self, values, num)


    def GetCurveDataDescriptor(self) -> "std::vector< unsigned short,std::allocator< unsigned short > > const &":
        """
        std::vector<unsigned short> const&
        gdcm::Curve::GetCurveDataDescriptor() const 
        """
        return _gdcmswig.Curve_GetCurveDataDescriptor(self)


    def SetCoordinateStartValue(self, v: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetCoordinateStartValue(unsigned short v) 
        """
        return _gdcmswig.Curve_SetCoordinateStartValue(self, v)


    def SetCoordinateStepValue(self, v: 'unsigned short') -> "void":
        """
        void
        gdcm::Curve::SetCoordinateStepValue(unsigned short v) 
        """
        return _gdcmswig.Curve_SetCoordinateStepValue(self, v)


    def SetCurve(self, array: 'char const *', length: 'unsigned int') -> "void":
        """
        void
        gdcm::Curve::SetCurve(const char *array, unsigned int length) 
        """
        return _gdcmswig.Curve_SetCurve(self, array, length)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Curve::IsEmpty() const 
        """
        return _gdcmswig.Curve_IsEmpty(self)


    def Decode(self, arg2: 'std::istream &', os: 'std::ostream &') -> "void":
        """
        void
        gdcm::Curve::Decode(std::istream &is, std::ostream &os) 
        """
        return _gdcmswig.Curve_Decode(self, arg2, os)


    def __init__(self, *args):
        """
        gdcm::Curve::Curve(Curve
        const &ov) 
        """
        this = _gdcmswig.new_Curve(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
Curve_swigregister = _gdcmswig.Curve_swigregister
Curve_swigregister(Curve)

def Curve_GetNumberOfCurves(ds: 'DataSet') -> "unsigned int":
    return _gdcmswig.Curve_GetNumberOfCurves(ds)
Curve_GetNumberOfCurves = _gdcmswig.Curve_GetNumberOfCurves

class DICOMDIR(_object):
    """


    DICOMDIR class.

    Structured for handling DICOMDIR

    C++ includes: gdcmDICOMDIR.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DICOMDIR, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DICOMDIR, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::DICOMDIR::DICOMDIR(const FileSet &fs) """
        this = _gdcmswig.new_DICOMDIR(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DICOMDIR
    __del__ = lambda self: None
DICOMDIR_swigregister = _gdcmswig.DICOMDIR_swigregister
DICOMDIR_swigregister(DICOMDIR)

class Validate(_object):
    """


    Validate class.

    C++ includes: gdcmValidate.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Validate, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Validate, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Validate::Validate() """
        this = _gdcmswig.new_Validate()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Validate
    __del__ = lambda self: None

    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::Validate::SetFile(File const &f) 
        """
        return _gdcmswig.Validate_SetFile(self, f)


    def GetValidatedFile(self) -> "gdcm::File const &":
        """
        const File&
        gdcm::Validate::GetValidatedFile() 
        """
        return _gdcmswig.Validate_GetValidatedFile(self)


    def Validation(self) -> "void":
        """
        void
        gdcm::Validate::Validation() 
        """
        return _gdcmswig.Validate_Validation(self)

Validate_swigregister = _gdcmswig.Validate_swigregister
Validate_swigregister(Validate)

class ApplicationEntity(_object):
    """


    ApplicationEntity.

    AE Application Entity

    A string of characters that identifies an Application Entity with
    leading and trailing spaces (20H) being non-significant. A value
    consisting solely of spaces shall not be used.

    Default Character Repertoire excluding character code 5CH (the
    BACKSLASH \\ in ISO-IR 6), and control characters LF, FF, CR and
    ESC.

    16 bytes maximum

    C++ includes: gdcmApplicationEntity.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ApplicationEntity, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ApplicationEntity, name)
    __repr__ = _swig_repr
    MaxNumberOfComponents = _gdcmswig.ApplicationEntity_MaxNumberOfComponents
    MaxLength = _gdcmswig.ApplicationEntity_MaxLength
    __swig_setmethods__["Internal"] = _gdcmswig.ApplicationEntity_Internal_set
    __swig_getmethods__["Internal"] = _gdcmswig.ApplicationEntity_Internal_get
    if _newclass:
        Internal = _swig_property(_gdcmswig.ApplicationEntity_Internal_get, _gdcmswig.ApplicationEntity_Internal_set)
    Separator = _gdcmswig.ApplicationEntity_Separator
    Padding = _gdcmswig.ApplicationEntity_Padding

    def IsValid(self) -> "bool":
        """
        bool
        gdcm::ApplicationEntity::IsValid() const 
        """
        return _gdcmswig.ApplicationEntity_IsValid(self)


    def Squeeze(self) -> "void":
        """
        void
        gdcm::ApplicationEntity::Squeeze() 
        """
        return _gdcmswig.ApplicationEntity_Squeeze(self)


    def SetBlob(self, v: 'std::vector< char,std::allocator< char > > const &') -> "void":
        """
        void
        gdcm::ApplicationEntity::SetBlob(const std::vector< char > &v) 
        """
        return _gdcmswig.ApplicationEntity_SetBlob(self, v)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::ApplicationEntity::Print(std::ostream &os) const 
        """
        return _gdcmswig.ApplicationEntity_Print(self, os)


    def __init__(self):
        this = _gdcmswig.new_ApplicationEntity()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ApplicationEntity
    __del__ = lambda self: None
ApplicationEntity_swigregister = _gdcmswig.ApplicationEntity_swigregister
ApplicationEntity_swigregister(ApplicationEntity)

class DictPrinter(Printer):
    """


    DictPrinter class.

    C++ includes: gdcmDictPrinter.h 
    """

    __swig_setmethods__ = {}
    for _s in [Printer]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, DictPrinter, name, value)
    __swig_getmethods__ = {}
    for _s in [Printer]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, DictPrinter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::DictPrinter::DictPrinter() """
        this = _gdcmswig.new_DictPrinter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DictPrinter
    __del__ = lambda self: None

    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::DictPrinter::Print(std::ostream &os) 
        """
        return _gdcmswig.DictPrinter_Print(self, os)

DictPrinter_swigregister = _gdcmswig.DictPrinter_swigregister
DictPrinter_swigregister(DictPrinter)

class FilenameGenerator(_object):
    """


    FilenameGenerator.

    class to generate filenames based on a pattern (C-style)

    Output will be:

    for i = 0, number of filenames: outfilename[i] = prefix + (pattern %
    i)

    where pattern % i means C-style snprintf of Pattern using value 'i'

    C++ includes: gdcmFilenameGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FilenameGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FilenameGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FilenameGenerator::FilenameGenerator() """
        this = _gdcmswig.new_FilenameGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FilenameGenerator
    __del__ = lambda self: None

    def SetPattern(self, pattern: 'char const *') -> "void":
        """
        void
        gdcm::FilenameGenerator::SetPattern(const char *pattern)

        Set/Get pattern. 
        """
        return _gdcmswig.FilenameGenerator_SetPattern(self, pattern)


    def GetPattern(self) -> "char const *":
        """
        const
        char* gdcm::FilenameGenerator::GetPattern() const 
        """
        return _gdcmswig.FilenameGenerator_GetPattern(self)


    def SetPrefix(self, prefix: 'char const *') -> "void":
        """
        void
        gdcm::FilenameGenerator::SetPrefix(const char *prefix)

        Set/Get prefix. 
        """
        return _gdcmswig.FilenameGenerator_SetPrefix(self, prefix)


    def GetPrefix(self) -> "char const *":
        """
        const
        char* gdcm::FilenameGenerator::GetPrefix() const 
        """
        return _gdcmswig.FilenameGenerator_GetPrefix(self)


    def Generate(self) -> "bool":
        """
        bool
        gdcm::FilenameGenerator::Generate()

        Generate (return success) 
        """
        return _gdcmswig.FilenameGenerator_Generate(self)


    def SetNumberOfFilenames(self, nfiles: 'gdcm::FilenameGenerator::SizeType') -> "void":
        """
        void gdcm::FilenameGenerator::SetNumberOfFilenames(SizeType nfiles)

        Set/Get the number of filenames to generate. 
        """
        return _gdcmswig.FilenameGenerator_SetNumberOfFilenames(self, nfiles)


    def GetNumberOfFilenames(self) -> "gdcm::FilenameGenerator::SizeType":
        """SizeType gdcm::FilenameGenerator::GetNumberOfFilenames() const """
        return _gdcmswig.FilenameGenerator_GetNumberOfFilenames(self)


    def GetFilename(self, n: 'gdcm::FilenameGenerator::SizeType') -> "char const *":
        """
        const
        char* gdcm::FilenameGenerator::GetFilename(SizeType n) const

        Get a particular filename (call after Generate) 
        """
        return _gdcmswig.FilenameGenerator_GetFilename(self, n)


    def GetFilenames(self) -> "gdcm::FilenameGenerator::FilenamesType const &":
        """
        FilenamesType const& gdcm::FilenameGenerator::GetFilenames() const

        Return all filenames. 
        """
        return _gdcmswig.FilenameGenerator_GetFilenames(self)

FilenameGenerator_swigregister = _gdcmswig.FilenameGenerator_swigregister
FilenameGenerator_swigregister(FilenameGenerator)

class Version(_object):
    """


    major/minor and build version

    C++ includes: gdcmVersion.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Version, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Version, name)
    __repr__ = _swig_repr
    if _newclass:
        GetVersion = staticmethod(_gdcmswig.Version_GetVersion)
    else:
        GetVersion = _gdcmswig.Version_GetVersion
    if _newclass:
        GetMajorVersion = staticmethod(_gdcmswig.Version_GetMajorVersion)
    else:
        GetMajorVersion = _gdcmswig.Version_GetMajorVersion
    if _newclass:
        GetMinorVersion = staticmethod(_gdcmswig.Version_GetMinorVersion)
    else:
        GetMinorVersion = _gdcmswig.Version_GetMinorVersion
    if _newclass:
        GetBuildVersion = staticmethod(_gdcmswig.Version_GetBuildVersion)
    else:
        GetBuildVersion = _gdcmswig.Version_GetBuildVersion

    def Print(self, *args) -> "void":
        """
        void
        gdcm::Version::Print(std::ostream &os=std::cout) const 
        """
        return _gdcmswig.Version_Print(self, *args)


    def __init__(self):
        """gdcm::Version::Version() """
        this = _gdcmswig.new_Version()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Version
    __del__ = lambda self: None

    def __str__(self) -> "char const *":
        return _gdcmswig.Version___str__(self)
Version_swigregister = _gdcmswig.Version_swigregister
Version_swigregister(Version)

def Version_GetVersion() -> "char const *":
    return _gdcmswig.Version_GetVersion()
Version_GetVersion = _gdcmswig.Version_GetVersion

def Version_GetMajorVersion() -> "int":
    return _gdcmswig.Version_GetMajorVersion()
Version_GetMajorVersion = _gdcmswig.Version_GetMajorVersion

def Version_GetMinorVersion() -> "int":
    return _gdcmswig.Version_GetMinorVersion()
Version_GetMinorVersion = _gdcmswig.Version_GetMinorVersion

def Version_GetBuildVersion() -> "int":
    return _gdcmswig.Version_GetBuildVersion()
Version_GetBuildVersion = _gdcmswig.Version_GetBuildVersion

class Filename(_object):
    """


    Class to manipulate file name's.

    OS independant representation of a filename (to query path, name and
    extension from a filename)

    C++ includes: gdcmFilename.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Filename, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Filename, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::Filename::Filename(const char *filename="") """
        this = _gdcmswig.new_Filename(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetFileName(self) -> "char const *":
        """
        const char*
        gdcm::Filename::GetFileName() const

        Return the full filename. 
        """
        return _gdcmswig.Filename_GetFileName(self)


    def GetPath(self) -> "char const *":
        """
        const char*
        gdcm::Filename::GetPath()

        Return only the path component of a filename. 
        """
        return _gdcmswig.Filename_GetPath(self)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::Filename::GetName()

        return only the name part of a filename 
        """
        return _gdcmswig.Filename_GetName(self)


    def GetExtension(self) -> "char const *":
        """
        const char*
        gdcm::Filename::GetExtension()

        return only the extension part of a filename 
        """
        return _gdcmswig.Filename_GetExtension(self)


    def ToUnixSlashes(self) -> "char const *":
        """
        const char*
        gdcm::Filename::ToUnixSlashes()

        Convert backslash (windows style) to UNIX style slash. 
        """
        return _gdcmswig.Filename_ToUnixSlashes(self)


    def ToWindowsSlashes(self) -> "char const *":
        """
        const char*
        gdcm::Filename::ToWindowsSlashes()

        Convert forward slash (UNIX style) to windows style slash. 
        """
        return _gdcmswig.Filename_ToWindowsSlashes(self)

    if _newclass:
        Join = staticmethod(_gdcmswig.Filename_Join)
    else:
        Join = _gdcmswig.Filename_Join

    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Filename::IsEmpty() const

        return whether the filename is empty 
        """
        return _gdcmswig.Filename_IsEmpty(self)


    def IsIdentical(self, fn: 'Filename') -> "bool":
        """
        bool
        gdcm::Filename::IsIdentical(Filename const &fn) const 
        """
        return _gdcmswig.Filename_IsIdentical(self, fn)


    def EndWith(self, ending: 'char const []') -> "bool":
        """
        bool
        gdcm::Filename::EndWith(const char ending[]) const

        Does the filename ends with a particular string ? 
        """
        return _gdcmswig.Filename_EndWith(self, ending)

    __swig_destroy__ = _gdcmswig.delete_Filename
    __del__ = lambda self: None
Filename_swigregister = _gdcmswig.Filename_swigregister
Filename_swigregister(Filename)

def Filename_Join(path: 'char const *', filename: 'char const *') -> "char const *":
    return _gdcmswig.Filename_Join(path, filename)
Filename_Join = _gdcmswig.Filename_Join

class EnumeratedValues(_object):
    """


    Element. A Data Element with Enumerated Values that does not have a
    Value equivalent to one of the Values specified in this standard has
    an invalid value within the scope of a specific Information Object/SOP
    Class definition. Note:

    Patient Sex (0010, 0040) is an example of a Data Element having
    Enumerated Values. It is defined to have a Value that is either "M",
    "F", or "O" (see PS 3.3). No other Value shall be given to this
    Data Element.

    Future modifications of this standard may add to the set of allowed
    values for Data Elements with Enumerated Values. Such additions by
    themselves may or may not require a change in SOP Class UIDs,
    depending on the semantics of the Data Element.

    C++ includes: gdcmEnumeratedValues.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EnumeratedValues, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EnumeratedValues, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::EnumeratedValues::EnumeratedValues() """
        this = _gdcmswig.new_EnumeratedValues()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_EnumeratedValues
    __del__ = lambda self: None
EnumeratedValues_swigregister = _gdcmswig.EnumeratedValues_swigregister
EnumeratedValues_swigregister(EnumeratedValues)

class Patient(_object):
    """


    See PS 3.3 - 2007 DICOM MODEL OF THE REAL-WORLD, p 54.

    C++ includes: gdcmPatient.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Patient, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Patient, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Patient::Patient() """
        this = _gdcmswig.new_Patient()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Patient
    __del__ = lambda self: None
Patient_swigregister = _gdcmswig.Patient_swigregister
Patient_swigregister(Patient)

class Study(_object):
    """


    Study.

    C++ includes: gdcmStudy.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Study, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Study, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Study::Study() """
        this = _gdcmswig.new_Study()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Study
    __del__ = lambda self: None
Study_swigregister = _gdcmswig.Study_swigregister
Study_swigregister(Study)

class Usage(_object):
    """


    Usage.

    A.1.3 IOD Module Table and Functional Group Macro Table This Section
    of each IOD defines in a tabular form the Modules comprising the IOD.
    The following information must be specified for each Module in the
    table: The name of the Module or Functional Group

    A reference to the Section in Annex C which defines the Module or
    Functional Group

    The usage of the Module or Functional Group; whether it is:

    Mandatory (see A.1.3.1) , abbreviated M

    Conditional (see A.1.3.2) , abbreviated C

    User Option (see A.1.3.3) , abbreviated U The Modules referenced are
    defined in Annex C. A.1.3.1 MANDATORY MODULES For each IOD, Mandatory
    Modules shall be supported per the definitions, semantics and
    requirements defined in Annex C.

    A.1.3.2 CONDITIONAL MODULES Conditional Modules are Mandatory Modules
    if specific conditions are met. If the specified conditions are not
    met, this Module shall not be supported; that is, no information
    defined in that Module shall be sent. A.1.3.3 USER OPTION MODULES User
    Option Modules may or may not be supported. If an optional Module is
    supported, the Attribute Types specified in the Modules in Annex C
    shall be supported.

    C++ includes: gdcmUsage.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Usage, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Usage, name)
    __repr__ = _swig_repr
    Mandatory = _gdcmswig.Usage_Mandatory
    Conditional = _gdcmswig.Usage_Conditional
    UserOption = _gdcmswig.Usage_UserOption
    Invalid = _gdcmswig.Usage_Invalid

    def __init__(self, *args):
        """gdcm::Usage::Usage(UsageType type=Invalid) """
        this = _gdcmswig.new_Usage(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    if _newclass:
        GetUsageString = staticmethod(_gdcmswig.Usage_GetUsageString)
    else:
        GetUsageString = _gdcmswig.Usage_GetUsageString
    if _newclass:
        GetUsageType = staticmethod(_gdcmswig.Usage_GetUsageType)
    else:
        GetUsageType = _gdcmswig.Usage_GetUsageType
    __swig_destroy__ = _gdcmswig.delete_Usage
    __del__ = lambda self: None
Usage_swigregister = _gdcmswig.Usage_swigregister
Usage_swigregister(Usage)

def Usage_GetUsageString(type: 'gdcm::Usage::UsageType') -> "char const *":
    return _gdcmswig.Usage_GetUsageString(type)
Usage_GetUsageString = _gdcmswig.Usage_GetUsageString

def Usage_GetUsageType(type: 'char const *') -> "gdcm::Usage::UsageType":
    return _gdcmswig.Usage_GetUsageType(type)
Usage_GetUsageType = _gdcmswig.Usage_GetUsageType

class ModuleEntry(_object):
    """


    Class for representing a ModuleEntry.

    bla

    See:   DictEntry

    C++ includes: gdcmModuleEntry.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ModuleEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ModuleEntry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::ModuleEntry::ModuleEntry(const char *name="", const char
        *type="3", const char *description="") 
        """
        this = _gdcmswig.new_ModuleEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ModuleEntry
    __del__ = lambda self: None

    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::ModuleEntry::SetName(const char *name) 
        """
        return _gdcmswig.ModuleEntry_SetName(self, name)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::ModuleEntry::GetName() const 
        """
        return _gdcmswig.ModuleEntry_GetName(self)


    def SetType(self, type: 'Type const &') -> "void":
        """
        void
        gdcm::ModuleEntry::SetType(const Type &type) 
        """
        return _gdcmswig.ModuleEntry_SetType(self, type)


    def GetType(self) -> "Type const &":
        """
        const Type&
        gdcm::ModuleEntry::GetType() const 
        """
        return _gdcmswig.ModuleEntry_GetType(self)


    def SetDescription(self, d: 'char const *') -> "void":
        """
        void
        gdcm::ModuleEntry::SetDescription(const char *d) 
        """
        return _gdcmswig.ModuleEntry_SetDescription(self, d)


    def GetDescription(self) -> "gdcm::ModuleEntry::Description const &":
        """
        const
        Description& gdcm::ModuleEntry::GetDescription() const 
        """
        return _gdcmswig.ModuleEntry_GetDescription(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.ModuleEntry___str__(self)
ModuleEntry_swigregister = _gdcmswig.ModuleEntry_swigregister
ModuleEntry_swigregister(ModuleEntry)

class NestedModuleEntries(ModuleEntry):
    """


    Class for representing a NestedModuleEntries.

    bla

    See:   ModuleEntry

    C++ includes: gdcmNestedModuleEntries.h 
    """

    __swig_setmethods__ = {}
    for _s in [ModuleEntry]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, NestedModuleEntries, name, value)
    __swig_getmethods__ = {}
    for _s in [ModuleEntry]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, NestedModuleEntries, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::NestedModuleEntries::NestedModuleEntries(const char
        *name="", const char *type="3", const char *description="") 
        """
        this = _gdcmswig.new_NestedModuleEntries(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def GetNumberOfModuleEntries(self) -> "gdcm::NestedModuleEntries::SizeType":
        """
        SizeType
        gdcm::NestedModuleEntries::GetNumberOfModuleEntries() 
        """
        return _gdcmswig.NestedModuleEntries_GetNumberOfModuleEntries(self)


    def GetModuleEntry(self, *args) -> "gdcm::ModuleEntry &":
        """
        ModuleEntry& gdcm::NestedModuleEntries::GetModuleEntry(SizeType idx)

        """
        return _gdcmswig.NestedModuleEntries_GetModuleEntry(self, *args)


    def AddModuleEntry(self, me: 'ModuleEntry') -> "void":
        """
        void gdcm::NestedModuleEntries::AddModuleEntry(const ModuleEntry &me)

        """
        return _gdcmswig.NestedModuleEntries_AddModuleEntry(self, me)

    __swig_destroy__ = _gdcmswig.delete_NestedModuleEntries
    __del__ = lambda self: None
NestedModuleEntries_swigregister = _gdcmswig.NestedModuleEntries_swigregister
NestedModuleEntries_swigregister(NestedModuleEntries)

class Macro(_object):
    """


    Class for representing a Macro.

    Attribute Macro: a set of Attributes that are described in a single
    table that is referenced by multiple Module or other tables.

    See:   Module

    C++ includes: gdcmMacro.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Macro, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Macro, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Macro::Macro() """
        this = _gdcmswig.new_Macro()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """
        void gdcm::Macro::Clear()

        """
        return _gdcmswig.Macro_Clear(self)


    def AddMacroEntry(self, tag: 'Tag', module: 'ModuleEntry') -> "void":
        """
        void
        gdcm::Macro::AddMacroEntry(const Tag &tag, const MacroEntry &module)

        Will add a ModuleEntry direcly at root-level. See Macro for nested-
        included level. 
        """
        return _gdcmswig.Macro_AddMacroEntry(self, tag, module)


    def FindMacroEntry(self, tag: 'Tag') -> "bool":
        """
        bool
        gdcm::Macro::FindMacroEntry(const Tag &tag) const

        Find or Get a ModuleEntry. ModuleEntry are either search are root-
        level or within nested-macro included in module. 
        """
        return _gdcmswig.Macro_FindMacroEntry(self, tag)


    def GetMacroEntry(self, tag: 'Tag') -> "gdcm::MacroEntry const &":
        """
        const MacroEntry&
        gdcm::Macro::GetMacroEntry(const Tag &tag) const 
        """
        return _gdcmswig.Macro_GetMacroEntry(self, tag)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::Macro::SetName(const char *name) 
        """
        return _gdcmswig.Macro_SetName(self, name)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::Macro::GetName() const 
        """
        return _gdcmswig.Macro_GetName(self)


    def Verify(self, ds: 'DataSet', usage: 'Usage') -> "bool":
        """
        bool
        gdcm::Macro::Verify(const DataSet &ds, Usage const &usage) const 
        """
        return _gdcmswig.Macro_Verify(self, ds, usage)

    __swig_destroy__ = _gdcmswig.delete_Macro
    __del__ = lambda self: None
Macro_swigregister = _gdcmswig.Macro_swigregister
Macro_swigregister(Macro)

class Macros(_object):
    """


    Class for representing a Modules.

    bla

    See:   Module

    C++ includes: gdcmMacros.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Macros, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Macros, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Macros::Macros()

        """
        this = _gdcmswig.new_Macros()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """
        void
        gdcm::Macros::Clear() 
        """
        return _gdcmswig.Macros_Clear(self)


    def AddMacro(self, ref: 'char const *', module: 'Macro') -> "void":
        """
        void
        gdcm::Macros::AddMacro(const char *ref, const Macro &module) 
        """
        return _gdcmswig.Macros_AddMacro(self, ref, module)


    def GetMacro(self, name: 'char const *') -> "gdcm::Macro const &":
        """
        const Macro&
        gdcm::Macros::GetMacro(const char *name) const 
        """
        return _gdcmswig.Macros_GetMacro(self, name)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Macros::IsEmpty() const 
        """
        return _gdcmswig.Macros_IsEmpty(self)

    __swig_destroy__ = _gdcmswig.delete_Macros
    __del__ = lambda self: None
Macros_swigregister = _gdcmswig.Macros_swigregister
Macros_swigregister(Macros)

class Module(_object):
    """


    Class for representing a Module.

    Module: A set of Attributes within an Information Entity or Normalized
    IOD which are logically related to each other.

    See:   Macro

    C++ includes: gdcmModule.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Module, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Module, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Module::Module()

        """
        this = _gdcmswig.new_Module()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """
        void
        gdcm::Module::Clear() 
        """
        return _gdcmswig.Module_Clear(self)


    def AddModuleEntry(self, tag: 'Tag', module: 'ModuleEntry') -> "void":
        """
        void
        gdcm::Module::AddModuleEntry(const Tag &tag, const ModuleEntry
        &module)

        Will add a ModuleEntry direcly at root-level. See Macro for nested-
        included level. 
        """
        return _gdcmswig.Module_AddModuleEntry(self, tag, module)


    def AddMacro(self, include: 'char const *') -> "void":
        """
        void
        gdcm::Module::AddMacro(const char *include) 
        """
        return _gdcmswig.Module_AddMacro(self, include)


    def FindModuleEntryInMacros(self, macros: 'Macros', tag: 'Tag') -> "bool":
        """
        bool
        gdcm::Module::FindModuleEntryInMacros(Macros const &macros, const Tag
        &tag) const

        Find or Get a ModuleEntry. ModuleEntry are either search are root-
        level or within nested-macro included in module. 
        """
        return _gdcmswig.Module_FindModuleEntryInMacros(self, macros, tag)


    def GetModuleEntryInMacros(self, macros: 'Macros', tag: 'Tag') -> "gdcm::ModuleEntry const &":
        """
        const
        ModuleEntry& gdcm::Module::GetModuleEntryInMacros(Macros const
        &macros, const Tag &tag) const 
        """
        return _gdcmswig.Module_GetModuleEntryInMacros(self, macros, tag)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::Module::SetName(const char *name) 
        """
        return _gdcmswig.Module_SetName(self, name)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::Module::GetName() const 
        """
        return _gdcmswig.Module_GetName(self)


    def Verify(self, ds: 'DataSet', usage: 'Usage') -> "bool":
        """
        bool
        gdcm::Module::Verify(const DataSet &ds, Usage const &usage) const 
        """
        return _gdcmswig.Module_Verify(self, ds, usage)

    __swig_destroy__ = _gdcmswig.delete_Module
    __del__ = lambda self: None
Module_swigregister = _gdcmswig.Module_swigregister
Module_swigregister(Module)

class Modules(_object):
    """


    Class for representing a Modules.

    bla

    See:   Module

    C++ includes: gdcmModules.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Modules, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Modules, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Modules::Modules() """
        this = _gdcmswig.new_Modules()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """
        void
        gdcm::Modules::Clear() 
        """
        return _gdcmswig.Modules_Clear(self)


    def AddModule(self, ref: 'char const *', module: 'Module') -> "void":
        """
        void
        gdcm::Modules::AddModule(const char *ref, const Module &module) 
        """
        return _gdcmswig.Modules_AddModule(self, ref, module)


    def GetModule(self, name: 'char const *') -> "gdcm::Module const &":
        """
        const Module&
        gdcm::Modules::GetModule(const char *name) const 
        """
        return _gdcmswig.Modules_GetModule(self, name)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Modules::IsEmpty() const 
        """
        return _gdcmswig.Modules_IsEmpty(self)

    __swig_destroy__ = _gdcmswig.delete_Modules
    __del__ = lambda self: None
Modules_swigregister = _gdcmswig.Modules_swigregister
Modules_swigregister(Modules)

class Defs(_object):
    """


    FIXME I do not like the name ' Defs'.

    bla

    C++ includes: gdcmDefs.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Defs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Defs, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Defs::Defs() """
        this = _gdcmswig.new_Defs()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Defs
    __del__ = lambda self: None

    def GetModules(self, *args) -> "gdcm::Modules &":
        """
        Modules&
        gdcm::Defs::GetModules() 
        """
        return _gdcmswig.Defs_GetModules(self, *args)


    def GetMacros(self, *args) -> "gdcm::Macros &":
        """
        Macros&
        gdcm::Defs::GetMacros() 
        """
        return _gdcmswig.Defs_GetMacros(self, *args)


    def GetIODs(self, *args) -> "IODs &":
        """
        IODs&
        gdcm::Defs::GetIODs() 
        """
        return _gdcmswig.Defs_GetIODs(self, *args)


    def IsEmpty(self) -> "bool":
        """
        bool
        gdcm::Defs::IsEmpty() const 
        """
        return _gdcmswig.Defs_IsEmpty(self)


    def Verify(self, *args) -> "bool":
        """
        bool
        gdcm::Defs::Verify(const DataSet &ds) const 
        """
        return _gdcmswig.Defs_Verify(self, *args)


    def GetTypeFromTag(self, file: 'File', tag: 'Tag') -> "Type":
        """
        Type
        gdcm::Defs::GetTypeFromTag(const File &file, const Tag &tag) const 
        """
        return _gdcmswig.Defs_GetTypeFromTag(self, file, tag)

    if _newclass:
        GetIODNameFromMediaStorage = staticmethod(_gdcmswig.Defs_GetIODNameFromMediaStorage)
    else:
        GetIODNameFromMediaStorage = _gdcmswig.Defs_GetIODNameFromMediaStorage

    def GetIODFromFile(self, file: 'File') -> "gdcm::IOD const &":
        """
        const IOD&
        gdcm::Defs::GetIODFromFile(const File &file) const 
        """
        return _gdcmswig.Defs_GetIODFromFile(self, file)

Defs_swigregister = _gdcmswig.Defs_swigregister
Defs_swigregister(Defs)

def Defs_GetIODNameFromMediaStorage(ms: 'MediaStorage') -> "char const *":
    return _gdcmswig.Defs_GetIODNameFromMediaStorage(ms)
Defs_GetIODNameFromMediaStorage = _gdcmswig.Defs_GetIODNameFromMediaStorage

class IOD(_object):
    """


    Class for representing a IOD.

    bla

    See:   Dict

    C++ includes: gdcmIOD.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IOD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IOD, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::IOD::IOD() """
        this = _gdcmswig.new_IOD()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """void gdcm::IOD::Clear() """
        return _gdcmswig.IOD_Clear(self)


    def AddIODEntry(self, iode: 'IODEntry const &') -> "void":
        """
        void
        gdcm::IOD::AddIODEntry(const IODEntry &iode) 
        """
        return _gdcmswig.IOD_AddIODEntry(self, iode)


    def GetNumberOfIODs(self) -> "gdcm::IOD::SizeType":
        """
        SizeType
        gdcm::IOD::GetNumberOfIODs() const 
        """
        return _gdcmswig.IOD_GetNumberOfIODs(self)


    def GetIODEntry(self, idx: 'gdcm::IOD::SizeType') -> "IODEntry const &":
        """
        const IODEntry&
        gdcm::IOD::GetIODEntry(SizeType idx) const 
        """
        return _gdcmswig.IOD_GetIODEntry(self, idx)


    def GetTypeFromTag(self, defs: 'Defs', tag: 'Tag') -> "Type":
        """
        Type
        gdcm::IOD::GetTypeFromTag(const Defs &defs, const Tag &tag) const 
        """
        return _gdcmswig.IOD_GetTypeFromTag(self, defs, tag)

    __swig_destroy__ = _gdcmswig.delete_IOD
    __del__ = lambda self: None
IOD_swigregister = _gdcmswig.IOD_swigregister
IOD_swigregister(IOD)

class IODs(_object):
    """


    Class for representing a IODs.

    bla

    See:   IOD

    C++ includes: gdcmIODs.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IODs, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IODs, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::IODs::IODs() """
        this = _gdcmswig.new_IODs()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def Clear(self) -> "void":
        """void gdcm::IODs::Clear() """
        return _gdcmswig.IODs_Clear(self)


    def AddIOD(self, name: 'char const *', module: 'IOD') -> "void":
        """
        void
        gdcm::IODs::AddIOD(const char *name, const IOD &module) 
        """
        return _gdcmswig.IODs_AddIOD(self, name, module)


    def GetIOD(self, name: 'char const *') -> "gdcm::IOD const &":
        """
        const IOD&
        gdcm::IODs::GetIOD(const char *name) const 
        """
        return _gdcmswig.IODs_GetIOD(self, name)


    def Begin(self) -> "gdcm::IODs::IODMapTypeConstIterator":
        """
        IODMapTypeConstIterator
        gdcm::IODs::Begin() const 
        """
        return _gdcmswig.IODs_Begin(self)


    def End(self) -> "gdcm::IODs::IODMapTypeConstIterator":
        """
        IODMapTypeConstIterator
        gdcm::IODs::End() const 
        """
        return _gdcmswig.IODs_End(self)

    __swig_destroy__ = _gdcmswig.delete_IODs
    __del__ = lambda self: None
IODs_swigregister = _gdcmswig.IODs_swigregister
IODs_swigregister(IODs)

class TableEntry(_object):
    """


    TableEntry.

    C++ includes: gdcmTableEntry.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TableEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TableEntry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::TableEntry::TableEntry(const char *attribute=0, Type const
        &type=Type(), const char *des=0) 
        """
        this = _gdcmswig.new_TableEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_TableEntry
    __del__ = lambda self: None
TableEntry_swigregister = _gdcmswig.TableEntry_swigregister
TableEntry_swigregister(TableEntry)

class DefinedTerms(_object):
    """


    Defined Terms are used when the specified explicit Values may be
    extended by implementors to include additional new Values. These new
    Values shall be specified in the Conformance Statement (see PS 3.2)
    and shall not have the same meaning as currently defined Values in
    this standard. A Data Element with Defined Terms that does not contain
    a Value equivalent to one of the Values currently specified in this
    standard shall not be considered to have an invalid value. Note:
    Interpretation Type ID (4008,0210) is an example of a Data Element
    having Defined Terms. It is defined to have a Value that may be one of
    the set of standard Values; REPORT or AMENDMENT (see PS 3.3). Because
    this Data Element has Defined Terms other Interpretation Type IDs may
    be defined by the implementor.

    C++ includes: gdcmDefinedTerms.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DefinedTerms, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DefinedTerms, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::DefinedTerms::DefinedTerms() """
        this = _gdcmswig.new_DefinedTerms()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DefinedTerms
    __del__ = lambda self: None
DefinedTerms_swigregister = _gdcmswig.DefinedTerms_swigregister
DefinedTerms_swigregister(DefinedTerms)

class Series(_object):
    """


    Series.

    C++ includes: gdcmSeries.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Series, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Series, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::Series::Series()

        """
        this = _gdcmswig.new_Series()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Series
    __del__ = lambda self: None
Series_swigregister = _gdcmswig.Series_swigregister
Series_swigregister(Series)

class IODEntry(_object):
    """


    Class for representing a IODEntry.

    A.1.3 IOD Module Table and Functional Group Macro Table This Section
    of each IOD defines in a tabular form the Modules comprising the IOD.
    The following information must be specified for each Module in the
    table: The name of the Module or Functional Group

    A reference to the Section in Annex C which defines the Module or
    Functional Group

    The usage of the Module or Functional Group; whether it is:

    Mandatory (see A.1.3.1) , abbreviated M

    Conditional (see A.1.3.2) , abbreviated C

    User Option (see A.1.3.3) , abbreviated U The Modules referenced are
    defined in Annex C. A.1.3.1 MANDATORY MODULES For each IOD, Mandatory
    Modules shall be supported per the definitions, semantics and
    requirements defined in Annex C. PS 3.3 - 2008 Page 96

    Standard - A.1.3.2 CONDITIONAL MODULES Conditional Modules are
    Mandatory Modules if specific conditions are met. If the specified
    conditions are not met, this Module shall not be supported; that is,
    no information defined in that Module shall be sent. A.1.3.3 USER
    OPTION MODULES User Option Modules may or may not be supported. If an
    optional Module is supported, the Attribute Types specified in the
    Modules in Annex C shall be supported.

    See:   DictEntry

    C++ includes: gdcmIODEntry.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IODEntry, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IODEntry, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::IODEntry::IODEntry(const char *name="", const char *ref="",
        const char *usag="") 
        """
        this = _gdcmswig.new_IODEntry(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetIE(self, ie: 'char const *') -> "void":
        """
        void
        gdcm::IODEntry::SetIE(const char *ie) 
        """
        return _gdcmswig.IODEntry_SetIE(self, ie)


    def GetIE(self) -> "char const *":
        """
        const char*
        gdcm::IODEntry::GetIE() const 
        """
        return _gdcmswig.IODEntry_GetIE(self)


    def SetName(self, name: 'char const *') -> "void":
        """
        void
        gdcm::IODEntry::SetName(const char *name) 
        """
        return _gdcmswig.IODEntry_SetName(self, name)


    def GetName(self) -> "char const *":
        """
        const char*
        gdcm::IODEntry::GetName() const 
        """
        return _gdcmswig.IODEntry_GetName(self)


    def SetRef(self, ref: 'char const *') -> "void":
        """
        void
        gdcm::IODEntry::SetRef(const char *ref) 
        """
        return _gdcmswig.IODEntry_SetRef(self, ref)


    def GetRef(self) -> "char const *":
        """
        const char*
        gdcm::IODEntry::GetRef() const 
        """
        return _gdcmswig.IODEntry_GetRef(self)


    def SetUsage(self, usag: 'char const *') -> "void":
        """
        void
        gdcm::IODEntry::SetUsage(const char *usag) 
        """
        return _gdcmswig.IODEntry_SetUsage(self, usag)


    def GetUsage(self) -> "char const *":
        """
        const char*
        gdcm::IODEntry::GetUsage() const 
        """
        return _gdcmswig.IODEntry_GetUsage(self)


    def GetUsageType(self) -> "gdcm::Usage::UsageType":
        """
        Usage::UsageType
        gdcm::IODEntry::GetUsageType() const 
        """
        return _gdcmswig.IODEntry_GetUsageType(self)

    __swig_destroy__ = _gdcmswig.delete_IODEntry
    __del__ = lambda self: None
IODEntry_swigregister = _gdcmswig.IODEntry_swigregister
IODEntry_swigregister(IODEntry)

class Rescaler(_object):
    """


    Rescale class.

    This class is meant to apply the linear transform of Stored Pixel
    Value to Real World Value. This is mostly found in CT or PET dataset,
    where the value are stored using one type, but need to be converted to
    another scale using a linear transform. There are basically two cases:
    In CT: the linear transform is generally integer based. E.g. the
    Stored Pixel Type is unsigned short 12bits, but to get Hounsfield
    unit, one need to apply the linear transform: \\[ RWV = 1. * SV -
    1024 \\] So the best scalar to store the Real World Value will be 16
    bits signed type.

    In PET: the linear transform is generally floating point based. Since
    the dynamic range can be quite high, the Rescale Slope / Rescale
    Intercept can be changing throughout the Series. So it is important to
    read all linear transform and deduce the best Pixel Type only at the
    end (when all the images to be read have been parsed).

    WARNING:  Internally any time a floating point value is found either
    in the Rescale Slope or the Rescale Intercept it is assumed that the
    best matching output pixel type is FLOAT64 (in previous implementation
    it was FLOAT32). Because VR:DS is closer to a 64bits floating point
    type FLOAT64 is thus a best matching pixel type for the floating point
    transformation.  Example: Let say input is FLOAT64, and we want UINT16
    as ouput, we would do:

    handle floating point transformation back and forth to integer
    properly (no loss)

    See:   Unpacker12Bits

    C++ includes: gdcmRescaler.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Rescaler, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Rescaler, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Rescaler::Rescaler() """
        this = _gdcmswig.new_Rescaler()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Rescaler
    __del__ = lambda self: None

    def Rescale(self, out: 'char *', arg3: 'char const *', n: 'size_t') -> "bool":
        """
        bool
        gdcm::Rescaler::Rescale(char *out, const char *in, size_t n)

        Direct transform. 
        """
        return _gdcmswig.Rescaler_Rescale(self, out, arg3, n)


    def InverseRescale(self, out: 'char *', arg3: 'char const *', n: 'size_t') -> "bool":
        """
        bool
        gdcm::Rescaler::InverseRescale(char *out, const char *in, size_t n)

        Inverse transform. 
        """
        return _gdcmswig.Rescaler_InverseRescale(self, out, arg3, n)


    def SetIntercept(self, i: 'double') -> "void":
        """
        void
        gdcm::Rescaler::SetIntercept(double i)

        Set Intercept: used for both direct&inverse transformation. 
        """
        return _gdcmswig.Rescaler_SetIntercept(self, i)


    def GetIntercept(self) -> "double":
        """
        double
        gdcm::Rescaler::GetIntercept() const 
        """
        return _gdcmswig.Rescaler_GetIntercept(self)


    def SetSlope(self, s: 'double') -> "void":
        """
        void
        gdcm::Rescaler::SetSlope(double s)

        Set Slope: user for both direct&inverse transformation. 
        """
        return _gdcmswig.Rescaler_SetSlope(self, s)


    def GetSlope(self) -> "double":
        """
        double
        gdcm::Rescaler::GetSlope() const 
        """
        return _gdcmswig.Rescaler_GetSlope(self)


    def SetTargetPixelType(self, targetst: 'PixelFormat') -> "void":
        """
        void
        gdcm::Rescaler::SetTargetPixelType(PixelFormat const &targetst)

        By default (when UseTargetPixelType is false), a best matching Target
        Pixel Type is computed. However user can override this auto selection
        by switching UseTargetPixelType:true and also specifying the specifix
        Target Pixel Type 
        """
        return _gdcmswig.Rescaler_SetTargetPixelType(self, targetst)


    def SetUseTargetPixelType(self, b: 'bool') -> "void":
        """
        void
        gdcm::Rescaler::SetUseTargetPixelType(bool b)

        Override default behavior of Rescale. 
        """
        return _gdcmswig.Rescaler_SetUseTargetPixelType(self, b)


    def SetPixelFormat(self, pf: 'PixelFormat') -> "void":
        """
        void
        gdcm::Rescaler::SetPixelFormat(PixelFormat const &pf)

        Set Pixel Format of input data. 
        """
        return _gdcmswig.Rescaler_SetPixelFormat(self, pf)


    def ComputeInterceptSlopePixelType(self) -> "gdcm::PixelFormat::ScalarType":
        """
        PixelFormat::ScalarType
        gdcm::Rescaler::ComputeInterceptSlopePixelType()

        Compute the Pixel Format of the output data Used for direct
        transformation 
        """
        return _gdcmswig.Rescaler_ComputeInterceptSlopePixelType(self)


    def SetMinMaxForPixelType(self, min: 'double', max: 'double') -> "void":
        """
        void
        gdcm::Rescaler::SetMinMaxForPixelType(double min, double max)

        Set target interval for output data. A best match will be computed (if
        possible) Used for inverse transformation 
        """
        return _gdcmswig.Rescaler_SetMinMaxForPixelType(self, min, max)


    def ComputePixelTypeFromMinMax(self) -> "gdcm::PixelFormat":
        """
        PixelFormat gdcm::Rescaler::ComputePixelTypeFromMinMax()

        Compute the Pixel Format of the output data Used for inverse
        transformation 
        """
        return _gdcmswig.Rescaler_ComputePixelTypeFromMinMax(self)

Rescaler_swigregister = _gdcmswig.Rescaler_swigregister
Rescaler_swigregister(Rescaler)

class SegmentedPaletteColorLookupTable(LookupTable):
    """


    SegmentedPaletteColorLookupTable class.

    C++ includes: gdcmSegmentedPaletteColorLookupTable.h 
    """

    __swig_setmethods__ = {}
    for _s in [LookupTable]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, SegmentedPaletteColorLookupTable, name, value)
    __swig_getmethods__ = {}
    for _s in [LookupTable]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, SegmentedPaletteColorLookupTable, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::SegmentedPaletteColorLookupTable::SegmentedPaletteColorLookupTable()

        """
        this = _gdcmswig.new_SegmentedPaletteColorLookupTable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SegmentedPaletteColorLookupTable
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void gdcm::SegmentedPaletteColorLookupTable::Print(std::ostream &)
        const 
        """
        return _gdcmswig.SegmentedPaletteColorLookupTable_Print(self, arg2)


    def SetLUT(self, type: 'gdcm::LookupTable::LookupTableType', array: 'unsigned char const *', length: 'unsigned int') -> "void":
        """
        void gdcm::SegmentedPaletteColorLookupTable::SetLUT(LookupTableType
        type, const unsigned char *array, unsigned int length)

        Initialize a SegmentedPaletteColorLookupTable. 
        """
        return _gdcmswig.SegmentedPaletteColorLookupTable_SetLUT(self, type, array, length)

SegmentedPaletteColorLookupTable_swigregister = _gdcmswig.SegmentedPaletteColorLookupTable_swigregister
SegmentedPaletteColorLookupTable_swigregister(SegmentedPaletteColorLookupTable)

class Unpacker12Bits(_object):
    """


    Pack/Unpack 12 bits pixel into 16bits.

    You can only pack an even number of 16bits, which means a multiple of
    4 (expressed in bytes)

    You can only unpack a multiple of 3 bytes  This class has no purpose
    in general purpose DICOM implementation. However to be able to cope
    with some early ACR-NEMA file generated by a well-known private
    vendor, one would need to unpack 12bits Stored Pixel Value into a more
    standard 16bits Stored Pixel Value.

    See:   Rescaler

    C++ includes: gdcmUnpacker12Bits.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Unpacker12Bits, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Unpacker12Bits, name)
    __repr__ = _swig_repr
    if _newclass:
        Pack = staticmethod(_gdcmswig.Unpacker12Bits_Pack)
    else:
        Pack = _gdcmswig.Unpacker12Bits_Pack
    if _newclass:
        Unpack = staticmethod(_gdcmswig.Unpacker12Bits_Unpack)
    else:
        Unpack = _gdcmswig.Unpacker12Bits_Unpack

    def __init__(self):
        this = _gdcmswig.new_Unpacker12Bits()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Unpacker12Bits
    __del__ = lambda self: None
Unpacker12Bits_swigregister = _gdcmswig.Unpacker12Bits_swigregister
Unpacker12Bits_swigregister(Unpacker12Bits)

def Unpacker12Bits_Pack(out: 'char *', arg3: 'char const *', n: 'size_t') -> "bool":
    return _gdcmswig.Unpacker12Bits_Pack(out, arg3, n)
Unpacker12Bits_Pack = _gdcmswig.Unpacker12Bits_Pack

def Unpacker12Bits_Unpack(out: 'char *', arg3: 'char const *', n: 'size_t') -> "bool":
    return _gdcmswig.Unpacker12Bits_Unpack(out, arg3, n)
Unpacker12Bits_Unpack = _gdcmswig.Unpacker12Bits_Unpack

class PythonFilter(_object):
    """


    PythonFilter PythonFilter is the class that make gdcm2.x looks more
    like gdcm1 and transform the binary blob contained in a DataElement
    into a string, typically this is a nice feature to have for wrapped
    language.

    C++ includes: gdcmPythonFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PythonFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PythonFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PythonFilter::PythonFilter() """
        this = _gdcmswig.new_PythonFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PythonFilter
    __del__ = lambda self: None

    def UseDictAlways(self, arg2: 'bool') -> "void":
        """
        void
        gdcm::PythonFilter::UseDictAlways(bool) 
        """
        return _gdcmswig.PythonFilter_UseDictAlways(self, arg2)


    def SetDicts(self, dicts: 'Dicts') -> "void":
        """
        void
        gdcm::PythonFilter::SetDicts(const Dicts &dicts) 
        """
        return _gdcmswig.PythonFilter_SetDicts(self, dicts)


    def ToPyObject(self, t: 'Tag') -> "PyObject *":
        """
        PyObject*
        gdcm::PythonFilter::ToPyObject(const Tag &t) const 
        """
        return _gdcmswig.PythonFilter_ToPyObject(self, t)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::PythonFilter::SetFile(const File &f) 
        """
        return _gdcmswig.PythonFilter_SetFile(self, f)


    def GetFile(self, *args) -> "gdcm::File const &":
        """
        const File&
        gdcm::PythonFilter::GetFile() const 
        """
        return _gdcmswig.PythonFilter_GetFile(self, *args)

PythonFilter_swigregister = _gdcmswig.PythonFilter_swigregister
PythonFilter_swigregister(PythonFilter)

class TagPath(_object):
    """


    class to handle a path of tag.

    Any Resemblance to Existing XPath is Purely
    Coincidentalftp://medical.nema.org/medical/dicom/supps/sup118_pc.pdf

    C++ includes: gdcmTagPath.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagPath, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TagPath, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::TagPath::TagPath() """
        this = _gdcmswig.new_TagPath()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_TagPath
    __del__ = lambda self: None

    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        void
        gdcm::TagPath::Print(std::ostream &) const 
        """
        return _gdcmswig.TagPath_Print(self, arg2)


    def ConstructFromString(self, path: 'char const *') -> "bool":
        """
        bool
        gdcm::TagPath::ConstructFromString(const char *path)

        "/0018,0018/"... No space allowed, comma is use to separate tag
        group from tag element and slash is used to separate tag return false
        if invalid 
        """
        return _gdcmswig.TagPath_ConstructFromString(self, path)

    if _newclass:
        IsValid = staticmethod(_gdcmswig.TagPath_IsValid)
    else:
        IsValid = _gdcmswig.TagPath_IsValid

    def ConstructFromTagList(self, l: 'Tag', n: 'unsigned int') -> "bool":
        """
        bool
        gdcm::TagPath::ConstructFromTagList(Tag const *l, unsigned int n)

        Construct from a list of tags. 
        """
        return _gdcmswig.TagPath_ConstructFromTagList(self, l, n)


    def Push(self, *args) -> "bool":
        """
        bool
        gdcm::TagPath::Push(unsigned int itemnum) 
        """
        return _gdcmswig.TagPath_Push(self, *args)

TagPath_swigregister = _gdcmswig.TagPath_swigregister
TagPath_swigregister(TagPath)

def TagPath_IsValid(path: 'char const *') -> "bool":
    return _gdcmswig.TagPath_IsValid(path)
TagPath_IsValid = _gdcmswig.TagPath_IsValid

class BitmapToBitmapFilter(_object):
    """


    BitmapToBitmapFilter class.

    Super class for all filter taking an image and producing an output
    image

    C++ includes: gdcmBitmapToBitmapFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BitmapToBitmapFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BitmapToBitmapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::BitmapToBitmapFilter::BitmapToBitmapFilter() """
        this = _gdcmswig.new_BitmapToBitmapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_BitmapToBitmapFilter
    __del__ = lambda self: None

    def SetInput(self, image: 'Bitmap') -> "void":
        """
        void
        gdcm::BitmapToBitmapFilter::SetInput(const Bitmap &image)

        Set input image. 
        """
        return _gdcmswig.BitmapToBitmapFilter_SetInput(self, image)


    def GetOutput(self) -> "gdcm::Bitmap const &":
        """
        const
        Bitmap& gdcm::BitmapToBitmapFilter::GetOutput() const

        Get Output image. 
        """
        return _gdcmswig.BitmapToBitmapFilter_GetOutput(self)


    def GetOutputAsBitmap(self) -> "gdcm::Bitmap const &":
        """const Bitmap& gdcm::BitmapToBitmapFilter::GetOutputAsBitmap() const """
        return _gdcmswig.BitmapToBitmapFilter_GetOutputAsBitmap(self)

BitmapToBitmapFilter_swigregister = _gdcmswig.BitmapToBitmapFilter_swigregister
BitmapToBitmapFilter_swigregister(BitmapToBitmapFilter)

class PixmapToPixmapFilter(BitmapToBitmapFilter):
    """


    PixmapToPixmapFilter class.

    Super class for all filter taking an image and producing an output
    image

    C++ includes: gdcmPixmapToPixmapFilter.h 
    """

    __swig_setmethods__ = {}
    for _s in [BitmapToBitmapFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PixmapToPixmapFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [BitmapToBitmapFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PixmapToPixmapFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PixmapToPixmapFilter::PixmapToPixmapFilter() """
        this = _gdcmswig.new_PixmapToPixmapFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PixmapToPixmapFilter
    __del__ = lambda self: None

    def GetInput(self) -> "gdcm::Pixmap &":
        """
        Pixmap&
        gdcm::PixmapToPixmapFilter::GetInput() 
        """
        return _gdcmswig.PixmapToPixmapFilter_GetInput(self)


    def GetOutput(self) -> "gdcm::Pixmap const &":
        """
        const
        Pixmap& gdcm::PixmapToPixmapFilter::GetOutput() const

        Get Output image. 
        """
        return _gdcmswig.PixmapToPixmapFilter_GetOutput(self)


    def GetOutputAsPixmap(self) -> "gdcm::Pixmap const &":
        """const Pixmap& gdcm::PixmapToPixmapFilter::GetOutputAsPixmap() const """
        return _gdcmswig.PixmapToPixmapFilter_GetOutputAsPixmap(self)

PixmapToPixmapFilter_swigregister = _gdcmswig.PixmapToPixmapFilter_swigregister
PixmapToPixmapFilter_swigregister(PixmapToPixmapFilter)

class ImageToImageFilter(PixmapToPixmapFilter):
    """


    ImageToImageFilter class.

    Super class for all filter taking an image and producing an output
    image

    C++ includes: gdcmImageToImageFilter.h 
    """

    __swig_setmethods__ = {}
    for _s in [PixmapToPixmapFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageToImageFilter, name, value)
    __swig_getmethods__ = {}
    for _s in [PixmapToPixmapFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageToImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageToImageFilter::ImageToImageFilter() """
        this = _gdcmswig.new_ImageToImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageToImageFilter
    __del__ = lambda self: None

    def GetInput(self) -> "gdcm::Image &":
        """
        Image&
        gdcm::ImageToImageFilter::GetInput() 
        """
        return _gdcmswig.ImageToImageFilter_GetInput(self)


    def GetOutput(self) -> "gdcm::Image const &":
        """
        const
        Image& gdcm::ImageToImageFilter::GetOutput() const

        Get Output image. 
        """
        return _gdcmswig.ImageToImageFilter_GetOutput(self)

ImageToImageFilter_swigregister = _gdcmswig.ImageToImageFilter_swigregister
ImageToImageFilter_swigregister(ImageToImageFilter)

class SOPClassUIDToIOD(_object):
    """


    Class convert a class SOP Class UID into IOD.

    Reference PS 3.4 Table B.5-1 STANDARD SOP CLASSES

    C++ includes: gdcmSOPClassUIDToIOD.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SOPClassUIDToIOD, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SOPClassUIDToIOD, name)
    __repr__ = _swig_repr
    if _newclass:
        GetIOD = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetIOD)
    else:
        GetIOD = _gdcmswig.SOPClassUIDToIOD_GetIOD
    if _newclass:
        GetNumberOfSOPClassToIOD = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetNumberOfSOPClassToIOD)
    else:
        GetNumberOfSOPClassToIOD = _gdcmswig.SOPClassUIDToIOD_GetNumberOfSOPClassToIOD
    if _newclass:
        GetSOPClassUIDToIODs = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIODs)
    else:
        GetSOPClassUIDToIODs = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIODs
    if _newclass:
        GetSOPClassUIDToIOD = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIOD)
    else:
        GetSOPClassUIDToIOD = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIOD
    if _newclass:
        GetSOPClassUIDFromIOD = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDFromIOD)
    else:
        GetSOPClassUIDFromIOD = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDFromIOD
    if _newclass:
        GetIODFromSOPClassUID = staticmethod(_gdcmswig.SOPClassUIDToIOD_GetIODFromSOPClassUID)
    else:
        GetIODFromSOPClassUID = _gdcmswig.SOPClassUIDToIOD_GetIODFromSOPClassUID

    def __init__(self):
        this = _gdcmswig.new_SOPClassUIDToIOD()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SOPClassUIDToIOD
    __del__ = lambda self: None
SOPClassUIDToIOD_swigregister = _gdcmswig.SOPClassUIDToIOD_swigregister
SOPClassUIDToIOD_swigregister(SOPClassUIDToIOD)

def SOPClassUIDToIOD_GetIOD(uid: 'UIDs') -> "char const *":
    return _gdcmswig.SOPClassUIDToIOD_GetIOD(uid)
SOPClassUIDToIOD_GetIOD = _gdcmswig.SOPClassUIDToIOD_GetIOD

def SOPClassUIDToIOD_GetNumberOfSOPClassToIOD() -> "unsigned int":
    return _gdcmswig.SOPClassUIDToIOD_GetNumberOfSOPClassToIOD()
SOPClassUIDToIOD_GetNumberOfSOPClassToIOD = _gdcmswig.SOPClassUIDToIOD_GetNumberOfSOPClassToIOD

def SOPClassUIDToIOD_GetSOPClassUIDToIODs() -> "gdcm::SOPClassUIDToIOD::SOPClassUIDToIODType *":
    return _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIODs()
SOPClassUIDToIOD_GetSOPClassUIDToIODs = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIODs

def SOPClassUIDToIOD_GetSOPClassUIDToIOD(i: 'unsigned int') -> "gdcm::SOPClassUIDToIOD::SOPClassUIDToIODType &":
    return _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIOD(i)
SOPClassUIDToIOD_GetSOPClassUIDToIOD = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDToIOD

def SOPClassUIDToIOD_GetSOPClassUIDFromIOD(iod: 'char const *') -> "char const *":
    return _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDFromIOD(iod)
SOPClassUIDToIOD_GetSOPClassUIDFromIOD = _gdcmswig.SOPClassUIDToIOD_GetSOPClassUIDFromIOD

def SOPClassUIDToIOD_GetIODFromSOPClassUID(sopclassuid: 'char const *') -> "char const *":
    return _gdcmswig.SOPClassUIDToIOD_GetIODFromSOPClassUID(sopclassuid)
SOPClassUIDToIOD_GetIODFromSOPClassUID = _gdcmswig.SOPClassUIDToIOD_GetIODFromSOPClassUID

class ImageCodec(_object):
    """


    ImageCodec.

    Main codec, this is a central place for all implementation

    C++ includes: gdcmImageCodec.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageCodec, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ImageCodec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageCodec::ImageCodec() """
        if self.__class__ == ImageCodec:
            _self = None
        else:
            _self = self
        this = _gdcmswig.new_ImageCodec(_self, )
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageCodec
    __del__ = lambda self: None

    def CanCode(self, arg2: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::ImageCodec::CanCode(TransferSyntax const &) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.ImageCodec_CanCode(self, arg2)


    def CanDecode(self, arg2: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::ImageCodec::CanDecode(TransferSyntax const &) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.ImageCodec_CanDecode(self, arg2)


    def Decode(self, is_: 'DataElement', os: 'DataElement') -> "bool":
        """
        bool
        gdcm::ImageCodec::Decode(DataElement const &is_, DataElement &os)

        Decode. 
        """
        return _gdcmswig.ImageCodec_Decode(self, is_, os)


    def IsLossy(self) -> "bool":
        """
        bool
        gdcm::ImageCodec::IsLossy() const 
        """
        return _gdcmswig.ImageCodec_IsLossy(self)


    def SetLossyFlag(self, l: 'bool') -> "void":
        """
        void
        gdcm::ImageCodec::SetLossyFlag(bool l) 
        """
        return _gdcmswig.ImageCodec_SetLossyFlag(self, l)


    def GetLossyFlag(self) -> "bool":
        """
        bool
        gdcm::ImageCodec::GetLossyFlag() const 
        """
        return _gdcmswig.ImageCodec_GetLossyFlag(self)


    def GetHeaderInfo(self, is_: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        virtual bool
        gdcm::ImageCodec::GetHeaderInfo(std::istream &is_, TransferSyntax &ts)

        """
        return _gdcmswig.ImageCodec_GetHeaderInfo(self, is_, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual ImageCodec*
        gdcm::ImageCodec::Clone() const =0 
        """
        return _gdcmswig.ImageCodec_Clone(self)


    def IsValid(self, pi: 'PhotometricInterpretation') -> "bool":
        return _gdcmswig.ImageCodec_IsValid(self, pi)

    def GetPlanarConfiguration(self) -> "unsigned int":
        """unsigned int gdcm::ImageCodec::GetPlanarConfiguration() const """
        return _gdcmswig.ImageCodec_GetPlanarConfiguration(self)


    def SetPlanarConfiguration(self, pc: 'unsigned int') -> "void":
        """
        void
        gdcm::ImageCodec::SetPlanarConfiguration(unsigned int pc) 
        """
        return _gdcmswig.ImageCodec_SetPlanarConfiguration(self, pc)


    def GetPixelFormat(self, *args) -> "gdcm::PixelFormat const &":
        """
        const
        PixelFormat& gdcm::ImageCodec::GetPixelFormat() const 
        """
        return _gdcmswig.ImageCodec_GetPixelFormat(self, *args)


    def SetPixelFormat(self, pf: 'PixelFormat') -> "void":
        """
        virtual void
        gdcm::ImageCodec::SetPixelFormat(PixelFormat const &pf) 
        """
        return _gdcmswig.ImageCodec_SetPixelFormat(self, pf)


    def GetPhotometricInterpretation(self) -> "gdcm::PhotometricInterpretation const &":
        """
        const PhotometricInterpretation&
        gdcm::ImageCodec::GetPhotometricInterpretation() const 
        """
        return _gdcmswig.ImageCodec_GetPhotometricInterpretation(self)


    def SetPhotometricInterpretation(self, pi: 'PhotometricInterpretation') -> "void":
        """
        void
        gdcm::ImageCodec::SetPhotometricInterpretation(PhotometricInterpretation
        const &pi) 
        """
        return _gdcmswig.ImageCodec_SetPhotometricInterpretation(self, pi)


    def GetNeedByteSwap(self) -> "bool":
        """
        bool
        gdcm::ImageCodec::GetNeedByteSwap() const 
        """
        return _gdcmswig.ImageCodec_GetNeedByteSwap(self)


    def SetNeedByteSwap(self, b: 'bool') -> "void":
        """
        void
        gdcm::ImageCodec::SetNeedByteSwap(bool b) 
        """
        return _gdcmswig.ImageCodec_SetNeedByteSwap(self, b)


    def SetNeedOverlayCleanup(self, b: 'bool') -> "void":
        """
        void
        gdcm::ImageCodec::SetNeedOverlayCleanup(bool b) 
        """
        return _gdcmswig.ImageCodec_SetNeedOverlayCleanup(self, b)


    def SetLUT(self, lut: 'LookupTable') -> "void":
        """
        void
        gdcm::ImageCodec::SetLUT(LookupTable const &lut) 
        """
        return _gdcmswig.ImageCodec_SetLUT(self, lut)


    def GetLUT(self) -> "gdcm::LookupTable const &":
        """
        const LookupTable&
        gdcm::ImageCodec::GetLUT() const 
        """
        return _gdcmswig.ImageCodec_GetLUT(self)


    def SetDimensions(self, *args) -> "void":
        """
        void
        gdcm::ImageCodec::SetDimensions(const std::vector< unsigned int > &d)

        """
        return _gdcmswig.ImageCodec_SetDimensions(self, *args)


    def GetDimensions(self) -> "unsigned int const *":
        """
        const
        unsigned int* gdcm::ImageCodec::GetDimensions() const 
        """
        return _gdcmswig.ImageCodec_GetDimensions(self)


    def SetNumberOfDimensions(self, dim: 'unsigned int') -> "void":
        """
        void
        gdcm::ImageCodec::SetNumberOfDimensions(unsigned int dim) 
        """
        return _gdcmswig.ImageCodec_SetNumberOfDimensions(self, dim)


    def GetNumberOfDimensions(self) -> "unsigned int":
        """unsigned int gdcm::ImageCodec::GetNumberOfDimensions() const """
        return _gdcmswig.ImageCodec_GetNumberOfDimensions(self)


    def CleanupUnusedBits(self, data: 'char *', datalen: 'size_t') -> "bool":
        return _gdcmswig.ImageCodec_CleanupUnusedBits(self, data, datalen)

    def StartEncode(self, os: 'std::ostream &') -> "bool":
        return _gdcmswig.ImageCodec_StartEncode(self, os)

    def IsRowEncoder(self) -> "bool":
        return _gdcmswig.ImageCodec_IsRowEncoder(self)

    def IsFrameEncoder(self) -> "bool":
        return _gdcmswig.ImageCodec_IsFrameEncoder(self)

    def AppendRowEncode(self, out: 'std::ostream &', data: 'char const *', datalen: 'size_t') -> "bool":
        return _gdcmswig.ImageCodec_AppendRowEncode(self, out, data, datalen)

    def AppendFrameEncode(self, out: 'std::ostream &', data: 'char const *', datalen: 'size_t') -> "bool":
        return _gdcmswig.ImageCodec_AppendFrameEncode(self, out, data, datalen)

    def StopEncode(self, os: 'std::ostream &') -> "bool":
        return _gdcmswig.ImageCodec_StopEncode(self, os)
    def __disown__(self):
        self.this.disown()
        _gdcmswig.disown_ImageCodec(self)
        return weakref_proxy(self)
ImageCodec_swigregister = _gdcmswig.ImageCodec_swigregister
ImageCodec_swigregister(ImageCodec)

class RLECodec(ImageCodec):
    """


    Class to do RLE.

    ANSI X3.9 A.4.2 RLE Compression Annex G defines a RLE Compression
    Transfer Syntax. This transfer Syntax is identified by the UID value
    "1.2.840.10008.1.2.5". If the object allows multi-frame images in
    the pixel data field, then each frame shall be encoded separately.
    Each frame shall be encoded in one and only one Fragment (see PS
    3.5.8.2).

    C++ includes: gdcmRLECodec.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageCodec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, RLECodec, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageCodec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, RLECodec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::RLECodec::RLECodec() """
        this = _gdcmswig.new_RLECodec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_RLECodec
    __del__ = lambda self: None

    def CanCode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::RLECodec::CanCode(TransferSyntax const &ts) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.RLECodec_CanCode(self, ts)


    def CanDecode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::RLECodec::CanDecode(TransferSyntax const &ts) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.RLECodec_CanDecode(self, ts)


    def Decode(self, arg2: 'DataElement', os: 'DataElement') -> "bool":
        """
        bool
        gdcm::RLECodec::Decode(DataElement const &is, DataElement &os)

        Decode. 
        """
        return _gdcmswig.RLECodec_Decode(self, arg2, os)


    def GetBufferLength(self) -> "unsigned long":
        """
        unsigned long
        gdcm::RLECodec::GetBufferLength() const 
        """
        return _gdcmswig.RLECodec_GetBufferLength(self)


    def SetBufferLength(self, l: 'unsigned long') -> "void":
        """
        void
        gdcm::RLECodec::SetBufferLength(unsigned long l) 
        """
        return _gdcmswig.RLECodec_SetBufferLength(self, l)


    def Code(self, arg2: 'DataElement', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::RLECodec::Code(DataElement const &in, DataElement &out)

        Code. 
        """
        return _gdcmswig.RLECodec_Code(self, arg2, out)


    def GetHeaderInfo(self, arg2: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::RLECodec::GetHeaderInfo(std::istream &is, TransferSyntax &ts) 
        """
        return _gdcmswig.RLECodec_GetHeaderInfo(self, arg2, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual ImageCodec*
        gdcm::RLECodec::Clone() const 
        """
        return _gdcmswig.RLECodec_Clone(self)


    def SetLength(self, l: 'unsigned long') -> "void":
        """
        void
        gdcm::RLECodec::SetLength(unsigned long l) 
        """
        return _gdcmswig.RLECodec_SetLength(self, l)

RLECodec_swigregister = _gdcmswig.RLECodec_swigregister
RLECodec_swigregister(RLECodec)

class JPEGCodec(ImageCodec):
    """


    JPEG codec.

    Class to do JPEG (8bits, 12bits, 16bits lossy & lossless). It
    redispatch in between the different codec implementation: JPEG8Codec,
    JPEG12Codec & JPEG16Codec It also support inconsistency in between
    DICOM header and JPEG compressed stream ImageCodec implementation for
    the JPEG case

    Things you should know if you ever want to dive into DICOM/JPEG world
    (among other):

    http://groups.google.com/group/comp.protocols.dicom/browse_thread/thread/625e46919f2080e1

    http://groups.google.com/group/comp.protocols.dicom/browse_thread/thread/75fdfccc65a6243

    http://groups.google.com/group/comp.protocols.dicom/browse_thread/thread/2d525ef6a2f093ed

    http://groups.google.com/group/comp.protocols.dicom/browse_thread/thread/6b93af410f8c921f

    C++ includes: gdcmJPEGCodec.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageCodec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JPEGCodec, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageCodec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JPEGCodec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::JPEGCodec::JPEGCodec() """
        this = _gdcmswig.new_JPEGCodec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_JPEGCodec
    __del__ = lambda self: None

    def CanDecode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEGCodec::CanDecode(TransferSyntax const &ts) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.JPEGCodec_CanDecode(self, ts)


    def CanCode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEGCodec::CanCode(TransferSyntax const &ts) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.JPEGCodec_CanCode(self, ts)


    def Decode(self, arg2: 'DataElement', os: 'DataElement') -> "bool":
        """
        bool
        gdcm::JPEGCodec::Decode(DataElement const &is, DataElement &os)

        Decode. 
        """
        return _gdcmswig.JPEGCodec_Decode(self, arg2, os)


    def SetPixelFormat(self, pf: 'PixelFormat') -> "void":
        """
        void
        gdcm::JPEGCodec::SetPixelFormat(PixelFormat const &pf) 
        """
        return _gdcmswig.JPEGCodec_SetPixelFormat(self, pf)


    def ComputeOffsetTable(self, b: 'bool') -> "void":
        """
        void
        gdcm::JPEGCodec::ComputeOffsetTable(bool b)

        Compute the offset table: 
        """
        return _gdcmswig.JPEGCodec_ComputeOffsetTable(self, b)


    def Code(self, arg2: 'DataElement', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::JPEGCodec::Code(DataElement const &in, DataElement &out)

        Compress into JPEG. 
        """
        return _gdcmswig.JPEGCodec_Code(self, arg2, out)


    def GetHeaderInfo(self, arg2: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        virtual bool
        gdcm::JPEGCodec::GetHeaderInfo(std::istream &is, TransferSyntax &ts)

        """
        return _gdcmswig.JPEGCodec_GetHeaderInfo(self, arg2, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual ImageCodec*
        gdcm::JPEGCodec::Clone() const 
        """
        return _gdcmswig.JPEGCodec_Clone(self)


    def SetQuality(self, q: 'double') -> "void":
        """
        void
        gdcm::JPEGCodec::SetQuality(double q) 
        """
        return _gdcmswig.JPEGCodec_SetQuality(self, q)


    def GetQuality(self) -> "double":
        """
        double
        gdcm::JPEGCodec::GetQuality() const 
        """
        return _gdcmswig.JPEGCodec_GetQuality(self)


    def SetLossless(self, l: 'bool') -> "void":
        """
        void
        gdcm::JPEGCodec::SetLossless(bool l) 
        """
        return _gdcmswig.JPEGCodec_SetLossless(self, l)


    def GetLossless(self) -> "bool":
        """
        bool
        gdcm::JPEGCodec::GetLossless() const 
        """
        return _gdcmswig.JPEGCodec_GetLossless(self)


    def EncodeBuffer(self, out: 'std::ostream &', inbuffer: 'char const *', inlen: 'size_t') -> "bool":
        """
        virtual bool
        gdcm::JPEGCodec::EncodeBuffer(std::ostream &out, const char *inbuffer,
        size_t inlen) 
        """
        return _gdcmswig.JPEGCodec_EncodeBuffer(self, out, inbuffer, inlen)

JPEGCodec_swigregister = _gdcmswig.JPEGCodec_swigregister
JPEGCodec_swigregister(JPEGCodec)

class JPEGLSCodec(ImageCodec):
    """


    JPEG-LS.

    codec that implement the JPEG-LS compression this is an implementation
    of ImageCodec for JPEG-LS  It uses the CharLS JPEG-LS
    implementationhttps://github.com/team-charls/charls

    C++ includes: gdcmJPEGLSCodec.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageCodec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JPEGLSCodec, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageCodec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JPEGLSCodec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::JPEGLSCodec::JPEGLSCodec() """
        this = _gdcmswig.new_JPEGLSCodec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_JPEGLSCodec
    __del__ = lambda self: None

    def CanDecode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::CanDecode(TransferSyntax const &ts) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.JPEGLSCodec_CanDecode(self, ts)


    def CanCode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::CanCode(TransferSyntax const &ts) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.JPEGLSCodec_CanCode(self, ts)


    def GetBufferLength(self) -> "unsigned long":
        """
        unsigned
        long gdcm::JPEGLSCodec::GetBufferLength() const 
        """
        return _gdcmswig.JPEGLSCodec_GetBufferLength(self)


    def SetBufferLength(self, l: 'unsigned long') -> "void":
        """
        void
        gdcm::JPEGLSCodec::SetBufferLength(unsigned long l) 
        """
        return _gdcmswig.JPEGLSCodec_SetBufferLength(self, l)


    def Decode(self, *args) -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::Decode(DataElement const &in, char *outBuffer,
        size_t inBufferLength, uint32_t inXMin, uint32_t inXMax, uint32_t
        inYMin, uint32_t inYMax, uint32_t inZMin, uint32_t inZMax) 
        """
        return _gdcmswig.JPEGLSCodec_Decode(self, *args)


    def Code(self, arg2: 'DataElement', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::Code(DataElement const &in, DataElement &out)

        Code. 
        """
        return _gdcmswig.JPEGLSCodec_Code(self, arg2, out)


    def GetHeaderInfo(self, arg2: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::GetHeaderInfo(std::istream &is, TransferSyntax &ts)

        """
        return _gdcmswig.JPEGLSCodec_GetHeaderInfo(self, arg2, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual ImageCodec*
        gdcm::JPEGLSCodec::Clone() const 
        """
        return _gdcmswig.JPEGLSCodec_Clone(self)


    def SetLossless(self, l: 'bool') -> "void":
        """
        void
        gdcm::JPEGLSCodec::SetLossless(bool l) 
        """
        return _gdcmswig.JPEGLSCodec_SetLossless(self, l)


    def GetLossless(self) -> "bool":
        """
        bool
        gdcm::JPEGLSCodec::GetLossless() const 
        """
        return _gdcmswig.JPEGLSCodec_GetLossless(self)


    def SetLossyError(self, error: 'int') -> "void":
        """
        void
        gdcm::JPEGLSCodec::SetLossyError(int error)

        [0-3] generally 
        """
        return _gdcmswig.JPEGLSCodec_SetLossyError(self, error)

JPEGLSCodec_swigregister = _gdcmswig.JPEGLSCodec_swigregister
JPEGLSCodec_swigregister(JPEGLSCodec)

class JPEG2000Codec(ImageCodec):
    """


    Class to do JPEG 2000.

    the class will produce JPC (JPEG 2000 codestream), since some private
    implementor are using full jp2 file the decoder tolerate jp2 input
    this is an implementation of an ImageCodec

    C++ includes: gdcmJPEG2000Codec.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageCodec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, JPEG2000Codec, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageCodec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, JPEG2000Codec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::JPEG2000Codec::JPEG2000Codec() """
        this = _gdcmswig.new_JPEG2000Codec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_JPEG2000Codec
    __del__ = lambda self: None

    def CanDecode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEG2000Codec::CanDecode(TransferSyntax const &ts) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.JPEG2000Codec_CanDecode(self, ts)


    def CanCode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::JPEG2000Codec::CanCode(TransferSyntax const &ts) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.JPEG2000Codec_CanCode(self, ts)


    def Decode(self, arg2: 'DataElement', os: 'DataElement') -> "bool":
        """
        bool
        gdcm::JPEG2000Codec::Decode(DataElement const &is, DataElement &os)

        Decode. 
        """
        return _gdcmswig.JPEG2000Codec_Decode(self, arg2, os)


    def Code(self, arg2: 'DataElement', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::JPEG2000Codec::Code(DataElement const &in, DataElement &out)

        Code. 
        """
        return _gdcmswig.JPEG2000Codec_Code(self, arg2, out)


    def GetHeaderInfo(self, arg2: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        virtual
        bool gdcm::JPEG2000Codec::GetHeaderInfo(std::istream &is,
        TransferSyntax &ts) 
        """
        return _gdcmswig.JPEG2000Codec_GetHeaderInfo(self, arg2, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual
        ImageCodec* gdcm::JPEG2000Codec::Clone() const 
        """
        return _gdcmswig.JPEG2000Codec_Clone(self)


    def SetRate(self, idx: 'unsigned int', rate: 'double') -> "void":
        """
        void
        gdcm::JPEG2000Codec::SetRate(unsigned int idx, double rate) 
        """
        return _gdcmswig.JPEG2000Codec_SetRate(self, idx, rate)


    def GetRate(self, idx: 'unsigned int'=0) -> "double":
        """
        double
        gdcm::JPEG2000Codec::GetRate(unsigned int idx=0) const 
        """
        return _gdcmswig.JPEG2000Codec_GetRate(self, idx)


    def SetQuality(self, idx: 'unsigned int', q: 'double') -> "void":
        """
        void
        gdcm::JPEG2000Codec::SetQuality(unsigned int idx, double q) 
        """
        return _gdcmswig.JPEG2000Codec_SetQuality(self, idx, q)


    def GetQuality(self, idx: 'unsigned int'=0) -> "double":
        """
        double
        gdcm::JPEG2000Codec::GetQuality(unsigned int idx=0) const 
        """
        return _gdcmswig.JPEG2000Codec_GetQuality(self, idx)


    def SetTileSize(self, tx: 'unsigned int', ty: 'unsigned int') -> "void":
        """
        void
        gdcm::JPEG2000Codec::SetTileSize(unsigned int tx, unsigned int ty) 
        """
        return _gdcmswig.JPEG2000Codec_SetTileSize(self, tx, ty)


    def SetNumberOfResolutions(self, nres: 'unsigned int') -> "void":
        """void gdcm::JPEG2000Codec::SetNumberOfResolutions(unsigned int nres) """
        return _gdcmswig.JPEG2000Codec_SetNumberOfResolutions(self, nres)


    def SetReversible(self, res: 'bool') -> "void":
        """
        void
        gdcm::JPEG2000Codec::SetReversible(bool res) 
        """
        return _gdcmswig.JPEG2000Codec_SetReversible(self, res)

JPEG2000Codec_swigregister = _gdcmswig.JPEG2000Codec_swigregister
JPEG2000Codec_swigregister(JPEG2000Codec)

class PNMCodec(ImageCodec):
    """


    Class to do PNM.

    PNM is the Portable anymap file format. The main web page can be found
    at:http://netpbm.sourceforge.net/ Only support P5 & P6 PNM file
    (binary grayscale and binary rgb)

    C++ includes: gdcmPNMCodec.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageCodec]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, PNMCodec, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageCodec]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, PNMCodec, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PNMCodec::PNMCodec() """
        this = _gdcmswig.new_PNMCodec()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_PNMCodec
    __del__ = lambda self: None

    def CanDecode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::PNMCodec::CanDecode(TransferSyntax const &ts) const

        Return whether this decoder support this transfer syntax (can decode
        it) 
        """
        return _gdcmswig.PNMCodec_CanDecode(self, ts)


    def CanCode(self, ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::PNMCodec::CanCode(TransferSyntax const &ts) const

        Return whether this coder support this transfer syntax (can code it)

        """
        return _gdcmswig.PNMCodec_CanCode(self, ts)


    def GetBufferLength(self) -> "unsigned long":
        """
        unsigned long
        gdcm::PNMCodec::GetBufferLength() const 
        """
        return _gdcmswig.PNMCodec_GetBufferLength(self)


    def SetBufferLength(self, l: 'unsigned long') -> "void":
        """
        void
        gdcm::PNMCodec::SetBufferLength(unsigned long l) 
        """
        return _gdcmswig.PNMCodec_SetBufferLength(self, l)


    def GetHeaderInfo(self, arg2: 'std::istream &', ts: 'TransferSyntax') -> "bool":
        """
        bool
        gdcm::PNMCodec::GetHeaderInfo(std::istream &is, TransferSyntax &ts) 
        """
        return _gdcmswig.PNMCodec_GetHeaderInfo(self, arg2, ts)


    def Clone(self) -> "gdcm::ImageCodec *":
        """
        virtual ImageCodec*
        gdcm::PNMCodec::Clone() const 
        """
        return _gdcmswig.PNMCodec_Clone(self)


    def Read(self, filename: 'char const *', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::PNMCodec::Read(const char *filename, DataElement &out) const 
        """
        return _gdcmswig.PNMCodec_Read(self, filename, out)


    def Write(self, filename: 'char const *', out: 'DataElement') -> "bool":
        """
        bool
        gdcm::PNMCodec::Write(const char *filename, const DataElement &out)
        const 
        """
        return _gdcmswig.PNMCodec_Write(self, filename, out)

PNMCodec_swigregister = _gdcmswig.PNMCodec_swigregister
PNMCodec_swigregister(PNMCodec)

class ImageChangeTransferSyntax(ImageToImageFilter):
    """


    ImageChangeTransferSyntax class.

    Class to change the transfer syntax of an input DICOM

    If only Force param is set but no input TransferSyntax is set, it is
    assumed that user only wants to inspect encapsulated stream (advanced
    dev. option).

    When using UserCodec it is very important that the TransferSyntax (as
    set in SetTransferSyntax) is actually understood by UserCodec (ie.
    UserCodec->CanCode( TransferSyntax ) ). Otherwise the behavior is to
    use a default codec.

    See:   JPEGCodec JPEGLSCodec JPEG2000Codec

    C++ includes: gdcmImageChangeTransferSyntax.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageChangeTransferSyntax, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageChangeTransferSyntax, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageChangeTransferSyntax::ImageChangeTransferSyntax() """
        this = _gdcmswig.new_ImageChangeTransferSyntax()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageChangeTransferSyntax
    __del__ = lambda self: None

    def SetTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::ImageChangeTransferSyntax::SetTransferSyntax(const
        TransferSyntax &ts)

        Set target Transfer Syntax. 
        """
        return _gdcmswig.ImageChangeTransferSyntax_SetTransferSyntax(self, ts)


    def GetTransferSyntax(self) -> "gdcm::TransferSyntax const &":
        """
        const
        TransferSyntax& gdcm::ImageChangeTransferSyntax::GetTransferSyntax()
        const

        Get Transfer Syntax. 
        """
        return _gdcmswig.ImageChangeTransferSyntax_GetTransferSyntax(self)


    def Change(self) -> "bool":
        """
        bool
        gdcm::ImageChangeTransferSyntax::Change()

        Change. 
        """
        return _gdcmswig.ImageChangeTransferSyntax_Change(self)


    def SetCompressIconImage(self, b: 'bool') -> "void":
        """
        void
        gdcm::ImageChangeTransferSyntax::SetCompressIconImage(bool b)

        Decide whether or not to also compress the Icon Image using the same
        Transfer Syntax. Default is to simply decompress icon image 
        """
        return _gdcmswig.ImageChangeTransferSyntax_SetCompressIconImage(self, b)


    def SetForce(self, f: 'bool') -> "void":
        """
        void gdcm::ImageChangeTransferSyntax::SetForce(bool f)

        When target Transfer Syntax is identical to input target syntax, no
        operation is actually done. This is an issue when someone wants to re-
        compress using GDCM internal implementation a JPEG (for example) image

        """
        return _gdcmswig.ImageChangeTransferSyntax_SetForce(self, f)


    def SetUserCodec(self, ic: 'ImageCodec') -> "void":
        """
        void gdcm::ImageChangeTransferSyntax::SetUserCodec(ImageCodec *ic)

        Allow user to specify exactly which codec to use. this is needed to
        specify special qualities or compression option. WARNING:  if the
        codec 'ic' is not compatible with the TransferSyntax requested, it
        will not be used. It is the user responsibility to check that
        UserCodec->CanCode( TransferSyntax ) 
        """
        return _gdcmswig.ImageChangeTransferSyntax_SetUserCodec(self, ic)

ImageChangeTransferSyntax_swigregister = _gdcmswig.ImageChangeTransferSyntax_swigregister
ImageChangeTransferSyntax_swigregister(ImageChangeTransferSyntax)

class SmartPtrFCTS(_object):
    """


    Class for Smart Pointer.

    Will only work for subclass of gdcm::Object See tr1/shared_ptr for a
    more general approach (not invasive) #include <tr1/memory> {
    shared_ptr<Bla> b(new Bla); } Class partly based on post by Bill
    Hubauer:http://groups.google.com/group/comp.lang.c++/msg/173ddc38a827a930

    See:  http://www.davethehat.com/articles/smartp.htm  and
    itk::SmartPointer

    C++ includes: gdcmObject.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SmartPtrFCTS, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SmartPtrFCTS, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """gdcm::SmartPointer< ObjectType >::SmartPointer(ObjectType const &p) """
        this = _gdcmswig.new_SmartPtrFCTS(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SmartPtrFCTS
    __del__ = lambda self: None

    def __deref__(self) -> "gdcm::FileChangeTransferSyntax *":
        return _gdcmswig.SmartPtrFCTS___deref__(self)

    def __ref__(self) -> "gdcm::FileChangeTransferSyntax &":
        return _gdcmswig.SmartPtrFCTS___ref__(self)

    def GetPointer(self) -> "gdcm::FileChangeTransferSyntax *":
        """
        ObjectType*
        gdcm::SmartPointer< ObjectType >::GetPointer() const

        Explicit function to retrieve the pointer. 
        """
        return _gdcmswig.SmartPtrFCTS_GetPointer(self)


    def SetInputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetInputFileName(const char
        *filename_native)

        Set input filename (raw DICOM) 
        """
        return _gdcmswig.SmartPtrFCTS_SetInputFileName(self, filename_native)


    def SetOutputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetOutputFileName(const char
        *filename_native)

        Set output filename (target compressed DICOM) 
        """
        return _gdcmswig.SmartPtrFCTS_SetOutputFileName(self, filename_native)


    def Change(self) -> "bool":
        """
        bool
        gdcm::FileChangeTransferSyntax::Change()

        Change the transfer syntax. 
        """
        return _gdcmswig.SmartPtrFCTS_Change(self)


    def SetTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetTransferSyntax(TransferSyntax const
        &ts)

        Specify the Target Transfer Syntax. 
        """
        return _gdcmswig.SmartPtrFCTS_SetTransferSyntax(self, ts)


    def GetCodec(self) -> "gdcm::ImageCodec *":
        """
        ImageCodec* gdcm::FileChangeTransferSyntax::GetCodec()

        Retrieve the actual codec (valid after calling SetTransferSyntax) Only
        advanced users should call this function. 
        """
        return _gdcmswig.SmartPtrFCTS_GetCodec(self)


    def New(self) -> "gdcm::SmartPointer< gdcm::FileChangeTransferSyntax >":
        return _gdcmswig.SmartPtrFCTS_New(self)

    def AddObserver(self, *args) -> "unsigned long":
        """
        unsigned long
        gdcm::Subject::AddObserver(const Event &event, Command *) const 
        """
        return _gdcmswig.SmartPtrFCTS_AddObserver(self, *args)


    def GetCommand(self, tag: 'unsigned long') -> "gdcm::Command *":
        """
        Command*
        gdcm::Subject::GetCommand(unsigned long tag)

        Get the command associated with the given tag. NOTE: This returns a
        pointer to a Command, but it is safe to asign this to a
        Command::Pointer. Since Command inherits from LightObject, at this
        point in the code, only a pointer or a reference to the Command can be
        used. 
        """
        return _gdcmswig.SmartPtrFCTS_GetCommand(self, tag)


    def InvokeEvent(self, *args) -> "void":
        """
        void
        gdcm::Subject::InvokeEvent(const Event &) const

        Call Execute on all the Commands observing this event id. The actions
        triggered by this call doesn't modify this object. 
        """
        return _gdcmswig.SmartPtrFCTS_InvokeEvent(self, *args)


    def RemoveObserver(self, tag: 'unsigned long') -> "void":
        """
        void
        gdcm::Subject::RemoveObserver(unsigned long tag)

        Remove the observer with this tag value. 
        """
        return _gdcmswig.SmartPtrFCTS_RemoveObserver(self, tag)


    def RemoveAllObservers(self) -> "void":
        """
        void
        gdcm::Subject::RemoveAllObservers()

        Remove all observers . 
        """
        return _gdcmswig.SmartPtrFCTS_RemoveAllObservers(self)


    def HasObserver(self, event: 'Event') -> "bool":
        """
        bool
        gdcm::Subject::HasObserver(const Event &event) const

        Return true if an observer is registered for this event. 
        """
        return _gdcmswig.SmartPtrFCTS_HasObserver(self, event)


    def Print(self, arg2: 'std::ostream &') -> "void":
        """
        virtual void
        gdcm::Object::Print(std::ostream &) const 
        """
        return _gdcmswig.SmartPtrFCTS_Print(self, arg2)

SmartPtrFCTS_swigregister = _gdcmswig.SmartPtrFCTS_swigregister
SmartPtrFCTS_swigregister(SmartPtrFCTS)

class FileChangeTransferSyntax(Subject):
    """


    FileChangeTransferSyntax.

    This class is a file-based (limited) replacement of the in-memory
    ImageChangeTransferSyntax.

    This class provide a file-based compression-only mechanism. It will
    take in an uncompressed DICOM image file (Pixel Data element). Then
    produced as output a compressed DICOM file (Transfer Syntax will be
    updated).

    Currently it supports the following transfer syntax:
    JPEGLosslessProcess14_1

    C++ includes: gdcmFileChangeTransferSyntax.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileChangeTransferSyntax, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileChangeTransferSyntax, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileChangeTransferSyntax::FileChangeTransferSyntax() """
        this = _gdcmswig.new_FileChangeTransferSyntax()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileChangeTransferSyntax
    __del__ = lambda self: None

    def SetInputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetInputFileName(const char
        *filename_native)

        Set input filename (raw DICOM) 
        """
        return _gdcmswig.FileChangeTransferSyntax_SetInputFileName(self, filename_native)


    def SetOutputFileName(self, filename_native: 'char const *') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetOutputFileName(const char
        *filename_native)

        Set output filename (target compressed DICOM) 
        """
        return _gdcmswig.FileChangeTransferSyntax_SetOutputFileName(self, filename_native)


    def Change(self) -> "bool":
        """
        bool
        gdcm::FileChangeTransferSyntax::Change()

        Change the transfer syntax. 
        """
        return _gdcmswig.FileChangeTransferSyntax_Change(self)


    def SetTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::FileChangeTransferSyntax::SetTransferSyntax(TransferSyntax const
        &ts)

        Specify the Target Transfer Syntax. 
        """
        return _gdcmswig.FileChangeTransferSyntax_SetTransferSyntax(self, ts)


    def GetCodec(self) -> "gdcm::ImageCodec *":
        """
        ImageCodec* gdcm::FileChangeTransferSyntax::GetCodec()

        Retrieve the actual codec (valid after calling SetTransferSyntax) Only
        advanced users should call this function. 
        """
        return _gdcmswig.FileChangeTransferSyntax_GetCodec(self)

    if _newclass:
        New = staticmethod(_gdcmswig.FileChangeTransferSyntax_New)
    else:
        New = _gdcmswig.FileChangeTransferSyntax_New
FileChangeTransferSyntax_swigregister = _gdcmswig.FileChangeTransferSyntax_swigregister
FileChangeTransferSyntax_swigregister(FileChangeTransferSyntax)

def FileChangeTransferSyntax_New() -> "gdcm::SmartPointer< gdcm::FileChangeTransferSyntax >":
    return _gdcmswig.FileChangeTransferSyntax_New()
FileChangeTransferSyntax_New = _gdcmswig.FileChangeTransferSyntax_New

class ImageApplyLookupTable(ImageToImageFilter):
    """


    ImageApplyLookupTable class.

    It applies the LUT the PixelData (only PALETTE_COLOR images) Output
    will be a PhotometricInterpretation=RGB image

    C++ includes: gdcmImageApplyLookupTable.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageApplyLookupTable, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageApplyLookupTable, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageApplyLookupTable::ImageApplyLookupTable() """
        this = _gdcmswig.new_ImageApplyLookupTable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageApplyLookupTable
    __del__ = lambda self: None

    def Apply(self) -> "bool":
        """
        bool
        gdcm::ImageApplyLookupTable::Apply()

        Apply. 
        """
        return _gdcmswig.ImageApplyLookupTable_Apply(self)

ImageApplyLookupTable_swigregister = _gdcmswig.ImageApplyLookupTable_swigregister
ImageApplyLookupTable_swigregister(ImageApplyLookupTable)

class SplitMosaicFilter(_object):
    """


    SplitMosaicFilter class.

    Class to reshuffle bytes for a SIEMENS Mosaic image Siemens CSA Image
    Header CSA:= Common Siemens Architecture, sometimes also known as
    Common syngo Architecture

    C++ includes: gdcmSplitMosaicFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SplitMosaicFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SplitMosaicFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::SplitMosaicFilter::SplitMosaicFilter() """
        this = _gdcmswig.new_SplitMosaicFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SplitMosaicFilter
    __del__ = lambda self: None

    def Split(self) -> "bool":
        """
        bool
        gdcm::SplitMosaicFilter::Split()

        Split the SIEMENS MOSAIC image. 
        """
        return _gdcmswig.SplitMosaicFilter_Split(self)


    def ComputeMOSAICDimensions(self, dims: 'unsigned int [3]') -> "bool":
        """
        bool
        gdcm::SplitMosaicFilter::ComputeMOSAICDimensions(unsigned int dims[3])

        Compute the new dimensions according to private information stored in
        the MOSAIC header. 
        """
        return _gdcmswig.SplitMosaicFilter_ComputeMOSAICDimensions(self, dims)


    def ComputeMOSAICSliceNormal(self, dims: 'double [3]', inverted: 'bool &') -> "bool":
        return _gdcmswig.SplitMosaicFilter_ComputeMOSAICSliceNormal(self, dims, inverted)

    def ComputeMOSAICSlicePosition(self, pos: 'double [3]', inverted: 'bool') -> "bool":
        return _gdcmswig.SplitMosaicFilter_ComputeMOSAICSlicePosition(self, pos, inverted)

    def SetImage(self, image: 'Image') -> "void":
        """
        void
        gdcm::SplitMosaicFilter::SetImage(const Image &image) 
        """
        return _gdcmswig.SplitMosaicFilter_SetImage(self, image)


    def GetImage(self, *args) -> "gdcm::Image &":
        """
        Image&
        gdcm::SplitMosaicFilter::GetImage() 
        """
        return _gdcmswig.SplitMosaicFilter_GetImage(self, *args)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::SplitMosaicFilter::SetFile(const File &f) 
        """
        return _gdcmswig.SplitMosaicFilter_SetFile(self, f)


    def GetFile(self, *args) -> "gdcm::File const &":
        """
        const File&
        gdcm::SplitMosaicFilter::GetFile() const 
        """
        return _gdcmswig.SplitMosaicFilter_GetFile(self, *args)

    if _newclass:
        GetAcquisitionSize = staticmethod(_gdcmswig.SplitMosaicFilter_GetAcquisitionSize)
    else:
        GetAcquisitionSize = _gdcmswig.SplitMosaicFilter_GetAcquisitionSize
    if _newclass:
        GetNumberOfImagesInMosaic = staticmethod(_gdcmswig.SplitMosaicFilter_GetNumberOfImagesInMosaic)
    else:
        GetNumberOfImagesInMosaic = _gdcmswig.SplitMosaicFilter_GetNumberOfImagesInMosaic
SplitMosaicFilter_swigregister = _gdcmswig.SplitMosaicFilter_swigregister
SplitMosaicFilter_swigregister(SplitMosaicFilter)

def SplitMosaicFilter_GetAcquisitionSize(size: 'unsigned int [2]', ds: 'DataSet') -> "bool":
    return _gdcmswig.SplitMosaicFilter_GetAcquisitionSize(size, ds)
SplitMosaicFilter_GetAcquisitionSize = _gdcmswig.SplitMosaicFilter_GetAcquisitionSize

def SplitMosaicFilter_GetNumberOfImagesInMosaic(file: 'File') -> "unsigned int":
    return _gdcmswig.SplitMosaicFilter_GetNumberOfImagesInMosaic(file)
SplitMosaicFilter_GetNumberOfImagesInMosaic = _gdcmswig.SplitMosaicFilter_GetNumberOfImagesInMosaic

class ImageChangePhotometricInterpretation(ImageToImageFilter):
    """


    ImageChangePhotometricInterpretation class.

    Class to change the Photometric Interpetation of an input DICOM

    C++ includes: gdcmImageChangePhotometricInterpretation.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageChangePhotometricInterpretation, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageChangePhotometricInterpretation, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::ImageChangePhotometricInterpretation::ImageChangePhotometricInterpretation()

        """
        this = _gdcmswig.new_ImageChangePhotometricInterpretation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageChangePhotometricInterpretation
    __del__ = lambda self: None

    def SetPhotometricInterpretation(self, pi: 'PhotometricInterpretation') -> "void":
        """
        void
        gdcm::ImageChangePhotometricInterpretation::SetPhotometricInterpretation(PhotometricInterpretation
        const &pi)

        Set/Get requested PhotometricInterpretation. 
        """
        return _gdcmswig.ImageChangePhotometricInterpretation_SetPhotometricInterpretation(self, pi)


    def GetPhotometricInterpretation(self) -> "gdcm::PhotometricInterpretation const &":
        """
        const PhotometricInterpretation&
        gdcm::ImageChangePhotometricInterpretation::GetPhotometricInterpretation()
        const 
        """
        return _gdcmswig.ImageChangePhotometricInterpretation_GetPhotometricInterpretation(self)


    def Change(self) -> "bool":
        """
        bool
        gdcm::ImageChangePhotometricInterpretation::Change()

        Change. 
        """
        return _gdcmswig.ImageChangePhotometricInterpretation_Change(self)

ImageChangePhotometricInterpretation_swigregister = _gdcmswig.ImageChangePhotometricInterpretation_swigregister
ImageChangePhotometricInterpretation_swigregister(ImageChangePhotometricInterpretation)

class ImageChangePlanarConfiguration(ImageToImageFilter):
    """


    ImageChangePlanarConfiguration class.

    Class to change the Planar configuration of an input DICOM By default
    it will change into the more usual reprensentation:
    PlanarConfiguration = 0

    C++ includes: gdcmImageChangePlanarConfiguration.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageChangePlanarConfiguration, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageChangePlanarConfiguration, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::ImageChangePlanarConfiguration::ImageChangePlanarConfiguration()

        """
        this = _gdcmswig.new_ImageChangePlanarConfiguration()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageChangePlanarConfiguration
    __del__ = lambda self: None

    def SetPlanarConfiguration(self, pc: 'unsigned int') -> "void":
        """
        void
        gdcm::ImageChangePlanarConfiguration::SetPlanarConfiguration(unsigned
        int pc)

        Set/Get requested PlanarConfigation. 
        """
        return _gdcmswig.ImageChangePlanarConfiguration_SetPlanarConfiguration(self, pc)


    def GetPlanarConfiguration(self) -> "unsigned int":
        """
        unsigned int
        gdcm::ImageChangePlanarConfiguration::GetPlanarConfiguration() const

        """
        return _gdcmswig.ImageChangePlanarConfiguration_GetPlanarConfiguration(self)


    def Change(self) -> "bool":
        """
        bool gdcm::ImageChangePlanarConfiguration::Change()

        Change. 
        """
        return _gdcmswig.ImageChangePlanarConfiguration_Change(self)

ImageChangePlanarConfiguration_swigregister = _gdcmswig.ImageChangePlanarConfiguration_swigregister
ImageChangePlanarConfiguration_swigregister(ImageChangePlanarConfiguration)

class ImageFragmentSplitter(ImageToImageFilter):
    """


    ImageFragmentSplitter class.

    For single frame image, DICOM standard allow splitting the frame into
    multiple fragments

    C++ includes: gdcmImageFragmentSplitter.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageFragmentSplitter, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageToImageFilter]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageFragmentSplitter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageFragmentSplitter::ImageFragmentSplitter() """
        this = _gdcmswig.new_ImageFragmentSplitter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageFragmentSplitter
    __del__ = lambda self: None

    def Split(self) -> "bool":
        """
        bool
        gdcm::ImageFragmentSplitter::Split()

        Split. 
        """
        return _gdcmswig.ImageFragmentSplitter_Split(self)


    def SetFragmentSizeMax(self, fragsize: 'unsigned int') -> "void":
        """
        void gdcm::ImageFragmentSplitter::SetFragmentSizeMax(unsigned int
        fragsize)

        FragmentSizeMax needs to be an even number. 
        """
        return _gdcmswig.ImageFragmentSplitter_SetFragmentSizeMax(self, fragsize)


    def GetFragmentSizeMax(self) -> "unsigned int":
        """
        unsigned int gdcm::ImageFragmentSplitter::GetFragmentSizeMax() const

        """
        return _gdcmswig.ImageFragmentSplitter_GetFragmentSizeMax(self)


    def SetForce(self, f: 'bool') -> "void":
        """
        void
        gdcm::ImageFragmentSplitter::SetForce(bool f)

        When file already has all it's segment < FragmentSizeMax there is not
        need to run the filter. Unless the user explicitly say 'force'
        recomputation ! 
        """
        return _gdcmswig.ImageFragmentSplitter_SetForce(self, f)

ImageFragmentSplitter_swigregister = _gdcmswig.ImageFragmentSplitter_swigregister
ImageFragmentSplitter_swigregister(ImageFragmentSplitter)

class DataSetHelper(_object):
    """


    DataSetHelper (internal class, not intended for user level)

    C++ includes: gdcmDataSetHelper.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataSetHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataSetHelper, name)
    __repr__ = _swig_repr
    if _newclass:
        ComputeVR = staticmethod(_gdcmswig.DataSetHelper_ComputeVR)
    else:
        ComputeVR = _gdcmswig.DataSetHelper_ComputeVR

    def __init__(self):
        this = _gdcmswig.new_DataSetHelper()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DataSetHelper
    __del__ = lambda self: None
DataSetHelper_swigregister = _gdcmswig.DataSetHelper_swigregister
DataSetHelper_swigregister(DataSetHelper)

def DataSetHelper_ComputeVR(file: 'File', ds: 'DataSet', tag: 'Tag') -> "gdcm::VR":
    return _gdcmswig.DataSetHelper_ComputeVR(file, ds, tag)
DataSetHelper_ComputeVR = _gdcmswig.DataSetHelper_ComputeVR

class FileExplicitFilter(_object):
    """


    FileExplicitFilter class.

    After changing a file from Implicit to Explicit representation (see
    ImageChangeTransferSyntax) one operation is to make sure the VR of
    each DICOM attribute are accurate and do match the one from PS 3.6.
    Indeed when a file is written in Implicit reprensentation, the VR is
    not stored directly in the file.

    WARNING:  changing an implicit dataset to an explicit dataset is NOT a
    trivial task of simply changing the VR to the dict one: One has to
    make sure SQ is properly set

    One has to recompute the explicit length SQ

    One has to make sure that VR is valid for the encoding

    One has to make sure that VR 16bits can store the original value
    length

    C++ includes: gdcmFileExplicitFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileExplicitFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileExplicitFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileExplicitFilter::FileExplicitFilter() """
        this = _gdcmswig.new_FileExplicitFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileExplicitFilter
    __del__ = lambda self: None

    def SetChangePrivateTags(self, b: 'bool') -> "void":
        """
        void gdcm::FileExplicitFilter::SetChangePrivateTags(bool b)

        Decide whether or not to VR'ify private tags. 
        """
        return _gdcmswig.FileExplicitFilter_SetChangePrivateTags(self, b)


    def SetUseVRUN(self, b: 'bool') -> "void":
        """
        void
        gdcm::FileExplicitFilter::SetUseVRUN(bool b)

        When VR=16bits in explicit but Implicit has a 32bits length, use
        VR=UN. 
        """
        return _gdcmswig.FileExplicitFilter_SetUseVRUN(self, b)


    def SetRecomputeItemLength(self, b: 'bool') -> "void":
        """
        void
        gdcm::FileExplicitFilter::SetRecomputeItemLength(bool b)

        By default set Sequence & Item length to Undefined to avoid
        recomputing length: 
        """
        return _gdcmswig.FileExplicitFilter_SetRecomputeItemLength(self, b)


    def SetRecomputeSequenceLength(self, b: 'bool') -> "void":
        """
        void
        gdcm::FileExplicitFilter::SetRecomputeSequenceLength(bool b) 
        """
        return _gdcmswig.FileExplicitFilter_SetRecomputeSequenceLength(self, b)


    def Change(self) -> "bool":
        """
        bool
        gdcm::FileExplicitFilter::Change()

        Set FMI Transfer Syntax.

        Change 
        """
        return _gdcmswig.FileExplicitFilter_Change(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::FileExplicitFilter::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.FileExplicitFilter_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """
        File&
        gdcm::FileExplicitFilter::GetFile() 
        """
        return _gdcmswig.FileExplicitFilter_GetFile(self)

FileExplicitFilter_swigregister = _gdcmswig.FileExplicitFilter_swigregister
FileExplicitFilter_swigregister(FileExplicitFilter)

class DoubleArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DoubleArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DoubleArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.DoubleArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.DoubleArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.DoubleArrayType___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _gdcmswig.DoubleArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "std::vector< double,std::allocator< double > > *":
        return _gdcmswig.DoubleArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.DoubleArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< double >::difference_type', j: 'std::vector< double >::difference_type') -> "void":
        return _gdcmswig.DoubleArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.DoubleArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _gdcmswig.DoubleArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.DoubleArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _gdcmswig.DoubleArrayType_pop(self)

    def append(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _gdcmswig.DoubleArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.DoubleArrayType_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _gdcmswig.DoubleArrayType_size(self)

    def swap(self, v: 'DoubleArrayType') -> "void":
        return _gdcmswig.DoubleArrayType_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _gdcmswig.DoubleArrayType_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _gdcmswig.DoubleArrayType_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _gdcmswig.DoubleArrayType_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _gdcmswig.DoubleArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.DoubleArrayType_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _gdcmswig.DoubleArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.DoubleArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _gdcmswig.DoubleArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_DoubleArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< double >::value_type const &') -> "void":
        return _gdcmswig.DoubleArrayType_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _gdcmswig.DoubleArrayType_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _gdcmswig.DoubleArrayType_back(self)

    def assign(self, n: 'std::vector< double >::size_type', x: 'std::vector< double >::value_type const &') -> "void":
        return _gdcmswig.DoubleArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.DoubleArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.DoubleArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< double >::size_type') -> "void":
        return _gdcmswig.DoubleArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _gdcmswig.DoubleArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_DoubleArrayType
    __del__ = lambda self: None
DoubleArrayType_swigregister = _gdcmswig.DoubleArrayType_swigregister
DoubleArrayType_swigregister(DoubleArrayType)

class UShortArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UShortArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UShortArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.UShortArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.UShortArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.UShortArrayType___bool__(self)

    def __len__(self) -> "std::vector< unsigned short >::size_type":
        return _gdcmswig.UShortArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned short >::difference_type', j: 'std::vector< unsigned short >::difference_type') -> "std::vector< unsigned short,std::allocator< unsigned short > > *":
        return _gdcmswig.UShortArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.UShortArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned short >::difference_type', j: 'std::vector< unsigned short >::difference_type') -> "void":
        return _gdcmswig.UShortArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.UShortArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned short >::value_type const &":
        return _gdcmswig.UShortArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.UShortArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned short >::value_type":
        return _gdcmswig.UShortArrayType_pop(self)

    def append(self, x: 'std::vector< unsigned short >::value_type const &') -> "void":
        return _gdcmswig.UShortArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.UShortArrayType_empty(self)

    def size(self) -> "std::vector< unsigned short >::size_type":
        return _gdcmswig.UShortArrayType_size(self)

    def swap(self, v: 'UShortArrayType') -> "void":
        return _gdcmswig.UShortArrayType_swap(self, v)

    def begin(self) -> "std::vector< unsigned short >::iterator":
        return _gdcmswig.UShortArrayType_begin(self)

    def end(self) -> "std::vector< unsigned short >::iterator":
        return _gdcmswig.UShortArrayType_end(self)

    def rbegin(self) -> "std::vector< unsigned short >::reverse_iterator":
        return _gdcmswig.UShortArrayType_rbegin(self)

    def rend(self) -> "std::vector< unsigned short >::reverse_iterator":
        return _gdcmswig.UShortArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.UShortArrayType_clear(self)

    def get_allocator(self) -> "std::vector< unsigned short >::allocator_type":
        return _gdcmswig.UShortArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.UShortArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned short >::iterator":
        return _gdcmswig.UShortArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_UShortArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned short >::value_type const &') -> "void":
        return _gdcmswig.UShortArrayType_push_back(self, x)

    def front(self) -> "std::vector< unsigned short >::value_type const &":
        return _gdcmswig.UShortArrayType_front(self)

    def back(self) -> "std::vector< unsigned short >::value_type const &":
        return _gdcmswig.UShortArrayType_back(self)

    def assign(self, n: 'std::vector< unsigned short >::size_type', x: 'std::vector< unsigned short >::value_type const &') -> "void":
        return _gdcmswig.UShortArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.UShortArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.UShortArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned short >::size_type') -> "void":
        return _gdcmswig.UShortArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned short >::size_type":
        return _gdcmswig.UShortArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_UShortArrayType
    __del__ = lambda self: None
UShortArrayType_swigregister = _gdcmswig.UShortArrayType_swigregister
UShortArrayType_swigregister(UShortArrayType)

class UIntArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, UIntArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, UIntArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.UIntArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.UIntArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.UIntArrayType___bool__(self)

    def __len__(self) -> "std::vector< unsigned int >::size_type":
        return _gdcmswig.UIntArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "std::vector< unsigned int,std::allocator< unsigned int > > *":
        return _gdcmswig.UIntArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.UIntArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< unsigned int >::difference_type', j: 'std::vector< unsigned int >::difference_type') -> "void":
        return _gdcmswig.UIntArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.UIntArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< unsigned int >::value_type const &":
        return _gdcmswig.UIntArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.UIntArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< unsigned int >::value_type":
        return _gdcmswig.UIntArrayType_pop(self)

    def append(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _gdcmswig.UIntArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.UIntArrayType_empty(self)

    def size(self) -> "std::vector< unsigned int >::size_type":
        return _gdcmswig.UIntArrayType_size(self)

    def swap(self, v: 'UIntArrayType') -> "void":
        return _gdcmswig.UIntArrayType_swap(self, v)

    def begin(self) -> "std::vector< unsigned int >::iterator":
        return _gdcmswig.UIntArrayType_begin(self)

    def end(self) -> "std::vector< unsigned int >::iterator":
        return _gdcmswig.UIntArrayType_end(self)

    def rbegin(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _gdcmswig.UIntArrayType_rbegin(self)

    def rend(self) -> "std::vector< unsigned int >::reverse_iterator":
        return _gdcmswig.UIntArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.UIntArrayType_clear(self)

    def get_allocator(self) -> "std::vector< unsigned int >::allocator_type":
        return _gdcmswig.UIntArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.UIntArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< unsigned int >::iterator":
        return _gdcmswig.UIntArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_UIntArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _gdcmswig.UIntArrayType_push_back(self, x)

    def front(self) -> "std::vector< unsigned int >::value_type const &":
        return _gdcmswig.UIntArrayType_front(self)

    def back(self) -> "std::vector< unsigned int >::value_type const &":
        return _gdcmswig.UIntArrayType_back(self)

    def assign(self, n: 'std::vector< unsigned int >::size_type', x: 'std::vector< unsigned int >::value_type const &') -> "void":
        return _gdcmswig.UIntArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.UIntArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.UIntArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< unsigned int >::size_type') -> "void":
        return _gdcmswig.UIntArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< unsigned int >::size_type":
        return _gdcmswig.UIntArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_UIntArrayType
    __del__ = lambda self: None
UIntArrayType_swigregister = _gdcmswig.UIntArrayType_swigregister
UIntArrayType_swigregister(UIntArrayType)

class RealWorldValueMappingContent(_object):
    """
    C++
    includes: gdcmImageHelper.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, RealWorldValueMappingContent, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, RealWorldValueMappingContent, name)
    __repr__ = _swig_repr
    __swig_setmethods__["RealWorldValueIntercept"] = _gdcmswig.RealWorldValueMappingContent_RealWorldValueIntercept_set
    __swig_getmethods__["RealWorldValueIntercept"] = _gdcmswig.RealWorldValueMappingContent_RealWorldValueIntercept_get
    if _newclass:
        RealWorldValueIntercept = _swig_property(_gdcmswig.RealWorldValueMappingContent_RealWorldValueIntercept_get, _gdcmswig.RealWorldValueMappingContent_RealWorldValueIntercept_set)
    __swig_setmethods__["RealWorldValueSlope"] = _gdcmswig.RealWorldValueMappingContent_RealWorldValueSlope_set
    __swig_getmethods__["RealWorldValueSlope"] = _gdcmswig.RealWorldValueMappingContent_RealWorldValueSlope_get
    if _newclass:
        RealWorldValueSlope = _swig_property(_gdcmswig.RealWorldValueMappingContent_RealWorldValueSlope_get, _gdcmswig.RealWorldValueMappingContent_RealWorldValueSlope_set)
    __swig_setmethods__["CodeValue"] = _gdcmswig.RealWorldValueMappingContent_CodeValue_set
    __swig_getmethods__["CodeValue"] = _gdcmswig.RealWorldValueMappingContent_CodeValue_get
    if _newclass:
        CodeValue = _swig_property(_gdcmswig.RealWorldValueMappingContent_CodeValue_get, _gdcmswig.RealWorldValueMappingContent_CodeValue_set)
    __swig_setmethods__["CodeMeaning"] = _gdcmswig.RealWorldValueMappingContent_CodeMeaning_set
    __swig_getmethods__["CodeMeaning"] = _gdcmswig.RealWorldValueMappingContent_CodeMeaning_get
    if _newclass:
        CodeMeaning = _swig_property(_gdcmswig.RealWorldValueMappingContent_CodeMeaning_get, _gdcmswig.RealWorldValueMappingContent_CodeMeaning_set)

    def __init__(self):
        this = _gdcmswig.new_RealWorldValueMappingContent()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_RealWorldValueMappingContent
    __del__ = lambda self: None
RealWorldValueMappingContent_swigregister = _gdcmswig.RealWorldValueMappingContent_swigregister
RealWorldValueMappingContent_swigregister(RealWorldValueMappingContent)

class ImageHelper(_object):
    """


    ImageHelper (internal class, not intended for user level)

    Helper for writing World images in DICOM. DICOM has a 'template'
    approach to image where MR Image Storage are distinct object from
    Enhanced MR Image Storage. For example the Pixel Spacing in one object
    is not at the same position (ie Tag) as in the other this class is the
    central (read: fragile) place where all the dispatching is done from a
    unified view of a world image (typically VTK or ITK point of view)
    down to the low level DICOM point of view.

    WARNING:  : do not expect the API of this class to be maintained at
    any point, since as Modalities are added the API might have to be
    augmented or behavior changed to cope with new modalities.

    C++ includes: gdcmImageHelper.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageHelper, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, ImageHelper, name)
    __repr__ = _swig_repr
    if _newclass:
        SetForceRescaleInterceptSlope = staticmethod(_gdcmswig.ImageHelper_SetForceRescaleInterceptSlope)
    else:
        SetForceRescaleInterceptSlope = _gdcmswig.ImageHelper_SetForceRescaleInterceptSlope
    if _newclass:
        GetForceRescaleInterceptSlope = staticmethod(_gdcmswig.ImageHelper_GetForceRescaleInterceptSlope)
    else:
        GetForceRescaleInterceptSlope = _gdcmswig.ImageHelper_GetForceRescaleInterceptSlope
    if _newclass:
        SetPMSRescaleInterceptSlope = staticmethod(_gdcmswig.ImageHelper_SetPMSRescaleInterceptSlope)
    else:
        SetPMSRescaleInterceptSlope = _gdcmswig.ImageHelper_SetPMSRescaleInterceptSlope
    if _newclass:
        GetPMSRescaleInterceptSlope = staticmethod(_gdcmswig.ImageHelper_GetPMSRescaleInterceptSlope)
    else:
        GetPMSRescaleInterceptSlope = _gdcmswig.ImageHelper_GetPMSRescaleInterceptSlope
    if _newclass:
        SetForcePixelSpacing = staticmethod(_gdcmswig.ImageHelper_SetForcePixelSpacing)
    else:
        SetForcePixelSpacing = _gdcmswig.ImageHelper_SetForcePixelSpacing
    if _newclass:
        GetForcePixelSpacing = staticmethod(_gdcmswig.ImageHelper_GetForcePixelSpacing)
    else:
        GetForcePixelSpacing = _gdcmswig.ImageHelper_GetForcePixelSpacing
    if _newclass:
        GetDimensionsValue = staticmethod(_gdcmswig.ImageHelper_GetDimensionsValue)
    else:
        GetDimensionsValue = _gdcmswig.ImageHelper_GetDimensionsValue
    if _newclass:
        SetDimensionsValue = staticmethod(_gdcmswig.ImageHelper_SetDimensionsValue)
    else:
        SetDimensionsValue = _gdcmswig.ImageHelper_SetDimensionsValue
    if _newclass:
        GetPixelFormatValue = staticmethod(_gdcmswig.ImageHelper_GetPixelFormatValue)
    else:
        GetPixelFormatValue = _gdcmswig.ImageHelper_GetPixelFormatValue
    if _newclass:
        GetRescaleInterceptSlopeValue = staticmethod(_gdcmswig.ImageHelper_GetRescaleInterceptSlopeValue)
    else:
        GetRescaleInterceptSlopeValue = _gdcmswig.ImageHelper_GetRescaleInterceptSlopeValue
    if _newclass:
        SetRescaleInterceptSlopeValue = staticmethod(_gdcmswig.ImageHelper_SetRescaleInterceptSlopeValue)
    else:
        SetRescaleInterceptSlopeValue = _gdcmswig.ImageHelper_SetRescaleInterceptSlopeValue
    if _newclass:
        GetRealWorldValueMappingContent = staticmethod(_gdcmswig.ImageHelper_GetRealWorldValueMappingContent)
    else:
        GetRealWorldValueMappingContent = _gdcmswig.ImageHelper_GetRealWorldValueMappingContent
    if _newclass:
        GetOriginValue = staticmethod(_gdcmswig.ImageHelper_GetOriginValue)
    else:
        GetOriginValue = _gdcmswig.ImageHelper_GetOriginValue
    if _newclass:
        SetOriginValue = staticmethod(_gdcmswig.ImageHelper_SetOriginValue)
    else:
        SetOriginValue = _gdcmswig.ImageHelper_SetOriginValue
    if _newclass:
        GetDirectionCosinesValue = staticmethod(_gdcmswig.ImageHelper_GetDirectionCosinesValue)
    else:
        GetDirectionCosinesValue = _gdcmswig.ImageHelper_GetDirectionCosinesValue
    if _newclass:
        SetDirectionCosinesValue = staticmethod(_gdcmswig.ImageHelper_SetDirectionCosinesValue)
    else:
        SetDirectionCosinesValue = _gdcmswig.ImageHelper_SetDirectionCosinesValue
    if _newclass:
        GetSpacingValue = staticmethod(_gdcmswig.ImageHelper_GetSpacingValue)
    else:
        GetSpacingValue = _gdcmswig.ImageHelper_GetSpacingValue
    if _newclass:
        SetSpacingValue = staticmethod(_gdcmswig.ImageHelper_SetSpacingValue)
    else:
        SetSpacingValue = _gdcmswig.ImageHelper_SetSpacingValue
    if _newclass:
        ComputeSpacingFromImagePositionPatient = staticmethod(_gdcmswig.ImageHelper_ComputeSpacingFromImagePositionPatient)
    else:
        ComputeSpacingFromImagePositionPatient = _gdcmswig.ImageHelper_ComputeSpacingFromImagePositionPatient
    if _newclass:
        GetDirectionCosinesFromDataSet = staticmethod(_gdcmswig.ImageHelper_GetDirectionCosinesFromDataSet)
    else:
        GetDirectionCosinesFromDataSet = _gdcmswig.ImageHelper_GetDirectionCosinesFromDataSet
    if _newclass:
        GetPhotometricInterpretationValue = staticmethod(_gdcmswig.ImageHelper_GetPhotometricInterpretationValue)
    else:
        GetPhotometricInterpretationValue = _gdcmswig.ImageHelper_GetPhotometricInterpretationValue
    if _newclass:
        GetPlanarConfigurationValue = staticmethod(_gdcmswig.ImageHelper_GetPlanarConfigurationValue)
    else:
        GetPlanarConfigurationValue = _gdcmswig.ImageHelper_GetPlanarConfigurationValue
    if _newclass:
        GetLUT = staticmethod(_gdcmswig.ImageHelper_GetLUT)
    else:
        GetLUT = _gdcmswig.ImageHelper_GetLUT
    if _newclass:
        GetPointerFromElement = staticmethod(_gdcmswig.ImageHelper_GetPointerFromElement)
    else:
        GetPointerFromElement = _gdcmswig.ImageHelper_GetPointerFromElement
    if _newclass:
        ComputeMediaStorageFromModality = staticmethod(_gdcmswig.ImageHelper_ComputeMediaStorageFromModality)
    else:
        ComputeMediaStorageFromModality = _gdcmswig.ImageHelper_ComputeMediaStorageFromModality

    def __init__(self):
        this = _gdcmswig.new_ImageHelper()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageHelper
    __del__ = lambda self: None
ImageHelper_swigregister = _gdcmswig.ImageHelper_swigregister
ImageHelper_swigregister(ImageHelper)

def ImageHelper_SetForceRescaleInterceptSlope(arg2: 'bool') -> "void":
    return _gdcmswig.ImageHelper_SetForceRescaleInterceptSlope(arg2)
ImageHelper_SetForceRescaleInterceptSlope = _gdcmswig.ImageHelper_SetForceRescaleInterceptSlope

def ImageHelper_GetForceRescaleInterceptSlope() -> "bool":
    return _gdcmswig.ImageHelper_GetForceRescaleInterceptSlope()
ImageHelper_GetForceRescaleInterceptSlope = _gdcmswig.ImageHelper_GetForceRescaleInterceptSlope

def ImageHelper_SetPMSRescaleInterceptSlope(arg2: 'bool') -> "void":
    return _gdcmswig.ImageHelper_SetPMSRescaleInterceptSlope(arg2)
ImageHelper_SetPMSRescaleInterceptSlope = _gdcmswig.ImageHelper_SetPMSRescaleInterceptSlope

def ImageHelper_GetPMSRescaleInterceptSlope() -> "bool":
    return _gdcmswig.ImageHelper_GetPMSRescaleInterceptSlope()
ImageHelper_GetPMSRescaleInterceptSlope = _gdcmswig.ImageHelper_GetPMSRescaleInterceptSlope

def ImageHelper_SetForcePixelSpacing(arg2: 'bool') -> "void":
    return _gdcmswig.ImageHelper_SetForcePixelSpacing(arg2)
ImageHelper_SetForcePixelSpacing = _gdcmswig.ImageHelper_SetForcePixelSpacing

def ImageHelper_GetForcePixelSpacing() -> "bool":
    return _gdcmswig.ImageHelper_GetForcePixelSpacing()
ImageHelper_GetForcePixelSpacing = _gdcmswig.ImageHelper_GetForcePixelSpacing

def ImageHelper_GetDimensionsValue(f: 'File') -> "std::vector< unsigned int,std::allocator< unsigned int > >":
    return _gdcmswig.ImageHelper_GetDimensionsValue(f)
ImageHelper_GetDimensionsValue = _gdcmswig.ImageHelper_GetDimensionsValue

def ImageHelper_SetDimensionsValue(f: 'File', img: 'Pixmap') -> "void":
    return _gdcmswig.ImageHelper_SetDimensionsValue(f, img)
ImageHelper_SetDimensionsValue = _gdcmswig.ImageHelper_SetDimensionsValue

def ImageHelper_GetPixelFormatValue(f: 'File') -> "gdcm::PixelFormat":
    return _gdcmswig.ImageHelper_GetPixelFormatValue(f)
ImageHelper_GetPixelFormatValue = _gdcmswig.ImageHelper_GetPixelFormatValue

def ImageHelper_GetRescaleInterceptSlopeValue(f: 'File') -> "std::vector< double,std::allocator< double > >":
    return _gdcmswig.ImageHelper_GetRescaleInterceptSlopeValue(f)
ImageHelper_GetRescaleInterceptSlopeValue = _gdcmswig.ImageHelper_GetRescaleInterceptSlopeValue

def ImageHelper_SetRescaleInterceptSlopeValue(f: 'File', img: 'Image') -> "void":
    return _gdcmswig.ImageHelper_SetRescaleInterceptSlopeValue(f, img)
ImageHelper_SetRescaleInterceptSlopeValue = _gdcmswig.ImageHelper_SetRescaleInterceptSlopeValue

def ImageHelper_GetRealWorldValueMappingContent(f: 'File', rwvmc: 'RealWorldValueMappingContent') -> "bool":
    return _gdcmswig.ImageHelper_GetRealWorldValueMappingContent(f, rwvmc)
ImageHelper_GetRealWorldValueMappingContent = _gdcmswig.ImageHelper_GetRealWorldValueMappingContent

def ImageHelper_GetOriginValue(f: 'File') -> "std::vector< double,std::allocator< double > >":
    return _gdcmswig.ImageHelper_GetOriginValue(f)
ImageHelper_GetOriginValue = _gdcmswig.ImageHelper_GetOriginValue

def ImageHelper_SetOriginValue(ds: 'DataSet', img: 'Image') -> "void":
    return _gdcmswig.ImageHelper_SetOriginValue(ds, img)
ImageHelper_SetOriginValue = _gdcmswig.ImageHelper_SetOriginValue

def ImageHelper_GetDirectionCosinesValue(f: 'File') -> "std::vector< double,std::allocator< double > >":
    return _gdcmswig.ImageHelper_GetDirectionCosinesValue(f)
ImageHelper_GetDirectionCosinesValue = _gdcmswig.ImageHelper_GetDirectionCosinesValue

def ImageHelper_SetDirectionCosinesValue(ds: 'DataSet', dircos: 'DoubleArrayType') -> "void":
    return _gdcmswig.ImageHelper_SetDirectionCosinesValue(ds, dircos)
ImageHelper_SetDirectionCosinesValue = _gdcmswig.ImageHelper_SetDirectionCosinesValue

def ImageHelper_GetSpacingValue(f: 'File') -> "std::vector< double,std::allocator< double > >":
    return _gdcmswig.ImageHelper_GetSpacingValue(f)
ImageHelper_GetSpacingValue = _gdcmswig.ImageHelper_GetSpacingValue

def ImageHelper_SetSpacingValue(ds: 'DataSet', spacing: 'DoubleArrayType') -> "void":
    return _gdcmswig.ImageHelper_SetSpacingValue(ds, spacing)
ImageHelper_SetSpacingValue = _gdcmswig.ImageHelper_SetSpacingValue

def ImageHelper_ComputeSpacingFromImagePositionPatient(imageposition: 'DoubleArrayType', spacing: 'DoubleArrayType') -> "bool":
    return _gdcmswig.ImageHelper_ComputeSpacingFromImagePositionPatient(imageposition, spacing)
ImageHelper_ComputeSpacingFromImagePositionPatient = _gdcmswig.ImageHelper_ComputeSpacingFromImagePositionPatient

def ImageHelper_GetDirectionCosinesFromDataSet(ds: 'DataSet', dircos: 'DoubleArrayType') -> "bool":
    return _gdcmswig.ImageHelper_GetDirectionCosinesFromDataSet(ds, dircos)
ImageHelper_GetDirectionCosinesFromDataSet = _gdcmswig.ImageHelper_GetDirectionCosinesFromDataSet

def ImageHelper_GetPhotometricInterpretationValue(f: 'File') -> "gdcm::PhotometricInterpretation":
    return _gdcmswig.ImageHelper_GetPhotometricInterpretationValue(f)
ImageHelper_GetPhotometricInterpretationValue = _gdcmswig.ImageHelper_GetPhotometricInterpretationValue

def ImageHelper_GetPlanarConfigurationValue(f: 'File') -> "unsigned int":
    return _gdcmswig.ImageHelper_GetPlanarConfigurationValue(f)
ImageHelper_GetPlanarConfigurationValue = _gdcmswig.ImageHelper_GetPlanarConfigurationValue

def ImageHelper_GetLUT(f: 'File') -> "gdcm::SmartPointer< gdcm::LookupTable >":
    return _gdcmswig.ImageHelper_GetLUT(f)
ImageHelper_GetLUT = _gdcmswig.ImageHelper_GetLUT

def ImageHelper_GetPointerFromElement(tag: 'Tag', f: 'File') -> "gdcm::ByteValue const *":
    return _gdcmswig.ImageHelper_GetPointerFromElement(tag, f)
ImageHelper_GetPointerFromElement = _gdcmswig.ImageHelper_GetPointerFromElement

def ImageHelper_ComputeMediaStorageFromModality(*args) -> "gdcm::MediaStorage":
    return _gdcmswig.ImageHelper_ComputeMediaStorageFromModality(*args)
ImageHelper_ComputeMediaStorageFromModality = _gdcmswig.ImageHelper_ComputeMediaStorageFromModality

class MD5(_object):
    """


    Class for MD5.

    WARNING:  this class is able to pick from two implementations:

    a lightweight md5 implementation (when GDCM_BUILD_TESTING is turned
    ON)

    the one from OpenSSL (when GDCM_USE_SYSTEM_OPENSSL is turned ON)

    In all other cases it will return an error

    C++ includes: gdcmMD5.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, MD5, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, MD5, name)
    __repr__ = _swig_repr
    if _newclass:
        Compute = staticmethod(_gdcmswig.MD5_Compute)
    else:
        Compute = _gdcmswig.MD5_Compute
    if _newclass:
        ComputeFile = staticmethod(_gdcmswig.MD5_ComputeFile)
    else:
        ComputeFile = _gdcmswig.MD5_ComputeFile

    def __init__(self):
        this = _gdcmswig.new_MD5()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_MD5
    __del__ = lambda self: None
MD5_swigregister = _gdcmswig.MD5_swigregister
MD5_swigregister(MD5)

def MD5_Compute(buffer: 'char const *', buf_len: 'size_t', digest_str: 'char [33]') -> "bool":
    return _gdcmswig.MD5_Compute(buffer, buf_len, digest_str)
MD5_Compute = _gdcmswig.MD5_Compute

def MD5_ComputeFile(filename: 'char const *', digest_str: 'char [33]') -> "bool":
    return _gdcmswig.MD5_ComputeFile(filename, digest_str)
MD5_ComputeFile = _gdcmswig.MD5_ComputeFile

class DummyValueGenerator(_object):
    """


    Class for generating dummy value.

    See:   Anonymizer

    C++ includes: gdcmDummyValueGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DummyValueGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DummyValueGenerator, name)
    __repr__ = _swig_repr
    if _newclass:
        Generate = staticmethod(_gdcmswig.DummyValueGenerator_Generate)
    else:
        Generate = _gdcmswig.DummyValueGenerator_Generate

    def __init__(self):
        this = _gdcmswig.new_DummyValueGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DummyValueGenerator
    __del__ = lambda self: None
DummyValueGenerator_swigregister = _gdcmswig.DummyValueGenerator_swigregister
DummyValueGenerator_swigregister(DummyValueGenerator)

def DummyValueGenerator_Generate(input: 'char const *') -> "char const *":
    return _gdcmswig.DummyValueGenerator_Generate(input)
DummyValueGenerator_Generate = _gdcmswig.DummyValueGenerator_Generate

class SHA1(_object):
    """


    Class for SHA1.

    WARNING:  this class is able to pick from one implementation:

    the one from OpenSSL (when GDCM_USE_SYSTEM_OPENSSL is turned ON)

    In all other cases it will return an error

    C++ includes: gdcmSHA1.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SHA1, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SHA1, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::SHA1::SHA1() """
        this = _gdcmswig.new_SHA1()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SHA1
    __del__ = lambda self: None
    if _newclass:
        Compute = staticmethod(_gdcmswig.SHA1_Compute)
    else:
        Compute = _gdcmswig.SHA1_Compute
    if _newclass:
        ComputeFile = staticmethod(_gdcmswig.SHA1_ComputeFile)
    else:
        ComputeFile = _gdcmswig.SHA1_ComputeFile
SHA1_swigregister = _gdcmswig.SHA1_swigregister
SHA1_swigregister(SHA1)

def SHA1_Compute(buffer: 'char const *', buf_len: 'unsigned long', digest_str: 'char [20*2+1]') -> "bool":
    return _gdcmswig.SHA1_Compute(buffer, buf_len, digest_str)
SHA1_Compute = _gdcmswig.SHA1_Compute

def SHA1_ComputeFile(filename: 'char const *', digest_str: 'char [20*2+1]') -> "bool":
    return _gdcmswig.SHA1_ComputeFile(filename, digest_str)
SHA1_ComputeFile = _gdcmswig.SHA1_ComputeFile

class Base64(_object):
    """


    Class for Base64.

    C++ includes: gdcmBase64.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Base64, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Base64, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    if _newclass:
        GetEncodeLength = staticmethod(_gdcmswig.Base64_GetEncodeLength)
    else:
        GetEncodeLength = _gdcmswig.Base64_GetEncodeLength
    if _newclass:
        Encode = staticmethod(_gdcmswig.Base64_Encode)
    else:
        Encode = _gdcmswig.Base64_Encode
    if _newclass:
        GetDecodeLength = staticmethod(_gdcmswig.Base64_GetDecodeLength)
    else:
        GetDecodeLength = _gdcmswig.Base64_GetDecodeLength
    if _newclass:
        Decode = staticmethod(_gdcmswig.Base64_Decode)
    else:
        Decode = _gdcmswig.Base64_Decode
    __swig_destroy__ = _gdcmswig.delete_Base64
    __del__ = lambda self: None
Base64_swigregister = _gdcmswig.Base64_swigregister
Base64_swigregister(Base64)

def Base64_GetEncodeLength(src: 'char const *', srclen: 'size_t') -> "size_t":
    return _gdcmswig.Base64_GetEncodeLength(src, srclen)
Base64_GetEncodeLength = _gdcmswig.Base64_GetEncodeLength

def Base64_Encode(dst: 'char *', dlen: 'size_t', src: 'char const *', slen: 'size_t') -> "size_t":
    return _gdcmswig.Base64_Encode(dst, dlen, src, slen)
Base64_Encode = _gdcmswig.Base64_Encode

def Base64_GetDecodeLength(src: 'char const *', len: 'size_t') -> "size_t":
    return _gdcmswig.Base64_GetDecodeLength(src, len)
Base64_GetDecodeLength = _gdcmswig.Base64_GetDecodeLength

def Base64_Decode(dst: 'char *', dlen: 'size_t', src: 'char const *', slen: 'size_t') -> "size_t":
    return _gdcmswig.Base64_Decode(dst, dlen, src, slen)
Base64_Decode = _gdcmswig.Base64_Decode

class CryptographicMessageSyntax(_object):
    """
    C++ includes:
    gdcmCryptographicMessageSyntax.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CryptographicMessageSyntax, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CryptographicMessageSyntax, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_CryptographicMessageSyntax
    __del__ = lambda self: None
    DES3_CIPHER = _gdcmswig.CryptographicMessageSyntax_DES3_CIPHER
    AES128_CIPHER = _gdcmswig.CryptographicMessageSyntax_AES128_CIPHER
    AES192_CIPHER = _gdcmswig.CryptographicMessageSyntax_AES192_CIPHER
    AES256_CIPHER = _gdcmswig.CryptographicMessageSyntax_AES256_CIPHER

    def ParseCertificateFile(self, filename: 'char const *') -> "bool":
        """
        virtual bool
        gdcm::CryptographicMessageSyntax::ParseCertificateFile(const char
        *filename)=0 
        """
        return _gdcmswig.CryptographicMessageSyntax_ParseCertificateFile(self, filename)


    def ParseKeyFile(self, filename: 'char const *') -> "bool":
        """
        virtual bool gdcm::CryptographicMessageSyntax::ParseKeyFile(const
        char *filename)=0 
        """
        return _gdcmswig.CryptographicMessageSyntax_ParseKeyFile(self, filename)


    def SetPassword(self, arg2: 'char const *', passLen: 'size_t') -> "bool":
        """
        virtual bool gdcm::CryptographicMessageSyntax::SetPassword(const char
        *pass, size_t passLen)=0 
        """
        return _gdcmswig.CryptographicMessageSyntax_SetPassword(self, arg2, passLen)


    def Encrypt(self, output: 'char *', outlen: 'size_t &', array: 'char const *', len: 'size_t') -> "bool":
        """
        virtual bool gdcm::CryptographicMessageSyntax::Encrypt(char *output,
        size_t &outlen, const char *array, size_t len) const =0

        create a CMS envelopedData structure 
        """
        return _gdcmswig.CryptographicMessageSyntax_Encrypt(self, output, outlen, array, len)


    def Decrypt(self, output: 'char *', outlen: 'size_t &', array: 'char const *', len: 'size_t') -> "bool":
        """
        virtual bool gdcm::CryptographicMessageSyntax::Decrypt(char *output,
        size_t &outlen, const char *array, size_t len) const =0

        decrypt content from a CMS envelopedData structure 
        """
        return _gdcmswig.CryptographicMessageSyntax_Decrypt(self, output, outlen, array, len)


    def SetCipherType(self, type: 'gdcm::CryptographicMessageSyntax::CipherTypes') -> "void":
        """
        virtual void
        gdcm::CryptographicMessageSyntax::SetCipherType(CipherTypes type)=0 
        """
        return _gdcmswig.CryptographicMessageSyntax_SetCipherType(self, type)


    def GetCipherType(self) -> "gdcm::CryptographicMessageSyntax::CipherTypes":
        """
        virtual CipherTypes
        gdcm::CryptographicMessageSyntax::GetCipherType() const =0 
        """
        return _gdcmswig.CryptographicMessageSyntax_GetCipherType(self)

CryptographicMessageSyntax_swigregister = _gdcmswig.CryptographicMessageSyntax_swigregister
CryptographicMessageSyntax_swigregister(CryptographicMessageSyntax)

class CryptoFactory(_object):
    """


    Class to do handle the crypto factory.

    GDCM needs to access in a platform independant way the user specified
    crypto engine. It can be: CAPI (windows only)

    OPENSSL (portable)

    OPENSSLP7 (portable) By default the factory will try: CAPI if on
    windows OPENSSL if possible OPENSSLP7 when older OpenSSL is used.

    C++ includes: gdcmCryptoFactory.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CryptoFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CryptoFactory, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DEFAULT = _gdcmswig.CryptoFactory_DEFAULT
    OPENSSL = _gdcmswig.CryptoFactory_OPENSSL
    CAPI = _gdcmswig.CryptoFactory_CAPI
    OPENSSLP7 = _gdcmswig.CryptoFactory_OPENSSLP7

    def CreateCMSProvider(self) -> "gdcm::CryptographicMessageSyntax *":
        """
        virtual CryptographicMessageSyntax*
        gdcm::CryptoFactory::CreateCMSProvider()=0 
        """
        return _gdcmswig.CryptoFactory_CreateCMSProvider(self)

    if _newclass:
        GetFactoryInstance = staticmethod(_gdcmswig.CryptoFactory_GetFactoryInstance)
    else:
        GetFactoryInstance = _gdcmswig.CryptoFactory_GetFactoryInstance
CryptoFactory_swigregister = _gdcmswig.CryptoFactory_swigregister
CryptoFactory_swigregister(CryptoFactory)

def CryptoFactory_GetFactoryInstance(*args) -> "gdcm::CryptoFactory *":
    return _gdcmswig.CryptoFactory_GetFactoryInstance(*args)
CryptoFactory_GetFactoryInstance = _gdcmswig.CryptoFactory_GetFactoryInstance

class Spacing(_object):
    """


    Class for Spacing.

    It all began with a mail to WG6:

    Subject: Imager Pixel Spacing vs Pixel Spacing Body: [Apologies for
    the duplicate post, namely to David Clunie & OFFIS team]

    I have been trying to understand CP-586 in the following two cases:

    On the one hand: DISCIMG/IMAGES/CRIMAGE taken
    fromhttp://dclunie.com/images/pixelspacingtestimages.zip

    And on the other hand:
    http://gdcm.sourceforge.net/thingies/cr_pixelspacing.dcm

    If I understand correctly the CP, one is required to use Pixel Spacing
    for measurement ('true size' print) instead of Imager Pixel Spacing,
    since the two attributes are present and Pixel Spacing is different
    from Imager Pixel Spacing.

    If this is correct, then the test data DISCIMG/IMAGES/CRIMAGE is
    incorrect. If this is incorrect (ie. I need to use Imager Pixel
    Spacing), then the display of cr_pixelspacing.dcm for measurement will
    be incorrect.

    Could someone please let me know what am I missing here? I could not
    find any information in any header that would allow me to
    differentiate those.

    Thank you for your time,

    Ref:http://lists.nema.org/scripts/lyris.pl?sub=488573&id=400720477

    See PS 3.3-2008, Table C.7-11b IMAGE PIXEL MACRO ATTRIBUTES

    Ratio of the vertical size and horizontal size of the pixels in the
    image specified by a pair of integer values where the first value is
    the vertical pixel size, and the second value is the horizontal pixel
    size. Required if the aspect ratio values do not have a ratio of 1:1
    and the physical pixel spacing is not specified by Pixel Spacing
    (0028,0030), or Imager Pixel Spacing (0018,1164) or Nominal Scanned
    Pixel Spacing (0018,2010), either for the entire Image or per-frame in
    a Functional Group Macro. See C.7.6.3.1.7.

    PS 3.3-2008 10.7.1.3 Pixel Spacing Value Order and Valid Values All
    pixel spacing related attributes shall have non-zero values, except
    when there is only a single row or column or pixel of data present, in
    which case the corresponding value may be zero.

    Ref:http://gdcm.sourceforge.net/wiki/index.php/Imager_Pixel_Spacing

    C++ includes: gdcmSpacing.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spacing, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Spacing, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::Spacing::Spacing() """
        this = _gdcmswig.new_Spacing()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_Spacing
    __del__ = lambda self: None
    DETECTOR = _gdcmswig.Spacing_DETECTOR
    MAGNIFIED = _gdcmswig.Spacing_MAGNIFIED
    CALIBRATED = _gdcmswig.Spacing_CALIBRATED
    UNKNOWN = _gdcmswig.Spacing_UNKNOWN
    if _newclass:
        ComputePixelAspectRatioFromPixelSpacing = staticmethod(_gdcmswig.Spacing_ComputePixelAspectRatioFromPixelSpacing)
    else:
        ComputePixelAspectRatioFromPixelSpacing = _gdcmswig.Spacing_ComputePixelAspectRatioFromPixelSpacing
Spacing_swigregister = _gdcmswig.Spacing_swigregister
Spacing_swigregister(Spacing)

def Spacing_ComputePixelAspectRatioFromPixelSpacing(pixelspacing: 'gdcm::Attribute< 0x28,0x30 > const &') -> "gdcm::Attribute< 0x28,0x34 >":
    return _gdcmswig.Spacing_ComputePixelAspectRatioFromPixelSpacing(pixelspacing)
Spacing_ComputePixelAspectRatioFromPixelSpacing = _gdcmswig.Spacing_ComputePixelAspectRatioFromPixelSpacing

class IconImageGenerator(_object):
    """


    IconImageGenerator.

    This filter will generate a valid Icon from the Pixel Data element (an
    instance of Pixmap). To generate a valid Icon, one is only allowed the
    following Photometric Interpretation: MONOCHROME1

    MONOCHROME2

    PALETTE_COLOR

    The Pixel Bits Allocated is restricted to 8bits, therefore 16 bits
    image needs to be rescaled. By default the filter will use the full
    scalar range of 16bits image to rescale to unsigned 8bits. This may
    not be ideal for some situation, in which case the API SetPixelMinMax
    can be used to overwrite the default min,max interval used.

    See:   ImageReader

    C++ includes: gdcmIconImageGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IconImageGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IconImageGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::IconImageGenerator::IconImageGenerator() """
        this = _gdcmswig.new_IconImageGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_IconImageGenerator
    __del__ = lambda self: None

    def SetPixmap(self, p: 'Pixmap') -> "void":
        """
        void
        gdcm::IconImageGenerator::SetPixmap(const Pixmap &p)

        Set/Get File. 
        """
        return _gdcmswig.IconImageGenerator_SetPixmap(self, p)


    def GetPixmap(self, *args) -> "gdcm::Pixmap const &":
        """
        const
        Pixmap& gdcm::IconImageGenerator::GetPixmap() const 
        """
        return _gdcmswig.IconImageGenerator_GetPixmap(self, *args)


    def SetOutputDimensions(self, dims: 'unsigned int const [2]') -> "void":
        """
        void gdcm::IconImageGenerator::SetOutputDimensions(const unsigned int
        dims[2])

        Set Target dimension of output Icon. 
        """
        return _gdcmswig.IconImageGenerator_SetOutputDimensions(self, dims)


    def SetPixelMinMax(self, min: 'double', max: 'double') -> "void":
        """
        void
        gdcm::IconImageGenerator::SetPixelMinMax(double min, double max)

        Override default min/max to compute best rescale for 16bits -> 8bits
        downscale. Typically those value can be read from the
        SmallestImagePixelValue LargestImagePixelValue DICOM attribute. 
        """
        return _gdcmswig.IconImageGenerator_SetPixelMinMax(self, min, max)


    def AutoPixelMinMax(self, b: 'bool') -> "void":
        """
        void gdcm::IconImageGenerator::AutoPixelMinMax(bool b)

        Instead of explicitly specifying the min/max value for the rescale
        operation, let the internal mechanism compute the min/max of icon and
        rescale to best appropriate. 
        """
        return _gdcmswig.IconImageGenerator_AutoPixelMinMax(self, b)


    def ConvertRGBToPaletteColor(self, b: 'bool') -> "void":
        """
        void
        gdcm::IconImageGenerator::ConvertRGBToPaletteColor(bool b)

        Converting from RGB to PALETTE_COLOR can be a slow operation. However
        DICOM standard requires that color icon be described as palette. Set
        this boolean to false only if you understand the consequences. default
        value is true, false generates invalid Icon Image Sequence 
        """
        return _gdcmswig.IconImageGenerator_ConvertRGBToPaletteColor(self, b)


    def SetOutsideValuePixel(self, v: 'double') -> "void":
        """
        void gdcm::IconImageGenerator::SetOutsideValuePixel(double v)

        Set a pixel value that should be discarded. This happen typically for
        CT image, where a pixel has been used to pad outside the image (see
        Pixel Padding Value). Requires AutoPixelMinMax(true) 
        """
        return _gdcmswig.IconImageGenerator_SetOutsideValuePixel(self, v)


    def Generate(self) -> "bool":
        """
        bool
        gdcm::IconImageGenerator::Generate()

        Generate Icon. 
        """
        return _gdcmswig.IconImageGenerator_Generate(self)


    def GetIconImage(self) -> "gdcm::IconImage const &":
        """
        const
        IconImage& gdcm::IconImageGenerator::GetIconImage() const

        Retrieve generated Icon. 
        """
        return _gdcmswig.IconImageGenerator_GetIconImage(self)

IconImageGenerator_swigregister = _gdcmswig.IconImageGenerator_swigregister
IconImageGenerator_swigregister(IconImageGenerator)

class IconImageFilter(_object):
    """


    IconImageFilter.

    This filter will extract icons from a File This filter will loop over
    all known sequence (public and private) that may contains an IconImage
    and retrieve them. The filter will fails with a value of false if no
    icon can be found Since it handle both public and private icon type,
    one should not assume the icon is in uncompress form, some private
    vendor store private icon in JPEG8/JPEG12

    Implementation details: This filter supports the following Icons:
    (0088,0200) Icon Image Sequence

    (0009,10,GEIIS) GE IIS Thumbnail Sequence

    (6003,10,GEMS_Ultrasound_ImageGroup_001) GEMS Image Thumbnail Sequence

    (0055,30,VEPRO VIF 3.0 DATA) Icon Data

    (0055,30,VEPRO VIM 5.0 DATA) ICONDATA2

    WARNING:  the icon stored in those private attribute do not conform to
    definition of Icon Image Sequence (do not simply copy/paste). For
    example some private icon can be expressed as 12bits pixel, while the
    DICOM standard only allow 8bits icons.

    See:   ImageReader

    C++ includes: gdcmIconImageFilter.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, IconImageFilter, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, IconImageFilter, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::IconImageFilter::IconImageFilter() """
        this = _gdcmswig.new_IconImageFilter()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_IconImageFilter
    __del__ = lambda self: None

    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::IconImageFilter::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.IconImageFilter_SetFile(self, f)


    def GetFile(self, *args) -> "gdcm::File const &":
        """
        const File&
        gdcm::IconImageFilter::GetFile() const 
        """
        return _gdcmswig.IconImageFilter_GetFile(self, *args)


    def Extract(self) -> "bool":
        """
        bool
        gdcm::IconImageFilter::Extract()

        Extract all Icon found in File. 
        """
        return _gdcmswig.IconImageFilter_Extract(self)


    def GetNumberOfIconImages(self) -> "unsigned int":
        """
        unsigned int gdcm::IconImageFilter::GetNumberOfIconImages() const

        Retrieve extract IconImage (need to call Extract first) 
        """
        return _gdcmswig.IconImageFilter_GetNumberOfIconImages(self)


    def GetIconImage(self, i: 'unsigned int') -> "gdcm::IconImage &":
        """
        IconImage& gdcm::IconImageFilter::GetIconImage(unsigned int i) const

        """
        return _gdcmswig.IconImageFilter_GetIconImage(self, i)

IconImageFilter_swigregister = _gdcmswig.IconImageFilter_swigregister
IconImageFilter_swigregister(IconImageFilter)

class SimpleSubjectWatcher(_object):
    """


    SimpleSubjectWatcher.

    This is a typical Subject Watcher class. It will observe all events.

    C++ includes: gdcmSimpleSubjectWatcher.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, SimpleSubjectWatcher, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, SimpleSubjectWatcher, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::SimpleSubjectWatcher::SimpleSubjectWatcher(Subject *s, const
        char *comment="") 
        """
        if self.__class__ == SimpleSubjectWatcher:
            _self = None
        else:
            _self = self
        this = _gdcmswig.new_SimpleSubjectWatcher(_self, *args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_SimpleSubjectWatcher
    __del__ = lambda self: None

    def StartFilter(self) -> "void":
        return _gdcmswig.SimpleSubjectWatcher_StartFilter(self)

    def EndFilter(self) -> "void":
        return _gdcmswig.SimpleSubjectWatcher_EndFilter(self)

    def ShowProgress(self, caller: 'Subject', evt: 'Event') -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowProgress(self, caller, evt)

    def ShowFileName(self, caller: 'Subject', evt: 'Event') -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowFileName(self, caller, evt)

    def ShowIteration(self) -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowIteration(self)

    def ShowAnonymization(self, caller: 'Subject', evt: 'Event') -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowAnonymization(self, caller, evt)

    def ShowDataSet(self, caller: 'Subject', evt: 'Event') -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowDataSet(self, caller, evt)

    def ShowData(self, caller: 'Subject', evt: 'Event') -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowData(self, caller, evt)

    def ShowAbort(self) -> "void":
        return _gdcmswig.SimpleSubjectWatcher_ShowAbort(self)
    def __disown__(self):
        self.this.disown()
        _gdcmswig.disown_SimpleSubjectWatcher(self)
        return weakref_proxy(self)
SimpleSubjectWatcher_swigregister = _gdcmswig.SimpleSubjectWatcher_swigregister
SimpleSubjectWatcher_swigregister(SimpleSubjectWatcher)

class DICOMDIRGenerator(_object):
    """


    DICOMDIRGenerator class.

    This is a STD-GEN-CD DICOMDIR generator. ref: PS 3.11-2008 Annex D
    (Normative) - General Purpose CD-R and DVD Interchange Profiles

    PS 3.11 - 2008 / D.3.2 Physical Medium And Medium Format The STD-GEN-
    CD and STD-GEN-SEC-CD application profiles require the 120 mm CD-R
    physical medium with the ISO/IEC 9660 Media Format, as defined in
    PS3.12. See also PS 3.12 - 2008 / Annex F 120mm CD-R Medium
    (Normative) and PS 3.10 - 2008 / 8 DICOM File Service / 8.1 FILE-SET

    WARNING:  : PS 3.11 - 2008 / D.3.1 SOP Classes and Transfer Syntaxes
    Composite Image & Stand-alone Storage are required to be stored as
    Explicit VR Little Endian Uncompressed (1.2.840.10008.1.2.1). When a
    DICOM file is found using another Transfer Syntax the generator will
    simply stops.

    WARNING:

    Input files should be Explicit VR Little Endian

    filenames should be valid VR::CS value (16 bytes, upper case ...)

    Bug : There is a current limitation of not handling Referenced SOP
    Class UID / Referenced SOP Instance UID simply because the Scanner
    does not allow us See PS 3.11 / Table D.3-2 STD-GEN Additional
    DICOMDIR Keys

    C++ includes: gdcmDICOMDIRGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DICOMDIRGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DICOMDIRGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::DICOMDIRGenerator::DICOMDIRGenerator() """
        this = _gdcmswig.new_DICOMDIRGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_DICOMDIRGenerator
    __del__ = lambda self: None

    def SetFilenames(self, fns: 'FilenamesType') -> "void":
        """
        void
        gdcm::DICOMDIRGenerator::SetFilenames(FilenamesType const &fns)

        Set the list of filenames from which the DICOMDIR should be generated
        from. 
        """
        return _gdcmswig.DICOMDIRGenerator_SetFilenames(self, fns)


    def SetRootDirectory(self, root: 'gdcm::DICOMDIRGenerator::FilenameType const &') -> "void":
        """
        void gdcm::DICOMDIRGenerator::SetRootDirectory(FilenameType const
        &root)

        Set the root directory from which the filenames should be considered.

        """
        return _gdcmswig.DICOMDIRGenerator_SetRootDirectory(self, root)


    def SetDescriptor(self, d: 'char const *') -> "void":
        """
        void
        gdcm::DICOMDIRGenerator::SetDescriptor(const char *d)

        Set the File Set ID. WARNING:  this need to be a valid VR::CS value 
        """
        return _gdcmswig.DICOMDIRGenerator_SetDescriptor(self, d)


    def Generate(self) -> "bool":
        """
        bool
        gdcm::DICOMDIRGenerator::Generate()

        Main function to generate the DICOMDIR. 
        """
        return _gdcmswig.DICOMDIRGenerator_Generate(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::DICOMDIRGenerator::SetFile(const File &f)

        Set/Get file. The DICOMDIR file will be valid once a call to Generate
        has been done. 
        """
        return _gdcmswig.DICOMDIRGenerator_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """
        File&
        gdcm::DICOMDIRGenerator::GetFile() 
        """
        return _gdcmswig.DICOMDIRGenerator_GetFile(self)

DICOMDIRGenerator_swigregister = _gdcmswig.DICOMDIRGenerator_swigregister
DICOMDIRGenerator_swigregister(DICOMDIRGenerator)

class FileDerivation(_object):
    """


    FileDerivation class.

    See PS 3.16 - 2008 For the list of Code Value that can be used for in
    Derivation Code Sequence

    URL:http://medical.nema.org/medical/dicom/2008/08_16pu.pdf

    DICOM Part 16 has two Context Groups CID 7202 and CID 7203 which
    contain a set of codes defining reason for a source image reference
    (ie. reason code for referenced image sequence) and a coded
    description of the deriation applied to the new image data from the
    original. Both these context groups are extensible.

    File Derivation is compulsary when creating a lossy derived image.

    C++ includes: gdcmFileDerivation.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileDerivation, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileDerivation, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileDerivation::FileDerivation() """
        this = _gdcmswig.new_FileDerivation()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileDerivation
    __del__ = lambda self: None

    def AddReference(self, referencedsopclassuid: 'char const *', referencedsopinstanceuid: 'char const *') -> "bool":
        """
        bool
        gdcm::FileDerivation::AddReference(const char *referencedsopclassuid,
        const char *referencedsopinstanceuid)

        Create the proper reference. Need to pass the original SOP Class UID
        and the original SOP Instance UID, so that those value can be used as
        Reference. WARNING:  referencedsopclassuid and
        referencedsopinstanceuid needs to be \\0 padded. This is not
        compatible with how ByteValue->GetPointer works. 
        """
        return _gdcmswig.FileDerivation_AddReference(self, referencedsopclassuid, referencedsopinstanceuid)


    def SetPurposeOfReferenceCodeSequenceCodeValue(self, codevalue: 'unsigned int') -> "void":
        """
        void
        gdcm::FileDerivation::SetPurposeOfReferenceCodeSequenceCodeValue(unsigned
        int codevalue)

        Specify the Purpose Of Reference Code Value. Eg. 121320. 
        """
        return _gdcmswig.FileDerivation_SetPurposeOfReferenceCodeSequenceCodeValue(self, codevalue)


    def SetDerivationCodeSequenceCodeValue(self, codevalue: 'unsigned int') -> "void":
        """
        void
        gdcm::FileDerivation::SetDerivationCodeSequenceCodeValue(unsigned int
        codevalue)

        Specify the Derivation Code Sequence Code Value. Eg 113040. 
        """
        return _gdcmswig.FileDerivation_SetDerivationCodeSequenceCodeValue(self, codevalue)


    def SetDerivationDescription(self, dd: 'char const *') -> "void":
        """
        void gdcm::FileDerivation::SetDerivationDescription(const char *dd)

        Specify the Derivation Description. Eg "lossy conversion". 
        """
        return _gdcmswig.FileDerivation_SetDerivationDescription(self, dd)


    def SetAppendDerivationHistory(self, b: 'bool') -> "void":
        return _gdcmswig.FileDerivation_SetAppendDerivationHistory(self, b)

    def Derive(self) -> "bool":
        """
        bool
        gdcm::FileDerivation::Derive()

        Change. 
        """
        return _gdcmswig.FileDerivation_Derive(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::FileDerivation::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.FileDerivation_SetFile(self, f)


    def GetFile(self, *args) -> "gdcm::File const &":
        """
        const File&
        gdcm::FileDerivation::GetFile() const 
        """
        return _gdcmswig.FileDerivation_GetFile(self, *args)

FileDerivation_swigregister = _gdcmswig.FileDerivation_swigregister
FileDerivation_swigregister(FileDerivation)

class DataSetArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, DataSetArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, DataSetArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.DataSetArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.DataSetArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.DataSetArrayType___bool__(self)

    def __len__(self) -> "std::vector< gdcm::DataSet >::size_type":
        return _gdcmswig.DataSetArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< gdcm::DataSet >::difference_type', j: 'std::vector< gdcm::DataSet >::difference_type') -> "std::vector< gdcm::DataSet,std::allocator< gdcm::DataSet > > *":
        return _gdcmswig.DataSetArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.DataSetArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< gdcm::DataSet >::difference_type', j: 'std::vector< gdcm::DataSet >::difference_type') -> "void":
        return _gdcmswig.DataSetArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.DataSetArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gdcm::DataSet >::value_type const &":
        return _gdcmswig.DataSetArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.DataSetArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< gdcm::DataSet >::value_type":
        return _gdcmswig.DataSetArrayType_pop(self)

    def append(self, x: 'DataSet') -> "void":
        return _gdcmswig.DataSetArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.DataSetArrayType_empty(self)

    def size(self) -> "std::vector< gdcm::DataSet >::size_type":
        return _gdcmswig.DataSetArrayType_size(self)

    def swap(self, v: 'DataSetArrayType') -> "void":
        return _gdcmswig.DataSetArrayType_swap(self, v)

    def begin(self) -> "std::vector< gdcm::DataSet >::iterator":
        return _gdcmswig.DataSetArrayType_begin(self)

    def end(self) -> "std::vector< gdcm::DataSet >::iterator":
        return _gdcmswig.DataSetArrayType_end(self)

    def rbegin(self) -> "std::vector< gdcm::DataSet >::reverse_iterator":
        return _gdcmswig.DataSetArrayType_rbegin(self)

    def rend(self) -> "std::vector< gdcm::DataSet >::reverse_iterator":
        return _gdcmswig.DataSetArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.DataSetArrayType_clear(self)

    def get_allocator(self) -> "std::vector< gdcm::DataSet >::allocator_type":
        return _gdcmswig.DataSetArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.DataSetArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< gdcm::DataSet >::iterator":
        return _gdcmswig.DataSetArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_DataSetArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'DataSet') -> "void":
        return _gdcmswig.DataSetArrayType_push_back(self, x)

    def front(self) -> "std::vector< gdcm::DataSet >::value_type const &":
        return _gdcmswig.DataSetArrayType_front(self)

    def back(self) -> "std::vector< gdcm::DataSet >::value_type const &":
        return _gdcmswig.DataSetArrayType_back(self)

    def assign(self, n: 'std::vector< gdcm::DataSet >::size_type', x: 'DataSet') -> "void":
        return _gdcmswig.DataSetArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.DataSetArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.DataSetArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< gdcm::DataSet >::size_type') -> "void":
        return _gdcmswig.DataSetArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< gdcm::DataSet >::size_type":
        return _gdcmswig.DataSetArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_DataSetArrayType
    __del__ = lambda self: None
DataSetArrayType_swigregister = _gdcmswig.DataSetArrayType_swigregister
DataSetArrayType_swigregister(DataSetArrayType)

class FileArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, FileArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.FileArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.FileArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.FileArrayType___bool__(self)

    def __len__(self) -> "std::vector< gdcm::File >::size_type":
        return _gdcmswig.FileArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< gdcm::File >::difference_type', j: 'std::vector< gdcm::File >::difference_type') -> "std::vector< gdcm::File,std::allocator< gdcm::File > > *":
        return _gdcmswig.FileArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.FileArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< gdcm::File >::difference_type', j: 'std::vector< gdcm::File >::difference_type') -> "void":
        return _gdcmswig.FileArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.FileArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gdcm::File >::value_type const &":
        return _gdcmswig.FileArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.FileArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< gdcm::File >::value_type":
        return _gdcmswig.FileArrayType_pop(self)

    def append(self, x: 'File') -> "void":
        return _gdcmswig.FileArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.FileArrayType_empty(self)

    def size(self) -> "std::vector< gdcm::File >::size_type":
        return _gdcmswig.FileArrayType_size(self)

    def swap(self, v: 'FileArrayType') -> "void":
        return _gdcmswig.FileArrayType_swap(self, v)

    def begin(self) -> "std::vector< gdcm::File >::iterator":
        return _gdcmswig.FileArrayType_begin(self)

    def end(self) -> "std::vector< gdcm::File >::iterator":
        return _gdcmswig.FileArrayType_end(self)

    def rbegin(self) -> "std::vector< gdcm::File >::reverse_iterator":
        return _gdcmswig.FileArrayType_rbegin(self)

    def rend(self) -> "std::vector< gdcm::File >::reverse_iterator":
        return _gdcmswig.FileArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.FileArrayType_clear(self)

    def get_allocator(self) -> "std::vector< gdcm::File >::allocator_type":
        return _gdcmswig.FileArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.FileArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< gdcm::File >::iterator":
        return _gdcmswig.FileArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_FileArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'File') -> "void":
        return _gdcmswig.FileArrayType_push_back(self, x)

    def front(self) -> "std::vector< gdcm::File >::value_type const &":
        return _gdcmswig.FileArrayType_front(self)

    def back(self) -> "std::vector< gdcm::File >::value_type const &":
        return _gdcmswig.FileArrayType_back(self)

    def assign(self, n: 'std::vector< gdcm::File >::size_type', x: 'File') -> "void":
        return _gdcmswig.FileArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.FileArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.FileArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< gdcm::File >::size_type') -> "void":
        return _gdcmswig.FileArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< gdcm::File >::size_type":
        return _gdcmswig.FileArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_FileArrayType
    __del__ = lambda self: None
FileArrayType_swigregister = _gdcmswig.FileArrayType_swigregister
FileArrayType_swigregister(FileArrayType)

class PresentationContextArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresentationContextArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresentationContextArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.PresentationContextArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.PresentationContextArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.PresentationContextArrayType___bool__(self)

    def __len__(self) -> "std::vector< gdcm::PresentationContext >::size_type":
        return _gdcmswig.PresentationContextArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< gdcm::PresentationContext >::difference_type', j: 'std::vector< gdcm::PresentationContext >::difference_type') -> "std::vector< gdcm::PresentationContext,std::allocator< gdcm::PresentationContext > > *":
        return _gdcmswig.PresentationContextArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.PresentationContextArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< gdcm::PresentationContext >::difference_type', j: 'std::vector< gdcm::PresentationContext >::difference_type') -> "void":
        return _gdcmswig.PresentationContextArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.PresentationContextArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gdcm::PresentationContext >::value_type const &":
        return _gdcmswig.PresentationContextArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.PresentationContextArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< gdcm::PresentationContext >::value_type":
        return _gdcmswig.PresentationContextArrayType_pop(self)

    def append(self, x: 'PresentationContext') -> "void":
        return _gdcmswig.PresentationContextArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.PresentationContextArrayType_empty(self)

    def size(self) -> "std::vector< gdcm::PresentationContext >::size_type":
        return _gdcmswig.PresentationContextArrayType_size(self)

    def swap(self, v: 'PresentationContextArrayType') -> "void":
        return _gdcmswig.PresentationContextArrayType_swap(self, v)

    def begin(self) -> "std::vector< gdcm::PresentationContext >::iterator":
        return _gdcmswig.PresentationContextArrayType_begin(self)

    def end(self) -> "std::vector< gdcm::PresentationContext >::iterator":
        return _gdcmswig.PresentationContextArrayType_end(self)

    def rbegin(self) -> "std::vector< gdcm::PresentationContext >::reverse_iterator":
        return _gdcmswig.PresentationContextArrayType_rbegin(self)

    def rend(self) -> "std::vector< gdcm::PresentationContext >::reverse_iterator":
        return _gdcmswig.PresentationContextArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.PresentationContextArrayType_clear(self)

    def get_allocator(self) -> "std::vector< gdcm::PresentationContext >::allocator_type":
        return _gdcmswig.PresentationContextArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.PresentationContextArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< gdcm::PresentationContext >::iterator":
        return _gdcmswig.PresentationContextArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_PresentationContextArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'PresentationContext') -> "void":
        return _gdcmswig.PresentationContextArrayType_push_back(self, x)

    def front(self) -> "std::vector< gdcm::PresentationContext >::value_type const &":
        return _gdcmswig.PresentationContextArrayType_front(self)

    def back(self) -> "std::vector< gdcm::PresentationContext >::value_type const &":
        return _gdcmswig.PresentationContextArrayType_back(self)

    def assign(self, n: 'std::vector< gdcm::PresentationContext >::size_type', x: 'PresentationContext') -> "void":
        return _gdcmswig.PresentationContextArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.PresentationContextArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.PresentationContextArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< gdcm::PresentationContext >::size_type') -> "void":
        return _gdcmswig.PresentationContextArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< gdcm::PresentationContext >::size_type":
        return _gdcmswig.PresentationContextArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_PresentationContextArrayType
    __del__ = lambda self: None
PresentationContextArrayType_swigregister = _gdcmswig.PresentationContextArrayType_swigregister
PresentationContextArrayType_swigregister(PresentationContextArrayType)

class KeyValuePairType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyValuePairType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeyValuePairType, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        this = _gdcmswig.new_KeyValuePairType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_setmethods__["first"] = _gdcmswig.KeyValuePairType_first_set
    __swig_getmethods__["first"] = _gdcmswig.KeyValuePairType_first_get
    if _newclass:
        first = _swig_property(_gdcmswig.KeyValuePairType_first_get, _gdcmswig.KeyValuePairType_first_set)
    __swig_setmethods__["second"] = _gdcmswig.KeyValuePairType_second_set
    __swig_getmethods__["second"] = _gdcmswig.KeyValuePairType_second_get
    if _newclass:
        second = _swig_property(_gdcmswig.KeyValuePairType_second_get, _gdcmswig.KeyValuePairType_second_set)
    def __len__(self):
        return 2
    def __repr__(self):
        return str((self.first, self.second))
    def __getitem__(self, index): 
        if not (index % 2):
            return self.first
        else:
            return self.second
    def __setitem__(self, index, val):
        if not (index % 2):
            self.first = val
        else:
            self.second = val
    __swig_destroy__ = _gdcmswig.delete_KeyValuePairType
    __del__ = lambda self: None
KeyValuePairType_swigregister = _gdcmswig.KeyValuePairType_swigregister
KeyValuePairType_swigregister(KeyValuePairType)

class KeyValuePairArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, KeyValuePairArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, KeyValuePairArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.KeyValuePairArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.KeyValuePairArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.KeyValuePairArrayType___bool__(self)

    def __len__(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::size_type":
        return _gdcmswig.KeyValuePairArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< std::pair< gdcm::Tag,std::string > >::difference_type', j: 'std::vector< std::pair< gdcm::Tag,std::string > >::difference_type') -> "std::vector< std::pair< gdcm::Tag,std::string >,std::allocator< std::pair< gdcm::Tag,std::string > > > *":
        return _gdcmswig.KeyValuePairArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.KeyValuePairArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< std::pair< gdcm::Tag,std::string > >::difference_type', j: 'std::vector< std::pair< gdcm::Tag,std::string > >::difference_type') -> "void":
        return _gdcmswig.KeyValuePairArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.KeyValuePairArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::pair< gdcm::Tag,std::string > >::value_type const &":
        return _gdcmswig.KeyValuePairArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.KeyValuePairArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::value_type":
        return _gdcmswig.KeyValuePairArrayType_pop(self)

    def append(self, x: 'KeyValuePairType') -> "void":
        return _gdcmswig.KeyValuePairArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.KeyValuePairArrayType_empty(self)

    def size(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::size_type":
        return _gdcmswig.KeyValuePairArrayType_size(self)

    def swap(self, v: 'KeyValuePairArrayType') -> "void":
        return _gdcmswig.KeyValuePairArrayType_swap(self, v)

    def begin(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::iterator":
        return _gdcmswig.KeyValuePairArrayType_begin(self)

    def end(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::iterator":
        return _gdcmswig.KeyValuePairArrayType_end(self)

    def rbegin(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::reverse_iterator":
        return _gdcmswig.KeyValuePairArrayType_rbegin(self)

    def rend(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::reverse_iterator":
        return _gdcmswig.KeyValuePairArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.KeyValuePairArrayType_clear(self)

    def get_allocator(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::allocator_type":
        return _gdcmswig.KeyValuePairArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.KeyValuePairArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< std::pair< gdcm::Tag,std::string > >::iterator":
        return _gdcmswig.KeyValuePairArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_KeyValuePairArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'KeyValuePairType') -> "void":
        return _gdcmswig.KeyValuePairArrayType_push_back(self, x)

    def front(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::value_type const &":
        return _gdcmswig.KeyValuePairArrayType_front(self)

    def back(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::value_type const &":
        return _gdcmswig.KeyValuePairArrayType_back(self)

    def assign(self, n: 'std::vector< std::pair< gdcm::Tag,std::string > >::size_type', x: 'KeyValuePairType') -> "void":
        return _gdcmswig.KeyValuePairArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.KeyValuePairArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.KeyValuePairArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< std::pair< gdcm::Tag,std::string > >::size_type') -> "void":
        return _gdcmswig.KeyValuePairArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< std::pair< gdcm::Tag,std::string > >::size_type":
        return _gdcmswig.KeyValuePairArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_KeyValuePairArrayType
    __del__ = lambda self: None
KeyValuePairArrayType_swigregister = _gdcmswig.KeyValuePairArrayType_swigregister
KeyValuePairArrayType_swigregister(KeyValuePairArrayType)

class TagArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, TagArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, TagArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.TagArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.TagArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.TagArrayType___bool__(self)

    def __len__(self) -> "std::vector< gdcm::Tag >::size_type":
        return _gdcmswig.TagArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< gdcm::Tag >::difference_type', j: 'std::vector< gdcm::Tag >::difference_type') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > > *":
        return _gdcmswig.TagArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.TagArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< gdcm::Tag >::difference_type', j: 'std::vector< gdcm::Tag >::difference_type') -> "void":
        return _gdcmswig.TagArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.TagArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< gdcm::Tag >::value_type const &":
        return _gdcmswig.TagArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.TagArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< gdcm::Tag >::value_type":
        return _gdcmswig.TagArrayType_pop(self)

    def append(self, x: 'Tag') -> "void":
        return _gdcmswig.TagArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.TagArrayType_empty(self)

    def size(self) -> "std::vector< gdcm::Tag >::size_type":
        return _gdcmswig.TagArrayType_size(self)

    def swap(self, v: 'TagArrayType') -> "void":
        return _gdcmswig.TagArrayType_swap(self, v)

    def begin(self) -> "std::vector< gdcm::Tag >::iterator":
        return _gdcmswig.TagArrayType_begin(self)

    def end(self) -> "std::vector< gdcm::Tag >::iterator":
        return _gdcmswig.TagArrayType_end(self)

    def rbegin(self) -> "std::vector< gdcm::Tag >::reverse_iterator":
        return _gdcmswig.TagArrayType_rbegin(self)

    def rend(self) -> "std::vector< gdcm::Tag >::reverse_iterator":
        return _gdcmswig.TagArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.TagArrayType_clear(self)

    def get_allocator(self) -> "std::vector< gdcm::Tag >::allocator_type":
        return _gdcmswig.TagArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.TagArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< gdcm::Tag >::iterator":
        return _gdcmswig.TagArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_TagArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'Tag') -> "void":
        return _gdcmswig.TagArrayType_push_back(self, x)

    def front(self) -> "std::vector< gdcm::Tag >::value_type const &":
        return _gdcmswig.TagArrayType_front(self)

    def back(self) -> "std::vector< gdcm::Tag >::value_type const &":
        return _gdcmswig.TagArrayType_back(self)

    def assign(self, n: 'std::vector< gdcm::Tag >::size_type', x: 'Tag') -> "void":
        return _gdcmswig.TagArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.TagArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.TagArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< gdcm::Tag >::size_type') -> "void":
        return _gdcmswig.TagArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< gdcm::Tag >::size_type":
        return _gdcmswig.TagArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_TagArrayType
    __del__ = lambda self: None
TagArrayType_swigregister = _gdcmswig.TagArrayType_swigregister
TagArrayType_swigregister(TagArrayType)

ePatientRootType = _gdcmswig.ePatientRootType
eStudyRootType = _gdcmswig.eStudyRootType
class QueryBase(_object):
    """


    QueryBase.

    contains: the base class for constructing a query dataset for a C-FIND
    and a C-MOVE

    There are four levels of C-FIND and C-MOVE query:  Patient

    Study

    Series

    Image  Each one has its own required and optional tags. This class
    provides an interface for getting those tags. This is an interface
    class.

    See 3.4 C 6.1 and 3.4 C 6.2 for the patient and study root query
    types. These sections define the tags allowed by a particular query.
    The caller must pass in which root type they want, patient or study. A
    third root type, Modality Worklist Query, isn't yet supported.

    This class (or rather it's derived classes) will be held in the
    RootQuery types. These query types actually make the dataset, and will
    use this dataset to list the required, unique, and optional tags for
    each type of query. This design is somewhat overly complicated, but is
    kept so that if we ever wanted to try to guess the query type from the
    given tags, we could do so.

    C++ includes: gdcmQueryBase.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QueryBase, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QueryBase, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_QueryBase
    __del__ = lambda self: None

    def GetRequiredTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        virtual
        std::vector<Tag> gdcm::QueryBase::GetRequiredTags(const ERootType
        &inRootType) const =0 
        """
        return _gdcmswig.QueryBase_GetRequiredTags(self, inRootType)


    def GetUniqueTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        virtual
        std::vector<Tag> gdcm::QueryBase::GetUniqueTags(const ERootType
        &inRootType) const =0 
        """
        return _gdcmswig.QueryBase_GetUniqueTags(self, inRootType)


    def GetOptionalTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        virtual
        std::vector<Tag> gdcm::QueryBase::GetOptionalTags(const ERootType
        &inRootType) const =0 
        """
        return _gdcmswig.QueryBase_GetOptionalTags(self, inRootType)


    def GetHierachicalSearchTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        virtual std::vector<Tag>
        gdcm::QueryBase::GetHierachicalSearchTags(const ERootType &inRootType)
        const =0

        Return all Unique Key for a particular Query Root type (from the same
        level and above). 
        """
        return _gdcmswig.QueryBase_GetHierachicalSearchTags(self, inRootType)


    def GetAllTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        std::vector<Tag>
        gdcm::QueryBase::GetAllTags(const ERootType &inRootType) const

        In order to validate a query dataset, just check for the presence of a
        tag, not it's requirement level in the spec 
        """
        return _gdcmswig.QueryBase_GetAllTags(self, inRootType)


    def GetAllRequiredTags(self, inRootType: 'gdcm::ERootType const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        std::vector<Tag> gdcm::QueryBase::GetAllRequiredTags(const ERootType
        &inRootType) const

        In order to validate a query dataset we need to check that there
        exists at least one required (or unique) key 
        """
        return _gdcmswig.QueryBase_GetAllRequiredTags(self, inRootType)


    def GetName(self) -> "char const *":
        """
        virtual const char*
        gdcm::QueryBase::GetName() const =0 
        """
        return _gdcmswig.QueryBase_GetName(self)


    def GetQueryLevel(self) -> "gdcm::DataElement":
        """
        virtual
        DataElement gdcm::QueryBase::GetQueryLevel() const =0 
        """
        return _gdcmswig.QueryBase_GetQueryLevel(self)

QueryBase_swigregister = _gdcmswig.QueryBase_swigregister
QueryBase_swigregister(QueryBase)

ePatient = _gdcmswig.ePatient
eStudy = _gdcmswig.eStudy
eSeries = _gdcmswig.eSeries
eImage = _gdcmswig.eImage
eFind = _gdcmswig.eFind
eMove = _gdcmswig.eMove
eWLMFind = _gdcmswig.eWLMFind
class BaseRootQuery(_object):
    """


    BaseRootQuery.

    contains: a baseclass which will produce a dataset for c-find and
    c-move with patient/study root

    This class contains the functionality used in patient c-find and
    c-move queries. PatientRootQuery and StudyRootQuery derive from this
    class.

    Namely: 1) list all tags associated with a particular query type 2)
    produce a query dataset via tag association

    Eventually, it can be used to validate a particular dataset type.

    The dataset held by this object (or, really, one of its derivates)
    should be passed to a c-find or c-move query.

    C++ includes: gdcmBaseRootQuery.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, BaseRootQuery, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, BaseRootQuery, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_BaseRootQuery
    __del__ = lambda self: None

    def GetTagListByLevel(self, inQueryLevel: 'gdcm::EQueryLevel const &') -> "std::vector< gdcm::Tag,std::allocator< gdcm::Tag > >":
        """
        virtual std::vector<Tag> gdcm::BaseRootQuery::GetTagListByLevel(const
        EQueryLevel &inQueryLevel)=0

        this function will return all tags at a given query level, so that
        they maybe selected for searching. The boolean forFind is true if the
        query is a find query, or false for a move query. 
        """
        return _gdcmswig.BaseRootQuery_GetTagListByLevel(self, inQueryLevel)


    def InitializeDataSet(self, inQueryLevel: 'gdcm::EQueryLevel const &') -> "void":
        """
        virtual void gdcm::BaseRootQuery::InitializeDataSet(const EQueryLevel
        &inQueryLevel)=0

        this function sets tag 8,52 to the appropriate value based on query
        level also fills in the right unique tags, as per the standard's
        requirements should allow for connection with dcmtk 
        """
        return _gdcmswig.BaseRootQuery_InitializeDataSet(self, inQueryLevel)


    def ValidateQuery(self, inStrict: 'bool'=True) -> "bool":
        """
        virtual
        bool gdcm::BaseRootQuery::ValidateQuery(bool inStrict=true) const =0

        have to be able to ensure that 0x8,0x52 is set (which will be true if
        InitializeDataSet is called...) that the level is appropriate (ie, not
        setting PATIENT for a study query that the tags in the query match the
        right level (either required, unique, optional) by default, this
        function checks to see if the query is for finding, which is more
        permissive than for moving. For moving, only the unique tags are
        allowed. 10 Jan 2011: adding in the 'strict' mode. according to the
        standard (at least, how I've read it), only tags for a particular
        level should be allowed in a particular query (ie, just series level
        tags in a series level query). However, it seems that dcm4chee doesn't
        share that interpretation. So, if 'inStrict' is false, then tags from
        the current level and all higher levels are now considered valid. So,
        if you're doing a non-strict series-level query, tags from the patient
        and study level can be passed along as well. 
        """
        return _gdcmswig.BaseRootQuery_ValidateQuery(self, inStrict)

    if _newclass:
        GetQueryLevelString = staticmethod(_gdcmswig.BaseRootQuery_GetQueryLevelString)
    else:
        GetQueryLevelString = _gdcmswig.BaseRootQuery_GetQueryLevelString
    if _newclass:
        GetQueryLevelFromString = staticmethod(_gdcmswig.BaseRootQuery_GetQueryLevelFromString)
    else:
        GetQueryLevelFromString = _gdcmswig.BaseRootQuery_GetQueryLevelFromString
    if _newclass:
        Construct = staticmethod(_gdcmswig.BaseRootQuery_Construct)
    else:
        Construct = _gdcmswig.BaseRootQuery_Construct

    def GetQueryLevelFromQueryRoot(self, roottype: 'gdcm::ERootType') -> "gdcm::EQueryLevel":
        """
        EQueryLevel
        gdcm::BaseRootQuery::GetQueryLevelFromQueryRoot(ERootType roottype) 
        """
        return _gdcmswig.BaseRootQuery_GetQueryLevelFromQueryRoot(self, roottype)

BaseRootQuery_swigregister = _gdcmswig.BaseRootQuery_swigregister
BaseRootQuery_swigregister(BaseRootQuery)

def BaseRootQuery_GetQueryLevelString(ql: 'gdcm::EQueryLevel') -> "char const *":
    return _gdcmswig.BaseRootQuery_GetQueryLevelString(ql)
BaseRootQuery_GetQueryLevelString = _gdcmswig.BaseRootQuery_GetQueryLevelString

def BaseRootQuery_GetQueryLevelFromString(str: 'char const *') -> "int":
    return _gdcmswig.BaseRootQuery_GetQueryLevelFromString(str)
BaseRootQuery_GetQueryLevelFromString = _gdcmswig.BaseRootQuery_GetQueryLevelFromString

def BaseRootQuery_Construct(inRootType: 'gdcm::ERootType', qlevel: 'gdcm::EQueryLevel') -> "gdcm::QueryBase *":
    return _gdcmswig.BaseRootQuery_Construct(inRootType, qlevel)
BaseRootQuery_Construct = _gdcmswig.BaseRootQuery_Construct

eLatin1 = _gdcmswig.eLatin1
eLatin2 = _gdcmswig.eLatin2
eLatin3 = _gdcmswig.eLatin3
eLatin4 = _gdcmswig.eLatin4
eCyrillic = _gdcmswig.eCyrillic
eArabic = _gdcmswig.eArabic
eGreek = _gdcmswig.eGreek
eHebrew = _gdcmswig.eHebrew
eLatin5 = _gdcmswig.eLatin5
eJapanese = _gdcmswig.eJapanese
eThai = _gdcmswig.eThai
eJapaneseKanjiMultibyte = _gdcmswig.eJapaneseKanjiMultibyte
eJapaneseSupplementaryKanjiMultibyte = _gdcmswig.eJapaneseSupplementaryKanjiMultibyte
eKoreanHangulHanjaMultibyte = _gdcmswig.eKoreanHangulHanjaMultibyte
eUTF8 = _gdcmswig.eUTF8
eGB18030 = _gdcmswig.eGB18030
class QueryFactory(_object):
    """


    QueryFactory.h.

    contains: a class to produce a query based off of user-entered
    information

    Essentially, this class is used to construct a query based off of user
    input (typically from the command line; if in code directly, the query
    itself could just be instantiated)

    In theory, could also be used as the interface to validate incoming
    datasets as belonging to a particular query style

    C++ includes: gdcmQueryFactory.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, QueryFactory, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, QueryFactory, name)
    __repr__ = _swig_repr
    if _newclass:
        ProduceQuery = staticmethod(_gdcmswig.QueryFactory_ProduceQuery)
    else:
        ProduceQuery = _gdcmswig.QueryFactory_ProduceQuery
    if _newclass:
        ProduceCharacterSetDataElement = staticmethod(_gdcmswig.QueryFactory_ProduceCharacterSetDataElement)
    else:
        ProduceCharacterSetDataElement = _gdcmswig.QueryFactory_ProduceCharacterSetDataElement
    if _newclass:
        GetCharacterFromCurrentLocale = staticmethod(_gdcmswig.QueryFactory_GetCharacterFromCurrentLocale)
    else:
        GetCharacterFromCurrentLocale = _gdcmswig.QueryFactory_GetCharacterFromCurrentLocale
    if _newclass:
        ListCharSets = staticmethod(_gdcmswig.QueryFactory_ListCharSets)
    else:
        ListCharSets = _gdcmswig.QueryFactory_ListCharSets

    def __init__(self):
        this = _gdcmswig.new_QueryFactory()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_QueryFactory
    __del__ = lambda self: None
QueryFactory_swigregister = _gdcmswig.QueryFactory_swigregister
QueryFactory_swigregister(QueryFactory)

def QueryFactory_ProduceQuery(*args) -> "gdcm::BaseRootQuery *":
    return _gdcmswig.QueryFactory_ProduceQuery(*args)
QueryFactory_ProduceQuery = _gdcmswig.QueryFactory_ProduceQuery

def QueryFactory_ProduceCharacterSetDataElement(inCharSetType: 'CharSetArrayType') -> "gdcm::DataElement":
    return _gdcmswig.QueryFactory_ProduceCharacterSetDataElement(inCharSetType)
QueryFactory_ProduceCharacterSetDataElement = _gdcmswig.QueryFactory_ProduceCharacterSetDataElement

def QueryFactory_GetCharacterFromCurrentLocale() -> "gdcm::ECharSet":
    return _gdcmswig.QueryFactory_GetCharacterFromCurrentLocale()
QueryFactory_GetCharacterFromCurrentLocale = _gdcmswig.QueryFactory_GetCharacterFromCurrentLocale

def QueryFactory_ListCharSets(os: 'std::ostream &') -> "void":
    return _gdcmswig.QueryFactory_ListCharSets(os)
QueryFactory_ListCharSets = _gdcmswig.QueryFactory_ListCharSets

class CharSetArrayType(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CharSetArrayType, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CharSetArrayType, name)
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _gdcmswig.CharSetArrayType_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _gdcmswig.CharSetArrayType___nonzero__(self)

    def __bool__(self) -> "bool":
        return _gdcmswig.CharSetArrayType___bool__(self)

    def __len__(self) -> "std::vector< enum gdcm::ECharSet >::size_type":
        return _gdcmswig.CharSetArrayType___len__(self)

    def __getslice__(self, i: 'std::vector< enum gdcm::ECharSet >::difference_type', j: 'std::vector< enum gdcm::ECharSet >::difference_type') -> "std::vector< gdcm::ECharSet,std::allocator< gdcm::ECharSet > > *":
        return _gdcmswig.CharSetArrayType___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _gdcmswig.CharSetArrayType___setslice__(self, *args)

    def __delslice__(self, i: 'std::vector< enum gdcm::ECharSet >::difference_type', j: 'std::vector< enum gdcm::ECharSet >::difference_type') -> "void":
        return _gdcmswig.CharSetArrayType___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _gdcmswig.CharSetArrayType___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< enum gdcm::ECharSet >::value_type const &":
        return _gdcmswig.CharSetArrayType___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _gdcmswig.CharSetArrayType___setitem__(self, *args)

    def pop(self) -> "std::vector< enum gdcm::ECharSet >::value_type":
        return _gdcmswig.CharSetArrayType_pop(self)

    def append(self, x: 'std::vector< enum gdcm::ECharSet >::value_type const &') -> "void":
        return _gdcmswig.CharSetArrayType_append(self, x)

    def empty(self) -> "bool":
        return _gdcmswig.CharSetArrayType_empty(self)

    def size(self) -> "std::vector< enum gdcm::ECharSet >::size_type":
        return _gdcmswig.CharSetArrayType_size(self)

    def swap(self, v: 'CharSetArrayType') -> "void":
        return _gdcmswig.CharSetArrayType_swap(self, v)

    def begin(self) -> "std::vector< enum gdcm::ECharSet >::iterator":
        return _gdcmswig.CharSetArrayType_begin(self)

    def end(self) -> "std::vector< enum gdcm::ECharSet >::iterator":
        return _gdcmswig.CharSetArrayType_end(self)

    def rbegin(self) -> "std::vector< enum gdcm::ECharSet >::reverse_iterator":
        return _gdcmswig.CharSetArrayType_rbegin(self)

    def rend(self) -> "std::vector< enum gdcm::ECharSet >::reverse_iterator":
        return _gdcmswig.CharSetArrayType_rend(self)

    def clear(self) -> "void":
        return _gdcmswig.CharSetArrayType_clear(self)

    def get_allocator(self) -> "std::vector< enum gdcm::ECharSet >::allocator_type":
        return _gdcmswig.CharSetArrayType_get_allocator(self)

    def pop_back(self) -> "void":
        return _gdcmswig.CharSetArrayType_pop_back(self)

    def erase(self, *args) -> "std::vector< enum gdcm::ECharSet >::iterator":
        return _gdcmswig.CharSetArrayType_erase(self, *args)

    def __init__(self, *args):
        this = _gdcmswig.new_CharSetArrayType(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def push_back(self, x: 'std::vector< enum gdcm::ECharSet >::value_type const &') -> "void":
        return _gdcmswig.CharSetArrayType_push_back(self, x)

    def front(self) -> "std::vector< enum gdcm::ECharSet >::value_type const &":
        return _gdcmswig.CharSetArrayType_front(self)

    def back(self) -> "std::vector< enum gdcm::ECharSet >::value_type const &":
        return _gdcmswig.CharSetArrayType_back(self)

    def assign(self, n: 'std::vector< enum gdcm::ECharSet >::size_type', x: 'std::vector< enum gdcm::ECharSet >::value_type const &') -> "void":
        return _gdcmswig.CharSetArrayType_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _gdcmswig.CharSetArrayType_resize(self, *args)

    def insert(self, *args) -> "void":
        return _gdcmswig.CharSetArrayType_insert(self, *args)

    def reserve(self, n: 'std::vector< enum gdcm::ECharSet >::size_type') -> "void":
        return _gdcmswig.CharSetArrayType_reserve(self, n)

    def capacity(self) -> "std::vector< enum gdcm::ECharSet >::size_type":
        return _gdcmswig.CharSetArrayType_capacity(self)
    __swig_destroy__ = _gdcmswig.delete_CharSetArrayType
    __del__ = lambda self: None
CharSetArrayType_swigregister = _gdcmswig.CharSetArrayType_swigregister
CharSetArrayType_swigregister(CharSetArrayType)

class CompositeNetworkFunctions(_object):
    """


    Composite Network Functions.

    These functions provide a generic API to the DICOM functions
    implemented in GDCM. Advanced users can use this code as a template
    for building their own versions of these functions (for instance, to
    provide progress bars or some other way of handling returned query
    information), but for most users, these functions should be sufficient
    to interface with a PACS to a local machine. Note that these functions
    are not contained within a static class or some other class-style
    interface, because multiple connections can be instantiated in the
    same program. The DICOM standard is much more function oriented rather
    than class oriented in this instance, so the design of this API
    reflects that functional approach. These functions implements the
    following SCU operations: C-ECHO SCU

    C-FIND SCU

    C-STORE SCU

    C-MOVE SCU (+internal C-STORE SCP)

    C++ includes: gdcmCompositeNetworkFunctions.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, CompositeNetworkFunctions, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, CompositeNetworkFunctions, name)
    __repr__ = _swig_repr
    if _newclass:
        CEcho = staticmethod(_gdcmswig.CompositeNetworkFunctions_CEcho)
    else:
        CEcho = _gdcmswig.CompositeNetworkFunctions_CEcho
    if _newclass:
        ConstructQuery = staticmethod(_gdcmswig.CompositeNetworkFunctions_ConstructQuery)
    else:
        ConstructQuery = _gdcmswig.CompositeNetworkFunctions_ConstructQuery
    if _newclass:
        CMove = staticmethod(_gdcmswig.CompositeNetworkFunctions_CMove)
    else:
        CMove = _gdcmswig.CompositeNetworkFunctions_CMove
    if _newclass:
        CFind = staticmethod(_gdcmswig.CompositeNetworkFunctions_CFind)
    else:
        CFind = _gdcmswig.CompositeNetworkFunctions_CFind
    if _newclass:
        CStore = staticmethod(_gdcmswig.CompositeNetworkFunctions_CStore)
    else:
        CStore = _gdcmswig.CompositeNetworkFunctions_CStore

    def __init__(self):
        this = _gdcmswig.new_CompositeNetworkFunctions()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_CompositeNetworkFunctions
    __del__ = lambda self: None
CompositeNetworkFunctions_swigregister = _gdcmswig.CompositeNetworkFunctions_swigregister
CompositeNetworkFunctions_swigregister(CompositeNetworkFunctions)

def CompositeNetworkFunctions_CEcho(remote: 'char const *', portno: 'uint16_t', aetitle: 'char const *'=None, call: 'char const *'=None) -> "bool":
    return _gdcmswig.CompositeNetworkFunctions_CEcho(remote, portno, aetitle, call)
CompositeNetworkFunctions_CEcho = _gdcmswig.CompositeNetworkFunctions_CEcho

def CompositeNetworkFunctions_ConstructQuery(*args) -> "gdcm::BaseRootQuery *":
    return _gdcmswig.CompositeNetworkFunctions_ConstructQuery(*args)
CompositeNetworkFunctions_ConstructQuery = _gdcmswig.CompositeNetworkFunctions_ConstructQuery

def CompositeNetworkFunctions_CMove(remote: 'char const *', portno: 'uint16_t', query: 'BaseRootQuery', portscp: 'uint16_t', aetitle: 'char const *'=None, call: 'char const *'=None, outputdir: 'char const *'=None) -> "bool":
    return _gdcmswig.CompositeNetworkFunctions_CMove(remote, portno, query, portscp, aetitle, call, outputdir)
CompositeNetworkFunctions_CMove = _gdcmswig.CompositeNetworkFunctions_CMove

def CompositeNetworkFunctions_CFind(remote: 'char const *', portno: 'uint16_t', query: 'BaseRootQuery', retDataSets: 'DataSetArrayType', aetitle: 'char const *'=None, call: 'char const *'=None) -> "bool":
    return _gdcmswig.CompositeNetworkFunctions_CFind(remote, portno, query, retDataSets, aetitle, call)
CompositeNetworkFunctions_CFind = _gdcmswig.CompositeNetworkFunctions_CFind

def CompositeNetworkFunctions_CStore(remote: 'char const *', portno: 'uint16_t', filenames: 'FilenamesType', aetitle: 'char const *'=None, call: 'char const *'=None) -> "bool":
    return _gdcmswig.CompositeNetworkFunctions_CStore(remote, portno, filenames, aetitle, call)
CompositeNetworkFunctions_CStore = _gdcmswig.CompositeNetworkFunctions_CStore

class PresentationContext(_object):
    """


    PresentationContext.

    See:  PresentationContextAC PresentationContextRQ

    C++ includes: gdcmPresentationContext.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresentationContext, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresentationContext, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        gdcm::PresentationContext::PresentationContext(UIDs::TSName asname,
        UIDs::TSName
        tsname=UIDs::ImplicitVRLittleEndianDefaultTransferSyntaxforDICOM)

        Initialize Presentation Context with AbstractSyntax set to asname and
        with a single TransferSyntax set to tsname (default to Implicit VR
        LittleEndian when not specified ). 
        """
        this = _gdcmswig.new_PresentationContext(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetAbstractSyntax(self, absyn: 'char const *') -> "void":
        """
        void gdcm::PresentationContext::SetAbstractSyntax(const char *absyn)

        """
        return _gdcmswig.PresentationContext_SetAbstractSyntax(self, absyn)


    def GetAbstractSyntax(self) -> "char const *":
        """const char* gdcm::PresentationContext::GetAbstractSyntax() const """
        return _gdcmswig.PresentationContext_GetAbstractSyntax(self)


    def AddTransferSyntax(self, tsstr: 'char const *') -> "void":
        """
        void gdcm::PresentationContext::AddTransferSyntax(const char *tsstr)

        """
        return _gdcmswig.PresentationContext_AddTransferSyntax(self, tsstr)


    def GetTransferSyntax(self, i: 'gdcm::PresentationContext::SizeType') -> "char const *":
        """
        const char* gdcm::PresentationContext::GetTransferSyntax(SizeType i)
        const 
        """
        return _gdcmswig.PresentationContext_GetTransferSyntax(self, i)


    def GetNumberOfTransferSyntaxes(self) -> "gdcm::PresentationContext::SizeType":
        """
        SizeType
        gdcm::PresentationContext::GetNumberOfTransferSyntaxes() const 
        """
        return _gdcmswig.PresentationContext_GetNumberOfTransferSyntaxes(self)


    def SetPresentationContextID(self, id: 'uint8_t') -> "void":
        """
        void
        gdcm::PresentationContext::SetPresentationContextID(uint8_t id) 
        """
        return _gdcmswig.PresentationContext_SetPresentationContextID(self, id)


    def GetPresentationContextID(self) -> "uint8_t":
        """
        uint8_t
        gdcm::PresentationContext::GetPresentationContextID() const 
        """
        return _gdcmswig.PresentationContext_GetPresentationContextID(self)


    def Print(self, os: 'std::ostream &') -> "void":
        """
        void
        gdcm::PresentationContext::Print(std::ostream &os) const 
        """
        return _gdcmswig.PresentationContext_Print(self, os)


    def __eq__(self, pc: 'PresentationContext') -> "bool":
        return _gdcmswig.PresentationContext___eq__(self, pc)
    __swig_destroy__ = _gdcmswig.delete_PresentationContext
    __del__ = lambda self: None
PresentationContext_swigregister = _gdcmswig.PresentationContext_swigregister
PresentationContext_swigregister(PresentationContext)

class PresentationContextGenerator(_object):
    """


    PresentationContextGenerator.

    This class is responsible for generating the proper
    PresentationContext that will be used in subsequent operation during a
    DICOM Query/Retrieve association. The step of the association is very
    sensible as special care need to be taken to explicitly define what
    instance are going to be send and how they are encoded.

    For example a PresentationContext will express that negotiation
    requires that CT Image Storage are send using JPEG Lossless, while US
    Image Storage are sent using RLE Transfer Syntax.

    Two very different API are exposed one which will always default to
    little endian transfer syntax see GenerateFromUID() This API is used
    for C-ECHO, C-FIND and C-MOVE (SCU). Another API:
    GenerateFromFilenames() is used for C-STORE (SCU) as it will loop over
    all filenames argument to detect the actual encoding. and therefore
    find the proper encoding to be used.

    Two modes are available. The default mode
    (SetMergeModeToAbstractSyntax) append PresentationContext (one
    AbstractSyntax and one TransferSyntax), as long a they are different.
    Eg MR Image Storage/JPEG2000 and MR Image Storage/JPEGLossless would
    be considered different. the other mode SetMergeModeToTransferSyntax
    merge any new TransferSyntax to the already existing
    PresentationContext in order to re-use the same AbstractSyntax.

    See:   PresentationContext

    C++ includes: gdcmPresentationContextGenerator.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, PresentationContextGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, PresentationContextGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::PresentationContextGenerator::PresentationContextGenerator() """
        this = _gdcmswig.new_PresentationContextGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def SetMergeModeToAbstractSyntax(self) -> "void":
        """
        void
        gdcm::PresentationContextGenerator::SetMergeModeToAbstractSyntax() 
        """
        return _gdcmswig.PresentationContextGenerator_SetMergeModeToAbstractSyntax(self)


    def SetMergeModeToTransferSyntax(self) -> "void":
        """
        void
        gdcm::PresentationContextGenerator::SetMergeModeToTransferSyntax() 
        """
        return _gdcmswig.PresentationContextGenerator_SetMergeModeToTransferSyntax(self)


    def GenerateFromUID(self, asname: 'gdcm::UIDs::TSName') -> "bool":
        """
        bool
        gdcm::PresentationContextGenerator::GenerateFromUID(UIDs::TSName
        asname)

        Generate the PresentationContext array from a UID (eg.
        VerificationSOPClass) 
        """
        return _gdcmswig.PresentationContextGenerator_GenerateFromUID(self, asname)


    def GenerateFromFilenames(self, files: 'FilenamesType') -> "bool":
        """
        bool
        gdcm::PresentationContextGenerator::GenerateFromFilenames(const
        Directory::FilenamesType &files)

        Generate the PresentationContext array from a File-Set. File specified
        needs to be valid DICOM files. Used for C-STORE operations 
        """
        return _gdcmswig.PresentationContextGenerator_GenerateFromFilenames(self, files)


    def AddFromFile(self, file: 'File') -> "bool":
        """
        bool gdcm::PresentationContextGenerator::AddFromFile(const File
        &file)

        Add a single PresentationContext from a single File. Call multiple
        times when dealing with multiple files. 
        """
        return _gdcmswig.PresentationContextGenerator_AddFromFile(self, file)


    def GetPresentationContexts(self) -> "gdcm::PresentationContextGenerator::PresentationContextArrayType const &":
        """
        PresentationContextArrayType const&
        gdcm::PresentationContextGenerator::GetPresentationContexts() 
        """
        return _gdcmswig.PresentationContextGenerator_GetPresentationContexts(self)


    def SetDefaultTransferSyntax(self, ts: 'TransferSyntax') -> "void":
        """
        void
        gdcm::PresentationContextGenerator::SetDefaultTransferSyntax(const
        TransferSyntax &ts)

        Not implemented for now. GDCM internally uses Implicit Little Endian.

        """
        return _gdcmswig.PresentationContextGenerator_SetDefaultTransferSyntax(self, ts)

    __swig_destroy__ = _gdcmswig.delete_PresentationContextGenerator
    __del__ = lambda self: None
PresentationContextGenerator_swigregister = _gdcmswig.PresentationContextGenerator_swigregister
PresentationContextGenerator_swigregister(PresentationContextGenerator)

class ServiceClassUser(Subject):
    """


    ServiceClassUser.

    C++ includes: gdcmServiceClassUser.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ServiceClassUser, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ServiceClassUser, name)
    __repr__ = _swig_repr

    def __init__(self):
        """
        gdcm::ServiceClassUser::ServiceClassUser()

        Construct a SCU with default: hostname = localhost

        port = 104 
        """
        this = _gdcmswig.new_ServiceClassUser()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ServiceClassUser
    __del__ = lambda self: None

    def SetHostname(self, hostname: 'char const *') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetHostname(const char *hostname)

        Set the name of the called hostname (hostname or IP address) 
        """
        return _gdcmswig.ServiceClassUser_SetHostname(self, hostname)


    def SetPort(self, port: 'uint16_t') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetPort(uint16_t port)

        Set port of remote host (called application) 
        """
        return _gdcmswig.ServiceClassUser_SetPort(self, port)


    def SetPortSCP(self, portscp: 'uint16_t') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetPortSCP(uint16_t portscp)

        Set the port for any incoming C-STORE-SCP operation (typically in a
        return of C-MOVE) 
        """
        return _gdcmswig.ServiceClassUser_SetPortSCP(self, portscp)


    def SetAETitle(self, aetitle: 'char const *') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetAETitle(const char *aetitle)

        set calling ae title 
        """
        return _gdcmswig.ServiceClassUser_SetAETitle(self, aetitle)


    def GetAETitle(self) -> "char const *":
        """
        const
        char* gdcm::ServiceClassUser::GetAETitle() const 
        """
        return _gdcmswig.ServiceClassUser_GetAETitle(self)


    def SetCalledAETitle(self, aetitle: 'char const *') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetCalledAETitle(const char *aetitle)

        set called ae title 
        """
        return _gdcmswig.ServiceClassUser_SetCalledAETitle(self, aetitle)


    def GetCalledAETitle(self) -> "char const *":
        """const char* gdcm::ServiceClassUser::GetCalledAETitle() const """
        return _gdcmswig.ServiceClassUser_GetCalledAETitle(self)


    def SetTimeout(self, t: 'double') -> "void":
        """
        void
        gdcm::ServiceClassUser::SetTimeout(double t)

        set/get Timeout 
        """
        return _gdcmswig.ServiceClassUser_SetTimeout(self, t)


    def GetTimeout(self) -> "double":
        """
        double
        gdcm::ServiceClassUser::GetTimeout() const 
        """
        return _gdcmswig.ServiceClassUser_GetTimeout(self)


    def InitializeConnection(self) -> "bool":
        """
        bool gdcm::ServiceClassUser::InitializeConnection()

        Will try to connect This will setup the actual timeout used during the
        whole connection time. Need to call SetTimeout first 
        """
        return _gdcmswig.ServiceClassUser_InitializeConnection(self)


    def SetPresentationContexts(self, pcs: 'PresentationContextArrayType') -> "void":
        """
        void gdcm::ServiceClassUser::SetPresentationContexts(std::vector<
        PresentationContext > const &pcs)

        Set the Presentation Context used for the Association. 
        """
        return _gdcmswig.ServiceClassUser_SetPresentationContexts(self, pcs)


    def IsPresentationContextAccepted(self, pc: 'PresentationContext') -> "bool":
        """
        bool
        gdcm::ServiceClassUser::IsPresentationContextAccepted(const
        PresentationContext &pc) const

        Return if the passed in presentation was accepted during association
        negotiation. 
        """
        return _gdcmswig.ServiceClassUser_IsPresentationContextAccepted(self, pc)


    def StartAssociation(self) -> "bool":
        """
        bool
        gdcm::ServiceClassUser::StartAssociation()

        Start the association. Need to call SetPresentationContexts before. 
        """
        return _gdcmswig.ServiceClassUser_StartAssociation(self)


    def StopAssociation(self) -> "bool":
        """
        bool
        gdcm::ServiceClassUser::StopAssociation()

        Stop the running association. 
        """
        return _gdcmswig.ServiceClassUser_StopAssociation(self)


    def SendEcho(self) -> "bool":
        """
        bool
        gdcm::ServiceClassUser::SendEcho()

        C-ECHO. 
        """
        return _gdcmswig.ServiceClassUser_SendEcho(self)


    def SendStore(self, *args) -> "bool":
        """
        bool
        gdcm::ServiceClassUser::SendStore(DataSet const &ds)

        Execute a C-STORE on a DataSet, the transfer syntax used will be
        Implicit. 
        """
        return _gdcmswig.ServiceClassUser_SendStore(self, *args)


    def SendFind(self, query: 'BaseRootQuery', retDatasets: 'DataSetArrayType') -> "bool":
        """
        bool
        gdcm::ServiceClassUser::SendFind(const BaseRootQuery *query,
        std::vector< DataSet > &retDatasets)

        C-FIND a query, return result are in retDatasets. 
        """
        return _gdcmswig.ServiceClassUser_SendFind(self, query, retDatasets)


    def SendMove(self, *args) -> "bool":
        """
        bool
        gdcm::ServiceClassUser::SendMove(const BaseRootQuery *query,
        std::vector< File > &retFile)

        Execute a C-MOVE, based on query, returned Files are stored in vector.

        """
        return _gdcmswig.ServiceClassUser_SendMove(self, *args)

    if _newclass:
        New = staticmethod(_gdcmswig.ServiceClassUser_New)
    else:
        New = _gdcmswig.ServiceClassUser_New
ServiceClassUser_swigregister = _gdcmswig.ServiceClassUser_swigregister
ServiceClassUser_swigregister(ServiceClassUser)

def ServiceClassUser_New() -> "gdcm::SmartPointer< gdcm::ServiceClassUser >":
    return _gdcmswig.ServiceClassUser_New()
ServiceClassUser_New = _gdcmswig.ServiceClassUser_New

class StreamImageReader(_object):
    """


    StreamImageReader.

    its role is to convert the DICOM DataSet into a Image representation
    via an ITK streaming (ie, multithreaded) interface Image is different
    from Pixmap has it has a position and a direction in Space. Currently,
    this class is thread safe in that it can read a single extent in a
    single thread. Multiple versions can be used for multiple
    extents/threads.

    See:   Image

    C++ includes: gdcmStreamImageReader.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StreamImageReader, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StreamImageReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::StreamImageReader::StreamImageReader() """
        this = _gdcmswig.new_StreamImageReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_StreamImageReader
    __del__ = lambda self: None

    def SetFileName(self, inFileName: 'char const *') -> "void":
        """
        void
        gdcm::StreamImageReader::SetFileName(const char *inFileName)

        One of either SetFileName or SetStream must be called prior to any
        other functions. These initialize an internal Reader class to be able
        to get non-pixel image information. 
        """
        return _gdcmswig.StreamImageReader_SetFileName(self, inFileName)


    def SetStream(self, inStream: 'std::istream &') -> "void":
        """
        void
        gdcm::StreamImageReader::SetStream(std::istream &inStream) 
        """
        return _gdcmswig.StreamImageReader_SetStream(self, inStream)


    def GetDimensionsValueForResolution(self, arg2: 'unsigned int') -> "std::vector< unsigned int,std::allocator< unsigned int > >":
        """
        std::vector<unsigned int>
        gdcm::StreamImageReader::GetDimensionsValueForResolution(unsigned int)

        """
        return _gdcmswig.StreamImageReader_GetDimensionsValueForResolution(self, arg2)


    def DefinePixelExtent(self, inXMin: 'uint16_t', inXMax: 'uint16_t', inYMin: 'uint16_t', inYMax: 'uint16_t', inZMin: 'uint16_t'=0, inZMax: 'uint16_t'=1) -> "void":
        """
        void gdcm::StreamImageReader::DefinePixelExtent(uint16_t inXMin,
        uint16_t inXMax, uint16_t inYMin, uint16_t inYMax, uint16_t inZMin=0,
        uint16_t inZMax=1)

        Defines an image extent for the Read function. DICOM states that an
        image can have no more than 2^16 pixels per edge (as of 2009) In this
        case, the pixel extents ignore the direction cosines entirely, and
        assumes that the origin of the image is at location 0,0 (regardless of
        the definition in space per the tags). So, if the first 100 pixels of
        the first row are to be read in, this function should be called with
        DefinePixelExtent(0, 100, 0, 1), regardless of pixel size or
        orientation. 
        """
        return _gdcmswig.StreamImageReader_DefinePixelExtent(self, inXMin, inXMax, inYMin, inYMax, inZMin, inZMax)


    def DefineProperBufferLength(self) -> "uint32_t":
        """
        uint32_t
        gdcm::StreamImageReader::DefineProperBufferLength() const

        Paying attention to the pixel format and so forth, define the proper
        buffer length for the user. The return amount is in bytes. Call this
        function to determine the size of the char* buffer that will need to
        be passed in to ReadImageSubregion(). If the return is 0, then that
        means that the pixel extent was not defined prior 
        """
        return _gdcmswig.StreamImageReader_DefineProperBufferLength(self)


    def Read(self, inReadBuffer: 'char *', inBufferLength: 'std::size_t const &') -> "bool":
        """
        bool
        gdcm::StreamImageReader::Read(char *inReadBuffer, const std::size_t
        &inBufferLength)

        Read the DICOM image. There are three reasons for failure: The extent
        is not set

        the conversion from char* to std::ostream (internally) fails

        the given buffer isn't large enough to accommodate the desired pixel
        extent. This method has been implemented to look similar to the
        metaimageio in itk MUST have an extent defined, or else Read will
        return false. If no particular extent is required, use ImageReader
        instead. 
        """
        return _gdcmswig.StreamImageReader_Read(self, inReadBuffer, inBufferLength)


    def CanReadImage(self) -> "bool":
        """
        bool
        gdcm::StreamImageReader::CanReadImage() const

        Only RAW images are currently readable by the stream reader. As more
        streaming codecs are added, then this function will be updated to
        reflect those changes. Calling this function prior to reading will
        ensure that only streamable files are streamed. Make sure to call
        ReadImageInformation prior to calling this function. 
        """
        return _gdcmswig.StreamImageReader_CanReadImage(self)


    def ReadImageInformation(self) -> "bool":
        """
        virtual bool gdcm::StreamImageReader::ReadImageInformation()

        Set the spacing and dimension information for the set filename.
        returns false if the file is not initialized or not an image, with the
        pixel (7fe0,0010) tag. 
        """
        return _gdcmswig.StreamImageReader_ReadImageInformation(self)


    def GetFile(self) -> "gdcm::File const &":
        """
        File const&
        gdcm::StreamImageReader::GetFile() const

        Returns the dataset read by ReadImageInformation Couple this with the
        ImageHelper to get statistics about the image, like pixel extent, to
        be able to initialize buffers for reading 
        """
        return _gdcmswig.StreamImageReader_GetFile(self)

StreamImageReader_swigregister = _gdcmswig.StreamImageReader_swigregister
StreamImageReader_swigregister(StreamImageReader)

class Region(_object):
    """


    Class for manipulation region.

    C++ includes: gdcmRegion.h 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Region, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Region, name)

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_Region
    __del__ = lambda self: None

    def Print(self, *args) -> "void":
        """
        virtual void
        gdcm::Region::Print(std::ostream &os=std::cout) const

        Print. 
        """
        return _gdcmswig.Region_Print(self, *args)


    def Empty(self) -> "bool":
        """
        virtual bool
        gdcm::Region::Empty() const =0

        return whether this domain is empty: 
        """
        return _gdcmswig.Region_Empty(self)


    def IsValid(self) -> "bool":
        """
        virtual bool
        gdcm::Region::IsValid() const =0

        return whether this is valid domain 
        """
        return _gdcmswig.Region_IsValid(self)


    def Area(self) -> "size_t":
        """
        virtual size_t
        gdcm::Region::Area() const =0

        compute the area 
        """
        return _gdcmswig.Region_Area(self)


    def Clone(self) -> "gdcm::Region *":
        """
        virtual Region*
        gdcm::Region::Clone() const =0 
        """
        return _gdcmswig.Region_Clone(self)


    def ComputeBoundingBox(self) -> "gdcm::BoxRegion":
        """
        virtual
        BoxRegion gdcm::Region::ComputeBoundingBox()=0

        Return the Axis-Aligned minimum bounding box for all regions. 
        """
        return _gdcmswig.Region_ComputeBoundingBox(self)


    def __str__(self) -> "char const *":
        return _gdcmswig.Region___str__(self)
Region_swigregister = _gdcmswig.Region_swigregister
Region_swigregister(Region)


def __lshift__(*args) -> "std::ostream &":
    return _gdcmswig.__lshift__(*args)
__lshift__ = _gdcmswig.__lshift__
class BoxRegion(Region):
    """


    Class for manipulation box region.

    This is a very simple implementation of the Region class. It only
    support 3D box type region. It assumes the 3D Box does not have a tilt
    Origin is as (0,0,0)

    C++ includes: gdcmBoxRegion.h 
    """

    __swig_setmethods__ = {}
    for _s in [Region]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, BoxRegion, name, value)
    __swig_getmethods__ = {}
    for _s in [Region]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, BoxRegion, name)
    __repr__ = _swig_repr
    __swig_destroy__ = _gdcmswig.delete_BoxRegion
    __del__ = lambda self: None

    def SetDomain(self, xmin: 'unsigned int', xmax: 'unsigned int', ymin: 'unsigned int', ymax: 'unsigned int', zmin: 'unsigned int', zmax: 'unsigned int') -> "void":
        """
        void
        gdcm::BoxRegion::SetDomain(unsigned int xmin, unsigned int xmax,
        unsigned int ymin, unsigned int ymax, unsigned int zmin, unsigned int
        zmax)

        Set domain. 
        """
        return _gdcmswig.BoxRegion_SetDomain(self, xmin, xmax, ymin, ymax, zmin, zmax)


    def GetXMin(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetXMin() const

        Get domain. 
        """
        return _gdcmswig.BoxRegion_GetXMin(self)


    def GetXMax(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetXMax() const 
        """
        return _gdcmswig.BoxRegion_GetXMax(self)


    def GetYMin(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetYMin() const 
        """
        return _gdcmswig.BoxRegion_GetYMin(self)


    def GetYMax(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetYMax() const 
        """
        return _gdcmswig.BoxRegion_GetYMax(self)


    def GetZMin(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetZMin() const 
        """
        return _gdcmswig.BoxRegion_GetZMin(self)


    def GetZMax(self) -> "unsigned int":
        """
        unsigned int
        gdcm::BoxRegion::GetZMax() const 
        """
        return _gdcmswig.BoxRegion_GetZMax(self)


    def Clone(self) -> "gdcm::Region *":
        """
        Region*
        gdcm::BoxRegion::Clone() const 
        """
        return _gdcmswig.BoxRegion_Clone(self)


    def Empty(self) -> "bool":
        """
        bool
        gdcm::BoxRegion::Empty() const

        return whether this domain is empty: 
        """
        return _gdcmswig.BoxRegion_Empty(self)


    def IsValid(self) -> "bool":
        """
        bool
        gdcm::BoxRegion::IsValid() const

        return whether this is valid domain 
        """
        return _gdcmswig.BoxRegion_IsValid(self)


    def Area(self) -> "size_t":
        """
        size_t
        gdcm::BoxRegion::Area() const

        compute the area 
        """
        return _gdcmswig.BoxRegion_Area(self)


    def ComputeBoundingBox(self) -> "gdcm::BoxRegion":
        """
        BoxRegion
        gdcm::BoxRegion::ComputeBoundingBox()

        Return the Axis-Aligned minimum bounding box for all regions. 
        """
        return _gdcmswig.BoxRegion_ComputeBoundingBox(self)


    def Print(self, *args) -> "void":
        """
        void
        gdcm::BoxRegion::Print(std::ostream &os=std::cout) const

        Print. 
        """
        return _gdcmswig.BoxRegion_Print(self, *args)

    if _newclass:
        BoundingBox = staticmethod(_gdcmswig.BoxRegion_BoundingBox)
    else:
        BoundingBox = _gdcmswig.BoxRegion_BoundingBox

    def __init__(self, *args):
        """
        gdcm::BoxRegion::BoxRegion(const BoxRegion &)

        copy/cstor and al. 
        """
        this = _gdcmswig.new_BoxRegion(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def __str__(self) -> "char const *":
        return _gdcmswig.BoxRegion___str__(self)
BoxRegion_swigregister = _gdcmswig.BoxRegion_swigregister
BoxRegion_swigregister(BoxRegion)

def BoxRegion_BoundingBox(b1: 'BoxRegion', b2: 'BoxRegion') -> "gdcm::BoxRegion":
    return _gdcmswig.BoxRegion_BoundingBox(b1, b2)
BoxRegion_BoundingBox = _gdcmswig.BoxRegion_BoundingBox

class ImageRegionReader(ImageReader):
    """


    ImageRegionReader.

    This class is able to read a region from a DICOM file containing an
    image. This implementation requires that the information stored in the
    DICOM header are consistent with what is in the encapsulated Pixel
    Data. This is technically not required by DICOM standard, which makes
    this implementation illegal with regards to the famous JPEG
    note:http://dicom.nema.org/medical/dicom/current/output/chtml/part05/sect_8.2.html
    #para_4bcb841e-c6bf-4e26-82a5-3fad3c942da0 See:   ImageReader

    C++ includes: gdcmImageRegionReader.h 
    """

    __swig_setmethods__ = {}
    for _s in [ImageReader]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, ImageRegionReader, name, value)
    __swig_getmethods__ = {}
    for _s in [ImageReader]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, ImageRegionReader, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::ImageRegionReader::ImageRegionReader() """
        this = _gdcmswig.new_ImageRegionReader()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_ImageRegionReader
    __del__ = lambda self: None

    def SetRegion(self, region: 'Region') -> "void":
        """
        void
        gdcm::ImageRegionReader::SetRegion(Region const &region)

        Set/Get Region to be read. 
        """
        return _gdcmswig.ImageRegionReader_SetRegion(self, region)


    def GetRegion(self) -> "gdcm::Region const &":
        """
        Region
        const& gdcm::ImageRegionReader::GetRegion() const 
        """
        return _gdcmswig.ImageRegionReader_GetRegion(self)


    def ComputeBufferLength(self) -> "size_t":
        """
        size_t gdcm::ImageRegionReader::ComputeBufferLength() const

        Explicit call which will compute the minimal buffer length that can
        hold the whole uncompressed image as defined by Region region. 0 upon
        error 
        """
        return _gdcmswig.ImageRegionReader_ComputeBufferLength(self)


    def ReadInformation(self) -> "bool":
        """
        bool
        gdcm::ImageRegionReader::ReadInformation()

        Read meta information (not Pixel Data) from the DICOM file. false upon
        error 
        """
        return _gdcmswig.ImageRegionReader_ReadInformation(self)


    def ReadIntoBuffer(self, inreadbuffer: 'char *', buflen: 'size_t') -> "bool":
        """
        bool
        gdcm::ImageRegionReader::ReadIntoBuffer(char *inreadbuffer, size_t
        buflen)

        Read into buffer: false upon error 
        """
        return _gdcmswig.ImageRegionReader_ReadIntoBuffer(self, inreadbuffer, buflen)

ImageRegionReader_swigregister = _gdcmswig.ImageRegionReader_swigregister
ImageRegionReader_swigregister(ImageRegionReader)

class JSON(_object):
    """C++ includes: gdcmJSON.h """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, JSON, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, JSON, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::JSON::JSON() """
        this = _gdcmswig.new_JSON()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_JSON
    __del__ = lambda self: None

    def GetPrettyPrint(self) -> "bool":
        """
        bool
        gdcm::JSON::GetPrettyPrint() const 
        """
        return _gdcmswig.JSON_GetPrettyPrint(self)


    def SetPrettyPrint(self, onoff: 'bool') -> "void":
        """
        void
        gdcm::JSON::SetPrettyPrint(bool onoff) 
        """
        return _gdcmswig.JSON_SetPrettyPrint(self, onoff)


    def PrettyPrintOn(self) -> "void":
        """
        void
        gdcm::JSON::PrettyPrintOn() 
        """
        return _gdcmswig.JSON_PrettyPrintOn(self)


    def PrettyPrintOff(self) -> "void":
        """
        void
        gdcm::JSON::PrettyPrintOff() 
        """
        return _gdcmswig.JSON_PrettyPrintOff(self)


    def Code(self, arg2: 'DataSet', os: 'std::ostream &') -> "bool":
        """
        bool
        gdcm::JSON::Code(DataSet const &in, std::ostream &os) 
        """
        return _gdcmswig.JSON_Code(self, arg2, os)


    def Decode(self, arg2: 'std::istream &', out: 'DataSet') -> "bool":
        """
        bool
        gdcm::JSON::Decode(std::istream &is, DataSet &out) 
        """
        return _gdcmswig.JSON_Decode(self, arg2, out)

JSON_swigregister = _gdcmswig.JSON_swigregister
JSON_swigregister(JSON)

class FileDecompressLookupTable(Subject):
    """


    FileDecompressLookupTable class.

    It decompress the segmented LUT into linearized one (only
    PALETTE_COLOR images) Output will be a PhotometricInterpretation=RGB
    image

    C++ includes: gdcmFileDecompressLookupTable.h 
    """

    __swig_setmethods__ = {}
    for _s in [Subject]:
        __swig_setmethods__.update(getattr(_s, '__swig_setmethods__', {}))
    __setattr__ = lambda self, name, value: _swig_setattr(self, FileDecompressLookupTable, name, value)
    __swig_getmethods__ = {}
    for _s in [Subject]:
        __swig_getmethods__.update(getattr(_s, '__swig_getmethods__', {}))
    __getattr__ = lambda self, name: _swig_getattr(self, FileDecompressLookupTable, name)
    __repr__ = _swig_repr

    def __init__(self):
        """gdcm::FileDecompressLookupTable::FileDecompressLookupTable() """
        this = _gdcmswig.new_FileDecompressLookupTable()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_FileDecompressLookupTable
    __del__ = lambda self: None

    def Change(self) -> "bool":
        """
        bool
        gdcm::FileDecompressLookupTable::Change()

        Decompress. 
        """
        return _gdcmswig.FileDecompressLookupTable_Change(self)


    def SetFile(self, f: 'File') -> "void":
        """
        void
        gdcm::FileDecompressLookupTable::SetFile(const File &f)

        Set/Get File. 
        """
        return _gdcmswig.FileDecompressLookupTable_SetFile(self, f)


    def GetFile(self) -> "gdcm::File &":
        """File& gdcm::FileDecompressLookupTable::GetFile() """
        return _gdcmswig.FileDecompressLookupTable_GetFile(self)


    def GetPixmap(self, *args) -> "gdcm::Pixmap &":
        """Pixmap& gdcm::FileDecompressLookupTable::GetPixmap() """
        return _gdcmswig.FileDecompressLookupTable_GetPixmap(self, *args)


    def SetPixmap(self, img: 'Pixmap') -> "void":
        """void gdcm::FileDecompressLookupTable::SetPixmap(Pixmap const &img) """
        return _gdcmswig.FileDecompressLookupTable_SetPixmap(self, img)

FileDecompressLookupTable_swigregister = _gdcmswig.FileDecompressLookupTable_swigregister
FileDecompressLookupTable_swigregister(FileDecompressLookupTable)

class EmptyMaskGenerator(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, EmptyMaskGenerator, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, EmptyMaskGenerator, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _gdcmswig.new_EmptyMaskGenerator()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _gdcmswig.delete_EmptyMaskGenerator
    __del__ = lambda self: None
    UseOriginalSOPClassUID = _gdcmswig.EmptyMaskGenerator_UseOriginalSOPClassUID
    UseGrayscaleSecondaryImageStorage = _gdcmswig.EmptyMaskGenerator_UseGrayscaleSecondaryImageStorage

    def SetSOPClassUIDMode(self, mode: 'gdcm::EmptyMaskGenerator::SOPClassUIDMode') -> "void":
        return _gdcmswig.EmptyMaskGenerator_SetSOPClassUIDMode(self, mode)

    def SetInputDirectory(self, dirname: 'char const *') -> "void":
        return _gdcmswig.EmptyMaskGenerator_SetInputDirectory(self, dirname)

    def SetOutputDirectory(self, dirname: 'char const *') -> "void":
        return _gdcmswig.EmptyMaskGenerator_SetOutputDirectory(self, dirname)

    def Execute(self) -> "bool":
        return _gdcmswig.EmptyMaskGenerator_Execute(self)
EmptyMaskGenerator_swigregister = _gdcmswig.EmptyMaskGenerator_swigregister
EmptyMaskGenerator_swigregister(EmptyMaskGenerator)

# This file is compatible with both classic and new-style classes.


