<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>grib2io API documentation</title>
<meta name="description" content="Introduction
â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>grib2io</code></h1>
</header>
<section id="section-intro">
<h1 id="introduction">Introduction</h1>
<p>grib2io is a Python package that provides an interface to the NCEP GRIB2 C (g2c) library for the purpose
of reading and writing GRIB2 Messages.
WMO GRIdded Binary, Edition 2 (GRIB2) files store 2-D meteorological
data. A physical file can contain one or more GRIB2 messages.
File IO is handled in Python returning
a binary string of the GRIB2 message which is then passed to the g2c library for decoding or GRIB2 metadata
and unpacking of data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from ._grib2io import *
from ._grib2io import __doc__,__pdoc__

__all__ = [&#39;open&#39;,&#39;Grib2Message&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="grib2io.tables" href="tables/index.html">grib2io.tables</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="grib2io.Grib2Message"><code class="flex name class">
<span>class <span class="ident">Grib2Message</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class Constructor</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>msg : bytes</code></strong></p>
<p>Binary string representing the GRIB2 Message read from file.</p>
<p><strong><code>ref : grib2io.open, optional</code></strong></p>
<p>Holds the reference to the where this GRIB2 message originated
from (i.e. the input file). This allow for interaction with the
instance of <code><a title="grib2io.open" href="#grib2io.open">open</a></code>.</p>
<p><strong><code>num : int, optional</code></strong></p>
<p>Set to the GRIB2 Message number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Grib2Message:
    __pdoc__[&#39;grib2io.Grib2Message.__init__&#39;] = True
    def __init__(self, msg, ref=None, num=-1):
        &#34;&#34;&#34;
        Class Constructor

        Parameters
        ----------

        **`msg : bytes`**

        Binary string representing the GRIB2 Message read from file.

        **`ref : grib2io.open, optional`**

        Holds the reference to the where this GRIB2 message originated
        from (i.e. the input file). This allow for interaction with the
        instance of `grib2io.open`.

        **`num : int, optional`**

        Set to the GRIB2 Message number.
        &#34;&#34;&#34;
        self._msg = msg
        self._pos = 0
        self._ref = ref
        self._datapos = 0
        self._msgnum = num
        
        # Section 0, Indicator Section
        self.indicatorSection = []
        self.indicatorSection.append(struct.unpack(&#39;&gt;4s&#39;,self._msg[0:4])[0])
        self.indicatorSection.append(struct.unpack(&#39;&gt;H&#39;,self._msg[4:6])[0])
        self.indicatorSection.append(self._msg[6])
        self.indicatorSection.append(self._msg[7])
        self.indicatorSection.append(struct.unpack(&#39;&gt;Q&#39;,self._msg[8:16])[0])
        self.discipline = tables.get_value_from_table(self.indicatorSection[2],&#39;0.0&#39;)
        self._pos = 16
        
        # Section 1, Indentification Section.
        self.identificationSection,self._pos = g2clib.unpack1(self._msg,self._pos,np.empty)
        self.identificationSection = self.identificationSection.tolist()
        self.originatingCenter = tables.get_value_from_table(self.identificationSection[0],&#39;originating_centers&#39;)
        self.originatingSubCenter = tables.get_value_from_table(self.identificationSection[1],&#39;originating_subcenters&#39;)
        self.masterTableInfo = tables.get_value_from_table(self.identificationSection[2],&#39;1.0&#39;)
        self.localTableInfo = tables.get_value_from_table(self.identificationSection[3],&#39;1.1&#39;)
        self.significanceOfReferenceTime = tables.get_value_from_table(self.identificationSection[4],&#39;1.2&#39;)
        self.year = self.identificationSection[5]
        self.month = self.identificationSection[6]
        self.day = self.identificationSection[7]
        self.hour = self.identificationSection[8]
        self.minute = self.identificationSection[9]
        self.second = self.identificationSection[10]
        self.intreferenceDate = (self.year*1000000)+(self.month*10000)+\
                                (self.day*100)+self.hour
        self.dtReferenceDate = datetime.datetime(self.year,self.month,self.day,
                                                 hour=self.hour,minute=self.minute,
                                                 second=self.second)
        self.productionStatus = tables.get_value_from_table(self.identificationSection[11],&#39;1.3&#39;)
        self.typeOfData = tables.get_value_from_table(self.identificationSection[12],&#39;1.4&#39;)

        # After Section 1, perform rest of GRIB2 Decoding inside while loop
        # to account for sub-messages.
        while True:
            if self._msg[self._pos:self._pos+4].decode(&#39;ascii&#39;,&#39;ignore&#39;) == &#39;7777&#39;: break

            # Read the length and section number.
            sectlen = struct.unpack(&#39;&gt;i&#39;,self._msg[self._pos:self._pos+4])[0]
            sectnum = struct.unpack(&#39;&gt;B&#39;,self._msg[self._pos+4:self._pos+5])[0]

            # Handle submessage accordingly.
            if self._ref._index[&#39;isSubmessage&#39;][num]:
                if sectnum == self._ref._index[&#39;submessageBeginSection&#39;][self._msgnum]:
                    self._pos = self._ref._index[&#39;submessageOffset&#39;][self._msgnum]

            # Section 2, Local Use Section.
            self.localUseSection = None
            if sectnum == 2:
                _lus = self._msg[self._pos+5:self._pos+sectlen]
                self._pos += sectlen
                self.localUseSection = _lus
            # Section 3, Grid Definition Section.
            elif sectnum == 3:
                _gds,_gdtn,_deflist,self._pos = g2clib.unpack3(self._msg,self._pos,np.empty)
                self.gridDefinitionInfo = _gds.tolist()
                self.gridDefinitionTemplateNumber = int(_gds[4])
                self.gridDefinitionTemplate = _gdtn.tolist()
                self.defList = _deflist.tolist()
                self.gridDefinitionTemplateNumberInfo = tables.get_value_from_table(self.gridDefinitionTemplateNumber,&#39;3.1&#39;)
            # Section 4, Product Definition Section.
            elif sectnum == 4:
                _pdt,_pdtn,_coordlst,self._pos = g2clib.unpack4(self._msg,self._pos,np.empty)
                self.productDefinitionTemplate = _pdt.tolist()
                self.productDefinitionTemplateNumber = int(_pdtn)
                self.coordinateList = _coordlst.tolist()
            # Section 5, Data Representation Section.
            elif sectnum == 5:
                _drt,_drtn,_npts,self._pos = g2clib.unpack5(self._msg,self._pos,np.empty)
                self.dataRepresentationTemplate = _drt.tolist()
                self.dataRepresentationTemplateNumber = int(_drtn)
                self.numberOfDataPoints = _npts
            # Section 6, Bitmap Section.
            elif sectnum == 6:
                _bmap,_bmapflag = g2clib.unpack6(self._msg,self.gridDefinitionInfo[1],self._pos,np.empty)
                self.bitMapFlag = _bmapflag
                if self.bitMapFlag == 0:
                    self.bitMap = _bmap
                elif self.bitMapFlag == 254: 
                    # Value of 254 says to use a previous bitmap in the file.
                    self.bitMapFlag = 0
                    self.bitMap = self._ref._index[&#39;bitMap&#39;][self._msgnum]
                self._pos += sectlen # IMPORTANT: This is here because g2clib.unpack6() does not return updated position.
            # Section 7, Data Section (data unpacked when data() method is invoked).
            elif sectnum == 7:
                self._datapos = self._pos
                self._pos += sectlen # REMOVE THIS WHEN UNPACKING DATA IS IMPLEMENTED
            else:
                errmsg = &#39;Unknown section number = %i&#39; % sectnum
                raise ValueError(errmsg) 

        # Section 3 -- Grid Definition
        reggrid = self.gridDefinitionInfo[2] == 0 # self.gridDefinitionInfo[2]=0 means regular 2-d grid
        if self.gridDefinitionTemplateNumber in [50,51,52,1200]:
            earthparams = None
        else:
            earthparams = tables.earth_params[str(self.gridDefinitionTemplate[0])]
        if earthparams[&#39;shape&#39;] == &#39;spherical&#39;:
            if earthparams[&#39;radius&#39;] is None:
                self.earthRadius = self.gridDefinitionTemplate[2]/(10.**self.gridDefinitionTemplate[1])
            else:
                self.earthRadius = earthparams[&#39;radius&#39;]
                self.earthMajorAxis = None
                self.earthMinorAxis = None
        elif earthparams[&#39;shape&#39;] == &#39;oblateSpheroid&#39;:
            if earthparams[&#39;radius&#39;] is None and earthparams[&#39;major_axis&#39;] is None and earthparams[&#39;minor_axis&#39;] is None:
                self.earthRadius = self.gridDefinitionTemplate[2]/(10.**self.gridDefinitionTemplate[1])
                self.earthMajorAxis = self.gridDefinitionTemplate[4]/(10.**self.gridDefinitionTemplate[3])
                self.earthMinorAxis = self.gridDefinitionTemplate[6]/(10.**self.gridDefinitionTemplate[5])
            else:
                self.earthRadius = earthparams[&#39;radius&#39;]
                self.earthMajorAxis = earthparams[&#39;major_axis&#39;]
                self.earthMinorAxis = earthparams[&#39;minor_axis&#39;]
        if reggrid and self.gridDefinitionTemplateNumber not in [50,51,52,53,100,120,1000,1200]:
            self.nx = self.gridDefinitionTemplate[7]
            self.ny = self.gridDefinitionTemplate[8]
        if not reggrid and self.gridDefinitionTemplateNumber == 40: # &#39;reduced&#39; gaussian grid.
            self.ny = self.gridDefinitionTemplate[8]
        if self.gridDefinitionTemplateNumber in [0,1,203,205,32768,32769]: # regular or rotated lat/lon grid
            scalefact = float(self.gridDefinitionTemplate[9])
            divisor = float(self.gridDefinitionTemplate[10])
            if scalefact == 0: scalefact = 1.
            if divisor &lt;= 0: divisor = 1.e6
            self.latitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[11]/divisor
            self.longitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[12]/divisor
            self.latitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[14]/divisor
            self.longitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[15]/divisor
            self.gridlengthXDirection = scalefact*self.gridDefinitionTemplate[16]/divisor
            self.gridlengthYDirection = scalefact*self.gridDefinitionTemplate[17]/divisor
            if self.latitudeFirstGridpoint &gt; self.latitudeLastGridpoint:
                self.gridlengthYDirection = -self.gridlengthYDirection
            if self.longitudeFirstGridpoint &gt; self.longitudeLastGridpoint:
                self.gridlengthXDirection = -self.gridlengthXDirection
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]
            if self.gridDefinitionTemplateNumber == 1:
                self.latitudeSouthernPole = scalefact*self.gridDefinitionTemplate[19]/divisor
                self.longitudeSouthernPole = scalefact*self.gridDefinitionTemplate[20]/divisor
                self.anglePoleRotation = self.gridDefinitionTemplate[21]
        elif self.gridDefinitionTemplateNumber == 10: # mercator
            self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
            self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
            self.latitudeLastGridpoint = self.gridDefinitionTemplate[13]/1.e6
            self.longitudeLastGridpoint = self.gridDefinitionTemplate[14]/1.e6
            self.gridlengthXDirection = self.gridDefinitionTemplate[17]/1.e3
            self.gridlengthYDirection= self.gridDefinitionTemplate[18]/1.e3
            self.proj4_lat_ts = self.gridDefinitionTemplate[12]/1.e6
            self.proj4_lon_0 = 0.5*(self.longitudeFirstGridpoint+self.longitudeLastGridpoint)
            self.proj4_proj = &#39;merc&#39;
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[15],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 20: # stereographic
            projflag = _int2bin(self.gridDefinitionTemplate[16],output=list)[0]
            self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
            self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
            self.proj4_lat_ts = self.gridDefinitionTemplate[12]/1.e6
            if projflag == 0:
                self.proj4_lat_0 = 90
            elif projflag == 1:
                self.proj4_lat_0 = -90
            else:
                raise ValueError(&#39;Invalid projection center flag = %s&#39;%projflag)
            self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
            self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
            self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
            self.proj4_proj = &#39;stere&#39;
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 30: # lambert conformal
            self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
            self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
            self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
            self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
            self.proj4_lat_1 = self.gridDefinitionTemplate[18]/1.e6
            self.proj4_lat_2 = self.gridDefinitionTemplate[19]/1.e6
            self.proj4_lat_0 = self.gridDefinitionTemplate[12]/1.e6
            self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
            self.proj4_proj = &#39;lcc&#39;
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 31: # albers equal area.
            self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
            self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
            self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
            self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
            self.proj4_lat_1 = self.gridDefinitionTemplate[18]/1.e6
            self.proj4_lat_2 = self.gridDefinitionTemplate[19]/1.e6
            self.proj4_lat_0 = self.gridDefinitionTemplate[12]/1.e6
            self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
            self.proj4_proj = &#39;aea&#39;
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 40 or self.gridDefinitionTemplateNumber == 41: # gaussian grid.
            scalefact = float(self.gridDefinitionTemplate[9])
            divisor = float(self.gridDefinitionTemplate[10])
            if scalefact == 0: scalefact = 1.
            if divisor &lt;= 0: divisor = 1.e6
            self.pointsBetweenPoleAndEquator = self.gridDefinitionTemplate[17]
            self.latitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[11]/divisor
            self.longitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[12]/divisor
            self.latitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[14]/divisor
            self.longitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[15]/divisor
            if reggrid:
                self.gridlengthXDirection = scalefact*self.gridDefinitionTemplate[16]/divisor
                if self.longitudeFirstGridpoint &gt; self.longitudeLastGridpoint:
                    self.gridlengthXDirection = -self.gridlengthXDirection
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]
            if self.gridDefinitionTemplateNumber == 41:
                self.latitudeSouthernPole = scalefact*self.gridDefinitionTemplate[19]/divisor
                self.longitudeSouthernPole = scalefact*self.gridDefinitionTemplate[20]/divisor
                self.anglePoleRotation = self.gridDefinitionTemplate[21]
        elif self.gridDefinitionTemplateNumber == 50: # spectral coefficients.
            self.spectralFunctionParameters = (self.gridDefinitionTemplate[0],self.gridDefinitionTemplate[1],self.gridDefinitionTemplate[2])
            self.scanModeFlags = [None,None,None,None] # doesn&#39;t apply
        elif self.gridDefinitionTemplateNumber == 90: # near-sided vertical perspective satellite projection
            self.proj4_lat_0 = self.gridDefinitionTemplate[9]/1.e6
            self.proj4_lon_0 = self.gridDefinitionTemplate[10]/1.e6
            self.proj4_h = self.earthMajorAxis * (self.gridDefinitionTemplate[18]/1.e6)
            dx = self.gridDefinitionTemplate[12]
            dy = self.gridDefinitionTemplate[13]
            # if lat_0 is equator, it&#39;s a geostationary view.
            if self.proj4_lat_0 == 0.: # if lat_0 is equator, it&#39;s a
                self.proj4_proj = &#39;geos&#39;
            # general case of &#39;near-side perspective projection&#39; (untested)
            else:
                self.proj4_proj = &#39;nsper&#39;
                msg = &#39;only geostationary perspective is supported. lat/lon values returned by grid method may be incorrect.&#39;
                warnings.warn(msg)
            # latitude of horizon on central meridian
            lonmax = 90.-(180./np.pi)*np.arcsin(self.earthMajorAxis/self.proj4_h)
            # longitude of horizon on equator
            latmax = 90.-(180./np.pi)*np.arcsin(self.earthMinorAxis/self.proj4_h)
            # truncate to nearest thousandth of a degree (to make sure
            # they aren&#39;t slightly over the horizon)
            latmax = int(1000*latmax)/1000.
            lonmax = int(1000*lonmax)/1000.
            # h is measured from surface of earth at equator.
            self.proj4_h = self.proj4_h - self.earthMajorAxis
            # width and height of visible projection
            P = pyproj.Proj(proj=self.proj4_proj,\
                            a=self.earthMajorAxis,b=self.earthMinorAxis,\
                            lat_0=0,lon_0=0,h=self.proj4_h)
            x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)
            width = 2*x2; height = 2*y1
            self.gridlengthXDirection = width/dx
            self.gridlengthYDirection = height/dy
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[16],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 110: # azimuthal equidistant.
            self.proj4_lat_0 = self.gridDefinitionTemplate[9]/1.e6
            self.proj4_lon_0 = self.gridDefinitionTemplate[10]/1.e6
            self.gridlengthXDirection = self.gridDefinitionTemplate[12]/1000.
            self.gridlengthYDirection = self.gridDefinitionTemplate[13]/1000.
            self.proj4_proj = &#39;aeqd&#39;
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[15],output=list)[0:4]
        elif self.gridDefinitionTemplateNumber == 204: # curvilinear orthogonal
            self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]

        # Missing value.
        #if self.dataRepresentationTemplateNumber in [2,3] and self.dataRepresentationTemplate[6] != 0:
        #    self.missingValue = _getieeeint(self.dataRepresentationTemplate[7])
        #    if self.dataRepresentationTemplate[6] == 2:
        #        self.missingValue2 = _getieeeint(self.dataRepresentationTemplate[8])

        # Section 4 -- Product Definition
        _varinfo = tables.get_varname_from_table(self.indicatorSection[2],
                   self.productDefinitionTemplate[0],
                   self.productDefinitionTemplate[1])
        self.varDescription = _varinfo[0]
        self.units = _varinfo[1]
        self.varName = _varinfo[2]
        self.generatingProcess = tables.get_value_from_table(self.productDefinitionTemplate[4],&#39;generating_process&#39;)
        self.unitOfTimeRange = tables.get_value_from_table(self.productDefinitionTemplate[7],&#39;4.4&#39;)
        self.leadTime = self.productDefinitionTemplate[8]
        _vals = tables.get_value_from_table(self.productDefinitionTemplate[9],&#39;4.5&#39;)
        self.typeOfFirstFixedSurface = _vals[0]
        self.unitOfFirstFixedSurface = _vals[1]
        self.valueOfFristFixedSurface = self.productDefinitionTemplate[11]/(10.**self.productDefinitionTemplate[10])
        _vals = tables.get_value_from_table(self.productDefinitionTemplate[12],&#39;4.5&#39;)
        self.typeOfSecondFixedSurface = None if _vals[0] == &#39;Missing&#39; else _vals[0]
        self.unitOfSecondFixedSurface = None if _vals[1] == &#39;unknown&#39; else _vals[1]
        self.valueOfSecondFixedSurface = None if self.typeOfSecondFixedSurface is None else \
                                         self.productDefinitionTemplate[14]/(10.**self.productDefinitionTemplate[13])
        if self.productDefinitionTemplateNumber == 1:
            self.typeOfEnsembleForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.6&#39;)
            self.perturbationNumber = self.productDefinitionTemplate[16]
            self.numberOfEnsembleForecasts = self.productDefinitionTemplate[17]
        elif self.productDefinitionTemplateNumber == 2:
            self.typeOfDerivedForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.7&#39;)
            self.numberOfEnsembleForecasts = self.productDefinitionTemplate[16]
        elif self.productDefinitionTemplateNumber == 5:
            self.forecastProbabilityNumber = self.productDefinitionTemplate[15]
            self.totalNumberOfForecastProbabilities = self.productDefinitionTemplate[16]
            self.typeOfProbability = tables.get_value_from_table(self.productDefinitionTemplate[16],&#39;4.9&#39;)
            self.thresholdLowerLimit = self.productDefinitionTemplate[18]/(10.**self.productDefinitionTemplate[17])
            self.thresholdUpperLimit = self.productDefinitionTemplate[20]/(10.**self.productDefinitionTemplate[19])
        elif self.productDefinitionTemplateNumber == 6:
            self.percentileValue = self.productDefinitionTemplate[15]
        elif self.productDefinitionTemplateNumber == 8:
            self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[15]
            self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[16]
            self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[17]
            self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[18]
            self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[19]
            self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[20]
            self.numberOfTimeRanges = self.productDefinitionTemplate[21]
            self.numberOfMissingValues = self.productDefinitionTemplate[22]
            self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[23],&#39;4.10&#39;)
            self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[24],&#39;4.11&#39;)
            self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.4&#39;)
            self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[26]
            self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.4&#39;)
            self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[28]
        elif self.productDefinitionTemplateNumber == 9:
            self.forecastProbabilityNumber = self.productDefinitionTemplate[15]
            self.totalNumberOfForecastProbabilities = self.productDefinitionTemplate[16]
            self.typeOfProbability = tables.get_value_from_table(self.productDefinitionTemplate[16],&#39;4.9&#39;)
            self.thresholdLowerLimit = self.productDefinitionTemplate[18]/(10.**self.productDefinitionTemplate[17])
            self.thresholdUpperLimit = self.productDefinitionTemplate[20]/(10.**self.productDefinitionTemplate[19])
            self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[21]
            self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[22]
            self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[23]
            self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[24]
            self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[25]
            self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[26]
            self.numberOfTimeRanges = self.productDefinitionTemplate[27]
            self.numberOfMissingValues = self.productDefinitionTemplate[28]
            self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[29],&#39;4.10&#39;)
            self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[30],&#39;4.11&#39;)
            self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[31],&#39;4.4&#39;)
            self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[32]
            self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[33],&#39;4.4&#39;)
            self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[34]
        elif self.productDefinitionTemplateNumber == 10:
            self.percentileValue = self.productDefinitionTemplate[15]
            self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[16]
            self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[17]
            self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[18]
            self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[19]
            self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[20]
            self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[21]
            self.numberOfTimeRanges = self.productDefinitionTemplate[22]
            self.numberOfMissingValues = self.productDefinitionTemplate[23]
            self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[24],&#39;4.10&#39;)
            self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.11&#39;)
            self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.4&#39;)
            self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[27]
            self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[28],&#39;4.4&#39;)
            self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[29]
        elif self.productDefinitionTemplateNumber == 11:
            self.typeOfEnsembleForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.6&#39;)
            self.perturbationNumber = self.productDefinitionTemplate[16]
            self.numberOfEnsembleForecasts = self.productDefinitionTemplate[17]
            self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[18]
            self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[19]
            self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[20]
            self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[21]
            self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[22]
            self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[23]
            self.numberOfTimeRanges = self.productDefinitionTemplate[24]
            self.numberOfMissingValues = self.productDefinitionTemplate[25]
            self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.10&#39;)
            self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.11&#39;)
            self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[28],&#39;4.4&#39;)
            self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[29]
            self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[30],&#39;4.4&#39;)
            self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[31]
        elif self.productDefinitionTemplateNumber == 12:
            self.typeOfDerivedForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.7&#39;)
            self.numberOfEnsembleForecasts = self.productDefinitionTemplate[16]
            self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[17]
            self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[18]
            self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[19]
            self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[20]
            self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[21]
            self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[22]
            self.numberOfTimeRanges = self.productDefinitionTemplate[23]
            self.numberOfMissingValues = self.productDefinitionTemplate[24]
            self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.10&#39;)
            self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.11&#39;)
            self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.4&#39;)
            self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[28]
            self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[29],&#39;4.4&#39;)
            self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[30]

        # Section 5 -- Data Representation
        if self.dataRepresentationTemplateNumber == 0:
            # Grid Point Data -- Simple Packing
            self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
            self.binScaleFactor = self.dataRepresentationTemplate[1]
            self.decScaleFactor = self.dataRepresentationTemplate[2]
            self.nBitsPacking = self.dataRepresentationTemplate[3]
            self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[3],&#39;5.1&#39;)
        elif self.dataRepresentationTemplateNumber == 2:
            # Grid Point Data -- Complex Packing
            self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
            self.binScaleFactor = self.dataRepresentationTemplate[1]
            self.decScaleFactor = self.dataRepresentationTemplate[2]
            self.nBitsPacking = self.dataRepresentationTemplate[3]
            self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
            self.groupSplitMethod = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.4&#39;)
            self.typeOfMissingValue = tables.get_value_from_table(self.dataRepresentationTemplate[6],&#39;5.5&#39;)
            self.priMissingValue = _getieeeint(self.dataRepresentationTemplate[7]) if self.dataRepresentationTemplate[6] in [1,2] else None 
            self.secMissingValue = _getieeeint(self.dataRepresentationTemplate[8]) if self.dataRepresentationTemplate[6] in [1,2] else None
            self.nGroups = self.dataRepresentationTemplate[9]
            self.refGroupWidth = self.dataRepresentationTemplate[10]
            self.nBitsGroupWidth = self.dataRepresentationTemplate[11]
            self.refGroupLength = self.dataRepresentationTemplate[12]
            self.groupLengthIncrement = self.dataRepresentationTemplate[13]
            self.lengthOfLastGroup = self.dataRepresentationTemplate[14]
            self.nBitsScaledGroupLength = self.dataRepresentationTemplate[15]
        elif self.dataRepresentationTemplateNumber == 3:
            # Grid Point Data -- Complex Packing and Spatial Differencing
            self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
            self.binScaleFactor = self.dataRepresentationTemplate[1]
            self.decScaleFactor = self.dataRepresentationTemplate[2]
            self.nBitsPacking = self.dataRepresentationTemplate[3]
            self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
            self.groupSplitMethod = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.4&#39;)
            self.typeOfMissingValue = tables.get_value_from_table(self.dataRepresentationTemplate[6],&#39;5.5&#39;)
            self.priMissingValue = _getieeeint(self.dataRepresentationTemplate[7]) if self.dataRepresentationTemplate[6] in [1,2] else None 
            self.secMissingValue = _getieeeint(self.dataRepresentationTemplate[8]) if self.dataRepresentationTemplate[6] in [1,2] else None
            self.nGroups = self.dataRepresentationTemplate[9]
            self.refGroupWidth = self.dataRepresentationTemplate[10]
            self.nBitsGroupWidth = self.dataRepresentationTemplate[11]
            self.refGroupLength = self.dataRepresentationTemplate[12]
            self.groupLengthIncrement = self.dataRepresentationTemplate[13]
            self.lengthOfLastGroup = self.dataRepresentationTemplate[14]
            self.nBitsScaledGroupLength = self.dataRepresentationTemplate[15]
            self.spatialDifferenceOrder = tables.get_value_from_table(self.dataRepresentationTemplate[16],&#39;5.6&#39;)
            self.nBytesSpatialDifference = self.dataRepresentationTemplate[17]
        elif self.dataRepresentationTemplateNumber == 4:
            # Grid Point Data - IEEE Floating Point Data
            self.precision = tables.get_value_from_table(self.dataRepresentationTemplate[0],&#39;5.7&#39;)
        elif self.dataRepresentationTemplateNumber == 40:
            # Grid Point Data - JPEG2000 Compression
            self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
            self.binScaleFactor = self.dataRepresentationTemplate[1]
            self.decScaleFactor = self.dataRepresentationTemplate[2]
            self.nBitsPacking = self.dataRepresentationTemplate[3]
            self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
            self.typeOfCompression = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.40&#39;)
            self.targetCompressionRatio = self.dataRepresentationTemplate[6]
        elif self.dataRepresentationTemplateNumber == 41:
            # Grid Point Data - PNG Compression
            self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
            self.binScaleFactor = self.dataRepresentationTemplate[1]
            self.decScaleFactor = self.dataRepresentationTemplate[2]
            self.nBitsPacking = self.dataRepresentationTemplate[3]
            self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)

    def data(self,fill_value=DEFAULT_FILL_VALUE,masked_array=True,expand=True,order=None):
        &#34;&#34;&#34;
        Returns an unpacked data grid.

        Parameters
        ----------

        **`fill_value : float, optional`**

        Missing or masked data is filled with this value or default value given by
        `DEFAULT_FILL_VALUE`.

        **`masked_array : bool, optional`**

        When `True` [DEFAULT], return masked array if there is bitmap for missing or masked data.

        **`expand : bool, optional`**

        When `True` [DEFAULT], ECMWF &#39;reduced&#39; gaussian grids are expanded to regular gaussian grids.

        **`order : int, optional`**

        If 0 [DEFAULT], nearest neighbor interpolation is used if grid has missing or bitmapped 
        values. If 1, linear interpolation is used for expanding reduced gaussian grids.

        Returns
        -------

        **`numpy.ndarray`**

        A numpy.ndarray with dtype=numpy.float32 with dimensions (ny,nx).
        &#34;&#34;&#34;
        if not hasattr(self,&#39;scanModeFlags&#39;):
            raise ValueError(&#39;Unsupported grid definition template number %s&#39;%self.gridDefinitionTemplateNumber)
        else:
            if self.scanModeFlags[2]:
                storageorder=&#39;F&#39;
            else:
                storageorder=&#39;C&#39;
        if order is None:
            if (self.dataRepresentationTemplateNumber in [2,3] and 
                self.dataRepresentationTemplate[6] != 0) or self.bitMapFlag == 0: 
                order = 0
            else:
                order = 1
        drtnum = self.dataRepresentationTemplateNumber
        drtmpl = np.asarray(self.dataRepresentationTemplate,dtype=np.int32)
        gdtnum = self.gridDefinitionTemplateNumber
        gdtmpl = np.asarray(self.gridDefinitionTemplate,dtype=np.int32)
        ndpts = self.numberOfDataPoints
        gdsinfo = self.gridDefinitionInfo
        ngrdpts = gdsinfo[1]
        ipos = self._datapos
        fld1 = g2clib.unpack7(self._msg,gdtnum,gdtmpl,drtnum,drtmpl,ndpts,ipos,np.empty,storageorder=storageorder)
        # Apply bitmap.
        if self.bitMapFlag == 0:
            fld = fill_value*np.ones(ngrdpts,&#39;f&#39;)
            np.put(fld,np.nonzero(self.bitMap),fld1)
            if masked_array:
                fld = ma.masked_values(fld,fill_value)
        # Missing values instead of bitmap
        elif masked_array and hasattr(self,&#39;priMissingValue&#39;):
            if hasattr(self,&#39;secMissingValue&#39;):
                mask = np.logical_or(fld1==self.priMissingValue,fld1==self.secMissingValue)
            else:
                mask = fld1 == self.priMissingValue
            fld = ma.array(fld1,mask=mask)
        else:
            fld = fld1
        if self.nx is not None and self.ny is not None: # Rectangular grid.
            if ma.isMA(fld):
                fld = ma.reshape(fld,(self.ny,self.nx))
            else:
                fld = np.reshape(fld,(self.ny,self.nx))
        else:
            if gdsinfo[2] and gdtnum == 40: # ECMWF &#39;reduced&#39; global gaussian grid.
                if expand:
                    from redtoreg import _redtoreg
                    self.nx = 2*self.ny
                    lonsperlat = self.defList
                    if ma.isMA(fld):
                        fld = ma.filled(fld)
                        fld = _redtoreg(self.nx,lonsperlat.astype(np.long),\
                                fld.astype(np.double),fill_value)
                        fld = ma.masked_values(fld,fill_value)
                    else:
                        fld = _redtoreg(self.nx,lonsperlat.astype(np.long),\
                                fld.astype(np.double),fill_value)
        # Check scan modes for rect grids.
        if self.nx is not None and self.ny is not None:
            if self.scanModeFlags[3]:
                fldsave = fld.astype(&#39;f&#39;) # casting makes a copy
                fld[1::2,:] = fldsave[1::2,::-1]
        return fld


    def __repr__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grib2io.Grib2Message.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, msg, ref=None, num=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class Constructor</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>msg : bytes</code></strong></p>
<p>Binary string representing the GRIB2 Message read from file.</p>
<p><strong><code>ref : grib2io.open, optional</code></strong></p>
<p>Holds the reference to the where this GRIB2 message originated
from (i.e. the input file). This allow for interaction with the
instance of <code><a title="grib2io.open" href="#grib2io.open">open</a></code>.</p>
<p><strong><code>num : int, optional</code></strong></p>
<p>Set to the GRIB2 Message number.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(self, msg, ref=None, num=-1):
    &#34;&#34;&#34;
    Class Constructor

    Parameters
    ----------

    **`msg : bytes`**

    Binary string representing the GRIB2 Message read from file.

    **`ref : grib2io.open, optional`**

    Holds the reference to the where this GRIB2 message originated
    from (i.e. the input file). This allow for interaction with the
    instance of `grib2io.open`.

    **`num : int, optional`**

    Set to the GRIB2 Message number.
    &#34;&#34;&#34;
    self._msg = msg
    self._pos = 0
    self._ref = ref
    self._datapos = 0
    self._msgnum = num
    
    # Section 0, Indicator Section
    self.indicatorSection = []
    self.indicatorSection.append(struct.unpack(&#39;&gt;4s&#39;,self._msg[0:4])[0])
    self.indicatorSection.append(struct.unpack(&#39;&gt;H&#39;,self._msg[4:6])[0])
    self.indicatorSection.append(self._msg[6])
    self.indicatorSection.append(self._msg[7])
    self.indicatorSection.append(struct.unpack(&#39;&gt;Q&#39;,self._msg[8:16])[0])
    self.discipline = tables.get_value_from_table(self.indicatorSection[2],&#39;0.0&#39;)
    self._pos = 16
    
    # Section 1, Indentification Section.
    self.identificationSection,self._pos = g2clib.unpack1(self._msg,self._pos,np.empty)
    self.identificationSection = self.identificationSection.tolist()
    self.originatingCenter = tables.get_value_from_table(self.identificationSection[0],&#39;originating_centers&#39;)
    self.originatingSubCenter = tables.get_value_from_table(self.identificationSection[1],&#39;originating_subcenters&#39;)
    self.masterTableInfo = tables.get_value_from_table(self.identificationSection[2],&#39;1.0&#39;)
    self.localTableInfo = tables.get_value_from_table(self.identificationSection[3],&#39;1.1&#39;)
    self.significanceOfReferenceTime = tables.get_value_from_table(self.identificationSection[4],&#39;1.2&#39;)
    self.year = self.identificationSection[5]
    self.month = self.identificationSection[6]
    self.day = self.identificationSection[7]
    self.hour = self.identificationSection[8]
    self.minute = self.identificationSection[9]
    self.second = self.identificationSection[10]
    self.intreferenceDate = (self.year*1000000)+(self.month*10000)+\
                            (self.day*100)+self.hour
    self.dtReferenceDate = datetime.datetime(self.year,self.month,self.day,
                                             hour=self.hour,minute=self.minute,
                                             second=self.second)
    self.productionStatus = tables.get_value_from_table(self.identificationSection[11],&#39;1.3&#39;)
    self.typeOfData = tables.get_value_from_table(self.identificationSection[12],&#39;1.4&#39;)

    # After Section 1, perform rest of GRIB2 Decoding inside while loop
    # to account for sub-messages.
    while True:
        if self._msg[self._pos:self._pos+4].decode(&#39;ascii&#39;,&#39;ignore&#39;) == &#39;7777&#39;: break

        # Read the length and section number.
        sectlen = struct.unpack(&#39;&gt;i&#39;,self._msg[self._pos:self._pos+4])[0]
        sectnum = struct.unpack(&#39;&gt;B&#39;,self._msg[self._pos+4:self._pos+5])[0]

        # Handle submessage accordingly.
        if self._ref._index[&#39;isSubmessage&#39;][num]:
            if sectnum == self._ref._index[&#39;submessageBeginSection&#39;][self._msgnum]:
                self._pos = self._ref._index[&#39;submessageOffset&#39;][self._msgnum]

        # Section 2, Local Use Section.
        self.localUseSection = None
        if sectnum == 2:
            _lus = self._msg[self._pos+5:self._pos+sectlen]
            self._pos += sectlen
            self.localUseSection = _lus
        # Section 3, Grid Definition Section.
        elif sectnum == 3:
            _gds,_gdtn,_deflist,self._pos = g2clib.unpack3(self._msg,self._pos,np.empty)
            self.gridDefinitionInfo = _gds.tolist()
            self.gridDefinitionTemplateNumber = int(_gds[4])
            self.gridDefinitionTemplate = _gdtn.tolist()
            self.defList = _deflist.tolist()
            self.gridDefinitionTemplateNumberInfo = tables.get_value_from_table(self.gridDefinitionTemplateNumber,&#39;3.1&#39;)
        # Section 4, Product Definition Section.
        elif sectnum == 4:
            _pdt,_pdtn,_coordlst,self._pos = g2clib.unpack4(self._msg,self._pos,np.empty)
            self.productDefinitionTemplate = _pdt.tolist()
            self.productDefinitionTemplateNumber = int(_pdtn)
            self.coordinateList = _coordlst.tolist()
        # Section 5, Data Representation Section.
        elif sectnum == 5:
            _drt,_drtn,_npts,self._pos = g2clib.unpack5(self._msg,self._pos,np.empty)
            self.dataRepresentationTemplate = _drt.tolist()
            self.dataRepresentationTemplateNumber = int(_drtn)
            self.numberOfDataPoints = _npts
        # Section 6, Bitmap Section.
        elif sectnum == 6:
            _bmap,_bmapflag = g2clib.unpack6(self._msg,self.gridDefinitionInfo[1],self._pos,np.empty)
            self.bitMapFlag = _bmapflag
            if self.bitMapFlag == 0:
                self.bitMap = _bmap
            elif self.bitMapFlag == 254: 
                # Value of 254 says to use a previous bitmap in the file.
                self.bitMapFlag = 0
                self.bitMap = self._ref._index[&#39;bitMap&#39;][self._msgnum]
            self._pos += sectlen # IMPORTANT: This is here because g2clib.unpack6() does not return updated position.
        # Section 7, Data Section (data unpacked when data() method is invoked).
        elif sectnum == 7:
            self._datapos = self._pos
            self._pos += sectlen # REMOVE THIS WHEN UNPACKING DATA IS IMPLEMENTED
        else:
            errmsg = &#39;Unknown section number = %i&#39; % sectnum
            raise ValueError(errmsg) 

    # Section 3 -- Grid Definition
    reggrid = self.gridDefinitionInfo[2] == 0 # self.gridDefinitionInfo[2]=0 means regular 2-d grid
    if self.gridDefinitionTemplateNumber in [50,51,52,1200]:
        earthparams = None
    else:
        earthparams = tables.earth_params[str(self.gridDefinitionTemplate[0])]
    if earthparams[&#39;shape&#39;] == &#39;spherical&#39;:
        if earthparams[&#39;radius&#39;] is None:
            self.earthRadius = self.gridDefinitionTemplate[2]/(10.**self.gridDefinitionTemplate[1])
        else:
            self.earthRadius = earthparams[&#39;radius&#39;]
            self.earthMajorAxis = None
            self.earthMinorAxis = None
    elif earthparams[&#39;shape&#39;] == &#39;oblateSpheroid&#39;:
        if earthparams[&#39;radius&#39;] is None and earthparams[&#39;major_axis&#39;] is None and earthparams[&#39;minor_axis&#39;] is None:
            self.earthRadius = self.gridDefinitionTemplate[2]/(10.**self.gridDefinitionTemplate[1])
            self.earthMajorAxis = self.gridDefinitionTemplate[4]/(10.**self.gridDefinitionTemplate[3])
            self.earthMinorAxis = self.gridDefinitionTemplate[6]/(10.**self.gridDefinitionTemplate[5])
        else:
            self.earthRadius = earthparams[&#39;radius&#39;]
            self.earthMajorAxis = earthparams[&#39;major_axis&#39;]
            self.earthMinorAxis = earthparams[&#39;minor_axis&#39;]
    if reggrid and self.gridDefinitionTemplateNumber not in [50,51,52,53,100,120,1000,1200]:
        self.nx = self.gridDefinitionTemplate[7]
        self.ny = self.gridDefinitionTemplate[8]
    if not reggrid and self.gridDefinitionTemplateNumber == 40: # &#39;reduced&#39; gaussian grid.
        self.ny = self.gridDefinitionTemplate[8]
    if self.gridDefinitionTemplateNumber in [0,1,203,205,32768,32769]: # regular or rotated lat/lon grid
        scalefact = float(self.gridDefinitionTemplate[9])
        divisor = float(self.gridDefinitionTemplate[10])
        if scalefact == 0: scalefact = 1.
        if divisor &lt;= 0: divisor = 1.e6
        self.latitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[11]/divisor
        self.longitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[12]/divisor
        self.latitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[14]/divisor
        self.longitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[15]/divisor
        self.gridlengthXDirection = scalefact*self.gridDefinitionTemplate[16]/divisor
        self.gridlengthYDirection = scalefact*self.gridDefinitionTemplate[17]/divisor
        if self.latitudeFirstGridpoint &gt; self.latitudeLastGridpoint:
            self.gridlengthYDirection = -self.gridlengthYDirection
        if self.longitudeFirstGridpoint &gt; self.longitudeLastGridpoint:
            self.gridlengthXDirection = -self.gridlengthXDirection
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]
        if self.gridDefinitionTemplateNumber == 1:
            self.latitudeSouthernPole = scalefact*self.gridDefinitionTemplate[19]/divisor
            self.longitudeSouthernPole = scalefact*self.gridDefinitionTemplate[20]/divisor
            self.anglePoleRotation = self.gridDefinitionTemplate[21]
    elif self.gridDefinitionTemplateNumber == 10: # mercator
        self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
        self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
        self.latitudeLastGridpoint = self.gridDefinitionTemplate[13]/1.e6
        self.longitudeLastGridpoint = self.gridDefinitionTemplate[14]/1.e6
        self.gridlengthXDirection = self.gridDefinitionTemplate[17]/1.e3
        self.gridlengthYDirection= self.gridDefinitionTemplate[18]/1.e3
        self.proj4_lat_ts = self.gridDefinitionTemplate[12]/1.e6
        self.proj4_lon_0 = 0.5*(self.longitudeFirstGridpoint+self.longitudeLastGridpoint)
        self.proj4_proj = &#39;merc&#39;
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[15],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 20: # stereographic
        projflag = _int2bin(self.gridDefinitionTemplate[16],output=list)[0]
        self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
        self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
        self.proj4_lat_ts = self.gridDefinitionTemplate[12]/1.e6
        if projflag == 0:
            self.proj4_lat_0 = 90
        elif projflag == 1:
            self.proj4_lat_0 = -90
        else:
            raise ValueError(&#39;Invalid projection center flag = %s&#39;%projflag)
        self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
        self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
        self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
        self.proj4_proj = &#39;stere&#39;
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 30: # lambert conformal
        self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
        self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
        self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
        self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
        self.proj4_lat_1 = self.gridDefinitionTemplate[18]/1.e6
        self.proj4_lat_2 = self.gridDefinitionTemplate[19]/1.e6
        self.proj4_lat_0 = self.gridDefinitionTemplate[12]/1.e6
        self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
        self.proj4_proj = &#39;lcc&#39;
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 31: # albers equal area.
        self.latitudeFirstGridpoint = self.gridDefinitionTemplate[9]/1.e6
        self.longitudeFirstGridpoint = self.gridDefinitionTemplate[10]/1.e6
        self.gridlengthXDirection = self.gridDefinitionTemplate[14]/1000.
        self.gridlengthYDirection = self.gridDefinitionTemplate[15]/1000.
        self.proj4_lat_1 = self.gridDefinitionTemplate[18]/1.e6
        self.proj4_lat_2 = self.gridDefinitionTemplate[19]/1.e6
        self.proj4_lat_0 = self.gridDefinitionTemplate[12]/1.e6
        self.proj4_lon_0 = self.gridDefinitionTemplate[13]/1.e6
        self.proj4_proj = &#39;aea&#39;
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[17],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 40 or self.gridDefinitionTemplateNumber == 41: # gaussian grid.
        scalefact = float(self.gridDefinitionTemplate[9])
        divisor = float(self.gridDefinitionTemplate[10])
        if scalefact == 0: scalefact = 1.
        if divisor &lt;= 0: divisor = 1.e6
        self.pointsBetweenPoleAndEquator = self.gridDefinitionTemplate[17]
        self.latitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[11]/divisor
        self.longitudeFirstGridpoint = scalefact*self.gridDefinitionTemplate[12]/divisor
        self.latitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[14]/divisor
        self.longitudeLastGridpoint = scalefact*self.gridDefinitionTemplate[15]/divisor
        if reggrid:
            self.gridlengthXDirection = scalefact*self.gridDefinitionTemplate[16]/divisor
            if self.longitudeFirstGridpoint &gt; self.longitudeLastGridpoint:
                self.gridlengthXDirection = -self.gridlengthXDirection
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]
        if self.gridDefinitionTemplateNumber == 41:
            self.latitudeSouthernPole = scalefact*self.gridDefinitionTemplate[19]/divisor
            self.longitudeSouthernPole = scalefact*self.gridDefinitionTemplate[20]/divisor
            self.anglePoleRotation = self.gridDefinitionTemplate[21]
    elif self.gridDefinitionTemplateNumber == 50: # spectral coefficients.
        self.spectralFunctionParameters = (self.gridDefinitionTemplate[0],self.gridDefinitionTemplate[1],self.gridDefinitionTemplate[2])
        self.scanModeFlags = [None,None,None,None] # doesn&#39;t apply
    elif self.gridDefinitionTemplateNumber == 90: # near-sided vertical perspective satellite projection
        self.proj4_lat_0 = self.gridDefinitionTemplate[9]/1.e6
        self.proj4_lon_0 = self.gridDefinitionTemplate[10]/1.e6
        self.proj4_h = self.earthMajorAxis * (self.gridDefinitionTemplate[18]/1.e6)
        dx = self.gridDefinitionTemplate[12]
        dy = self.gridDefinitionTemplate[13]
        # if lat_0 is equator, it&#39;s a geostationary view.
        if self.proj4_lat_0 == 0.: # if lat_0 is equator, it&#39;s a
            self.proj4_proj = &#39;geos&#39;
        # general case of &#39;near-side perspective projection&#39; (untested)
        else:
            self.proj4_proj = &#39;nsper&#39;
            msg = &#39;only geostationary perspective is supported. lat/lon values returned by grid method may be incorrect.&#39;
            warnings.warn(msg)
        # latitude of horizon on central meridian
        lonmax = 90.-(180./np.pi)*np.arcsin(self.earthMajorAxis/self.proj4_h)
        # longitude of horizon on equator
        latmax = 90.-(180./np.pi)*np.arcsin(self.earthMinorAxis/self.proj4_h)
        # truncate to nearest thousandth of a degree (to make sure
        # they aren&#39;t slightly over the horizon)
        latmax = int(1000*latmax)/1000.
        lonmax = int(1000*lonmax)/1000.
        # h is measured from surface of earth at equator.
        self.proj4_h = self.proj4_h - self.earthMajorAxis
        # width and height of visible projection
        P = pyproj.Proj(proj=self.proj4_proj,\
                        a=self.earthMajorAxis,b=self.earthMinorAxis,\
                        lat_0=0,lon_0=0,h=self.proj4_h)
        x1,y1 = P(0.,latmax); x2,y2 = P(lonmax,0.)
        width = 2*x2; height = 2*y1
        self.gridlengthXDirection = width/dx
        self.gridlengthYDirection = height/dy
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[16],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 110: # azimuthal equidistant.
        self.proj4_lat_0 = self.gridDefinitionTemplate[9]/1.e6
        self.proj4_lon_0 = self.gridDefinitionTemplate[10]/1.e6
        self.gridlengthXDirection = self.gridDefinitionTemplate[12]/1000.
        self.gridlengthYDirection = self.gridDefinitionTemplate[13]/1000.
        self.proj4_proj = &#39;aeqd&#39;
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[15],output=list)[0:4]
    elif self.gridDefinitionTemplateNumber == 204: # curvilinear orthogonal
        self.scanModeFlags = _int2bin(self.gridDefinitionTemplate[18],output=list)[0:4]

    # Missing value.
    #if self.dataRepresentationTemplateNumber in [2,3] and self.dataRepresentationTemplate[6] != 0:
    #    self.missingValue = _getieeeint(self.dataRepresentationTemplate[7])
    #    if self.dataRepresentationTemplate[6] == 2:
    #        self.missingValue2 = _getieeeint(self.dataRepresentationTemplate[8])

    # Section 4 -- Product Definition
    _varinfo = tables.get_varname_from_table(self.indicatorSection[2],
               self.productDefinitionTemplate[0],
               self.productDefinitionTemplate[1])
    self.varDescription = _varinfo[0]
    self.units = _varinfo[1]
    self.varName = _varinfo[2]
    self.generatingProcess = tables.get_value_from_table(self.productDefinitionTemplate[4],&#39;generating_process&#39;)
    self.unitOfTimeRange = tables.get_value_from_table(self.productDefinitionTemplate[7],&#39;4.4&#39;)
    self.leadTime = self.productDefinitionTemplate[8]
    _vals = tables.get_value_from_table(self.productDefinitionTemplate[9],&#39;4.5&#39;)
    self.typeOfFirstFixedSurface = _vals[0]
    self.unitOfFirstFixedSurface = _vals[1]
    self.valueOfFristFixedSurface = self.productDefinitionTemplate[11]/(10.**self.productDefinitionTemplate[10])
    _vals = tables.get_value_from_table(self.productDefinitionTemplate[12],&#39;4.5&#39;)
    self.typeOfSecondFixedSurface = None if _vals[0] == &#39;Missing&#39; else _vals[0]
    self.unitOfSecondFixedSurface = None if _vals[1] == &#39;unknown&#39; else _vals[1]
    self.valueOfSecondFixedSurface = None if self.typeOfSecondFixedSurface is None else \
                                     self.productDefinitionTemplate[14]/(10.**self.productDefinitionTemplate[13])
    if self.productDefinitionTemplateNumber == 1:
        self.typeOfEnsembleForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.6&#39;)
        self.perturbationNumber = self.productDefinitionTemplate[16]
        self.numberOfEnsembleForecasts = self.productDefinitionTemplate[17]
    elif self.productDefinitionTemplateNumber == 2:
        self.typeOfDerivedForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.7&#39;)
        self.numberOfEnsembleForecasts = self.productDefinitionTemplate[16]
    elif self.productDefinitionTemplateNumber == 5:
        self.forecastProbabilityNumber = self.productDefinitionTemplate[15]
        self.totalNumberOfForecastProbabilities = self.productDefinitionTemplate[16]
        self.typeOfProbability = tables.get_value_from_table(self.productDefinitionTemplate[16],&#39;4.9&#39;)
        self.thresholdLowerLimit = self.productDefinitionTemplate[18]/(10.**self.productDefinitionTemplate[17])
        self.thresholdUpperLimit = self.productDefinitionTemplate[20]/(10.**self.productDefinitionTemplate[19])
    elif self.productDefinitionTemplateNumber == 6:
        self.percentileValue = self.productDefinitionTemplate[15]
    elif self.productDefinitionTemplateNumber == 8:
        self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[15]
        self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[16]
        self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[17]
        self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[18]
        self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[19]
        self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[20]
        self.numberOfTimeRanges = self.productDefinitionTemplate[21]
        self.numberOfMissingValues = self.productDefinitionTemplate[22]
        self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[23],&#39;4.10&#39;)
        self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[24],&#39;4.11&#39;)
        self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.4&#39;)
        self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[26]
        self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.4&#39;)
        self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[28]
    elif self.productDefinitionTemplateNumber == 9:
        self.forecastProbabilityNumber = self.productDefinitionTemplate[15]
        self.totalNumberOfForecastProbabilities = self.productDefinitionTemplate[16]
        self.typeOfProbability = tables.get_value_from_table(self.productDefinitionTemplate[16],&#39;4.9&#39;)
        self.thresholdLowerLimit = self.productDefinitionTemplate[18]/(10.**self.productDefinitionTemplate[17])
        self.thresholdUpperLimit = self.productDefinitionTemplate[20]/(10.**self.productDefinitionTemplate[19])
        self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[21]
        self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[22]
        self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[23]
        self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[24]
        self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[25]
        self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[26]
        self.numberOfTimeRanges = self.productDefinitionTemplate[27]
        self.numberOfMissingValues = self.productDefinitionTemplate[28]
        self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[29],&#39;4.10&#39;)
        self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[30],&#39;4.11&#39;)
        self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[31],&#39;4.4&#39;)
        self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[32]
        self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[33],&#39;4.4&#39;)
        self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[34]
    elif self.productDefinitionTemplateNumber == 10:
        self.percentileValue = self.productDefinitionTemplate[15]
        self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[16]
        self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[17]
        self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[18]
        self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[19]
        self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[20]
        self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[21]
        self.numberOfTimeRanges = self.productDefinitionTemplate[22]
        self.numberOfMissingValues = self.productDefinitionTemplate[23]
        self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[24],&#39;4.10&#39;)
        self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.11&#39;)
        self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.4&#39;)
        self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[27]
        self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[28],&#39;4.4&#39;)
        self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[29]
    elif self.productDefinitionTemplateNumber == 11:
        self.typeOfEnsembleForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.6&#39;)
        self.perturbationNumber = self.productDefinitionTemplate[16]
        self.numberOfEnsembleForecasts = self.productDefinitionTemplate[17]
        self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[18]
        self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[19]
        self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[20]
        self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[21]
        self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[22]
        self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[23]
        self.numberOfTimeRanges = self.productDefinitionTemplate[24]
        self.numberOfMissingValues = self.productDefinitionTemplate[25]
        self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.10&#39;)
        self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.11&#39;)
        self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[28],&#39;4.4&#39;)
        self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[29]
        self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[30],&#39;4.4&#39;)
        self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[31]
    elif self.productDefinitionTemplateNumber == 12:
        self.typeOfDerivedForecast = tables.get_value_from_table(self.productDefinitionTemplate[15],&#39;4.7&#39;)
        self.numberOfEnsembleForecasts = self.productDefinitionTemplate[16]
        self.yearOfEndOfTimePeriod = self.productDefinitionTemplate[17]
        self.monthOfEndOfTimePeriod = self.productDefinitionTemplate[18]
        self.dayOfEndOfTimePeriod = self.productDefinitionTemplate[19]
        self.hourOfEndOfTimePeriod = self.productDefinitionTemplate[20]
        self.minuteOfEndOfTimePeriod = self.productDefinitionTemplate[21]
        self.secondOfEndOfTimePeriod = self.productDefinitionTemplate[22]
        self.numberOfTimeRanges = self.productDefinitionTemplate[23]
        self.numberOfMissingValues = self.productDefinitionTemplate[24]
        self.statisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[25],&#39;4.10&#39;)
        self.typeOfTimeIncrementOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[26],&#39;4.11&#39;)
        self.unitOfTimeRangeOfStatisticalProcess = tables.get_value_from_table(self.productDefinitionTemplate[27],&#39;4.4&#39;)
        self.timeRangeOfStatisticalProcess = self.productDefinitionTemplate[28]
        self.unitOfTimeRangeOfSuccessiveFields = tables.get_value_from_table(self.productDefinitionTemplate[29],&#39;4.4&#39;)
        self.timeIncrementOfSuccessiveFields = self.productDefinitionTemplate[30]

    # Section 5 -- Data Representation
    if self.dataRepresentationTemplateNumber == 0:
        # Grid Point Data -- Simple Packing
        self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
        self.binScaleFactor = self.dataRepresentationTemplate[1]
        self.decScaleFactor = self.dataRepresentationTemplate[2]
        self.nBitsPacking = self.dataRepresentationTemplate[3]
        self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[3],&#39;5.1&#39;)
    elif self.dataRepresentationTemplateNumber == 2:
        # Grid Point Data -- Complex Packing
        self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
        self.binScaleFactor = self.dataRepresentationTemplate[1]
        self.decScaleFactor = self.dataRepresentationTemplate[2]
        self.nBitsPacking = self.dataRepresentationTemplate[3]
        self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
        self.groupSplitMethod = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.4&#39;)
        self.typeOfMissingValue = tables.get_value_from_table(self.dataRepresentationTemplate[6],&#39;5.5&#39;)
        self.priMissingValue = _getieeeint(self.dataRepresentationTemplate[7]) if self.dataRepresentationTemplate[6] in [1,2] else None 
        self.secMissingValue = _getieeeint(self.dataRepresentationTemplate[8]) if self.dataRepresentationTemplate[6] in [1,2] else None
        self.nGroups = self.dataRepresentationTemplate[9]
        self.refGroupWidth = self.dataRepresentationTemplate[10]
        self.nBitsGroupWidth = self.dataRepresentationTemplate[11]
        self.refGroupLength = self.dataRepresentationTemplate[12]
        self.groupLengthIncrement = self.dataRepresentationTemplate[13]
        self.lengthOfLastGroup = self.dataRepresentationTemplate[14]
        self.nBitsScaledGroupLength = self.dataRepresentationTemplate[15]
    elif self.dataRepresentationTemplateNumber == 3:
        # Grid Point Data -- Complex Packing and Spatial Differencing
        self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
        self.binScaleFactor = self.dataRepresentationTemplate[1]
        self.decScaleFactor = self.dataRepresentationTemplate[2]
        self.nBitsPacking = self.dataRepresentationTemplate[3]
        self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
        self.groupSplitMethod = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.4&#39;)
        self.typeOfMissingValue = tables.get_value_from_table(self.dataRepresentationTemplate[6],&#39;5.5&#39;)
        self.priMissingValue = _getieeeint(self.dataRepresentationTemplate[7]) if self.dataRepresentationTemplate[6] in [1,2] else None 
        self.secMissingValue = _getieeeint(self.dataRepresentationTemplate[8]) if self.dataRepresentationTemplate[6] in [1,2] else None
        self.nGroups = self.dataRepresentationTemplate[9]
        self.refGroupWidth = self.dataRepresentationTemplate[10]
        self.nBitsGroupWidth = self.dataRepresentationTemplate[11]
        self.refGroupLength = self.dataRepresentationTemplate[12]
        self.groupLengthIncrement = self.dataRepresentationTemplate[13]
        self.lengthOfLastGroup = self.dataRepresentationTemplate[14]
        self.nBitsScaledGroupLength = self.dataRepresentationTemplate[15]
        self.spatialDifferenceOrder = tables.get_value_from_table(self.dataRepresentationTemplate[16],&#39;5.6&#39;)
        self.nBytesSpatialDifference = self.dataRepresentationTemplate[17]
    elif self.dataRepresentationTemplateNumber == 4:
        # Grid Point Data - IEEE Floating Point Data
        self.precision = tables.get_value_from_table(self.dataRepresentationTemplate[0],&#39;5.7&#39;)
    elif self.dataRepresentationTemplateNumber == 40:
        # Grid Point Data - JPEG2000 Compression
        self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
        self.binScaleFactor = self.dataRepresentationTemplate[1]
        self.decScaleFactor = self.dataRepresentationTemplate[2]
        self.nBitsPacking = self.dataRepresentationTemplate[3]
        self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)
        self.typeOfCompression = tables.get_value_from_table(self.dataRepresentationTemplate[5],&#39;5.40&#39;)
        self.targetCompressionRatio = self.dataRepresentationTemplate[6]
    elif self.dataRepresentationTemplateNumber == 41:
        # Grid Point Data - PNG Compression
        self.refValue = _getieeeint(self.dataRepresentationTemplate[0])
        self.binScaleFactor = self.dataRepresentationTemplate[1]
        self.decScaleFactor = self.dataRepresentationTemplate[2]
        self.nBitsPacking = self.dataRepresentationTemplate[3]
        self.typeOfValues = tables.get_value_from_table(self.dataRepresentationTemplate[4],&#39;5.1&#39;)</code></pre>
</details>
</dd>
<dt id="grib2io.Grib2Message.data"><code class="name flex">
<span>def <span class="ident">data</span></span>(<span>self, fill_value=9.969209968386869e+36, masked_array=True, expand=True, order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns an unpacked data grid.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>fill_value : float, optional</code></strong></p>
<p>Missing or masked data is filled with this value or default value given by
<code>DEFAULT_FILL_VALUE</code>.</p>
<p><strong><code>masked_array : bool, optional</code></strong></p>
<p>When <code>True</code> [DEFAULT], return masked array if there is bitmap for missing or masked data.</p>
<p><strong><code>expand : bool, optional</code></strong></p>
<p>When <code>True</code> [DEFAULT], ECMWF 'reduced' gaussian grids are expanded to regular gaussian grids.</p>
<p><strong><code>order : int, optional</code></strong></p>
<p>If 0 [DEFAULT], nearest neighbor interpolation is used if grid has missing or bitmapped
values. If 1, linear interpolation is used for expanding reduced gaussian grids.</p>
<h2 id="returns">Returns</h2>
<p><strong><code>numpy.ndarray</code></strong></p>
<p>A numpy.ndarray with dtype=numpy.float32 with dimensions (ny,nx).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def data(self,fill_value=DEFAULT_FILL_VALUE,masked_array=True,expand=True,order=None):
    &#34;&#34;&#34;
    Returns an unpacked data grid.

    Parameters
    ----------

    **`fill_value : float, optional`**

    Missing or masked data is filled with this value or default value given by
    `DEFAULT_FILL_VALUE`.

    **`masked_array : bool, optional`**

    When `True` [DEFAULT], return masked array if there is bitmap for missing or masked data.

    **`expand : bool, optional`**

    When `True` [DEFAULT], ECMWF &#39;reduced&#39; gaussian grids are expanded to regular gaussian grids.

    **`order : int, optional`**

    If 0 [DEFAULT], nearest neighbor interpolation is used if grid has missing or bitmapped 
    values. If 1, linear interpolation is used for expanding reduced gaussian grids.

    Returns
    -------

    **`numpy.ndarray`**

    A numpy.ndarray with dtype=numpy.float32 with dimensions (ny,nx).
    &#34;&#34;&#34;
    if not hasattr(self,&#39;scanModeFlags&#39;):
        raise ValueError(&#39;Unsupported grid definition template number %s&#39;%self.gridDefinitionTemplateNumber)
    else:
        if self.scanModeFlags[2]:
            storageorder=&#39;F&#39;
        else:
            storageorder=&#39;C&#39;
    if order is None:
        if (self.dataRepresentationTemplateNumber in [2,3] and 
            self.dataRepresentationTemplate[6] != 0) or self.bitMapFlag == 0: 
            order = 0
        else:
            order = 1
    drtnum = self.dataRepresentationTemplateNumber
    drtmpl = np.asarray(self.dataRepresentationTemplate,dtype=np.int32)
    gdtnum = self.gridDefinitionTemplateNumber
    gdtmpl = np.asarray(self.gridDefinitionTemplate,dtype=np.int32)
    ndpts = self.numberOfDataPoints
    gdsinfo = self.gridDefinitionInfo
    ngrdpts = gdsinfo[1]
    ipos = self._datapos
    fld1 = g2clib.unpack7(self._msg,gdtnum,gdtmpl,drtnum,drtmpl,ndpts,ipos,np.empty,storageorder=storageorder)
    # Apply bitmap.
    if self.bitMapFlag == 0:
        fld = fill_value*np.ones(ngrdpts,&#39;f&#39;)
        np.put(fld,np.nonzero(self.bitMap),fld1)
        if masked_array:
            fld = ma.masked_values(fld,fill_value)
    # Missing values instead of bitmap
    elif masked_array and hasattr(self,&#39;priMissingValue&#39;):
        if hasattr(self,&#39;secMissingValue&#39;):
            mask = np.logical_or(fld1==self.priMissingValue,fld1==self.secMissingValue)
        else:
            mask = fld1 == self.priMissingValue
        fld = ma.array(fld1,mask=mask)
    else:
        fld = fld1
    if self.nx is not None and self.ny is not None: # Rectangular grid.
        if ma.isMA(fld):
            fld = ma.reshape(fld,(self.ny,self.nx))
        else:
            fld = np.reshape(fld,(self.ny,self.nx))
    else:
        if gdsinfo[2] and gdtnum == 40: # ECMWF &#39;reduced&#39; global gaussian grid.
            if expand:
                from redtoreg import _redtoreg
                self.nx = 2*self.ny
                lonsperlat = self.defList
                if ma.isMA(fld):
                    fld = ma.filled(fld)
                    fld = _redtoreg(self.nx,lonsperlat.astype(np.long),\
                            fld.astype(np.double),fill_value)
                    fld = ma.masked_values(fld,fill_value)
                else:
                    fld = _redtoreg(self.nx,lonsperlat.astype(np.long),\
                            fld.astype(np.double),fill_value)
    # Check scan modes for rect grids.
    if self.nx is not None and self.ny is not None:
        if self.scanModeFlags[3]:
            fldsave = fld.astype(&#39;f&#39;) # casting makes a copy
            fld[1::2,:] = fldsave[1::2,::-1]
    return fld</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="grib2io.open"><code class="flex name class">
<span>class <span class="ident">open</span></span>
</code></dt>
<dd>
<div class="desc"><p>GRIB2 File Object.
A physical file can contain one or more GRIB2 messages.
When instantiated,
class <code><a title="grib2io.open" href="#grib2io.open">open</a></code>, the file named <code>filename</code> is opened for reading (<code>mode = 'r'</code>) and is
automatically indexed.
The indexing procedure reads some of the GRIB2 metadata for all GRIB2 Messages.</p>
<p>A GRIB2 Message may contain submessages whereby Section 2-7 can be repeated.
grib2io accommodates
for this by flattening any GRIB2 submessages into multiple individual messages.</p>
<h2 id="attributes">Attributes</h2>
<p><strong><code>mode : str</code></strong></p>
<p>Mode of opening the file.
For reading, <code>mode = 'rb'</code> and writing, mode = 'wb'.</p>
<p><strong><code>name : str</code></strong></p>
<p>Full path name of the GRIB2 file.</p>
<p><strong><code>messages : int</code></strong></p>
<p>Count of GRIB2 Messages contained in the file.</p>
<p><strong><code>current_message : int</code></strong></p>
<p>Current position of the file in units of GRIB2 Messages.</p>
<p><strong><code>size : int</code></strong></p>
<p>Size of the file in units of bytes.</p>
<p><strong><code>closed : bool</code></strong></p>
<p>Bool signaling if the file is closed <strong><code>True</code></strong> or open <strong><code>False</code></strong>.</p>
<p>Class Constructor</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>filename : str</code></strong></p>
<p>File name.</p>
<p><strong><code>mode : str, optional, default = 'r'</code></strong></p>
<p>File handle mode.
The default is open for reading ('r').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class open():
    &#34;&#34;&#34;
    GRIB2 File Object.  A physical file can contain one or more GRIB2 messages.  When instantiated,
    class `grib2io.open`, the file named `filename` is opened for reading (`mode = &#39;r&#39;`) and is
    automatically indexed.  The indexing procedure reads some of the GRIB2 metadata for all GRIB2 Messages.

    A GRIB2 Message may contain submessages whereby Section 2-7 can be repeated.  grib2io accommodates
    for this by flattening any GRIB2 submessages into multiple individual messages.

    Attributes
    ----------

    **`mode : str`**

    Mode of opening the file.  For reading, `mode = &#39;rb&#39;` and writing, mode = &#39;wb&#39;.

    **`name : str`**

    Full path name of the GRIB2 file.

    **`messages : int`**

    Count of GRIB2 Messages contained in the file.

    **`current_message : int`**

    Current position of the file in units of GRIB2 Messages.

    **`size : int`**

    Size of the file in units of bytes.

    **`closed : bool`**

    Bool signaling if the file is closed **`True`** or open **`False`**.

    &#34;&#34;&#34;
    __pdoc__[&#39;grib2io.open.__init__&#39;] = True
    def __init__(self, filename, mode=&#39;r&#39;):
        &#34;&#34;&#34;
        Class Constructor

        Parameters
        ----------

        **`filename : str`**

        File name.

        **`mode : str, optional, default = &#39;r&#39;`**

        File handle mode.  The default is open for reading (&#39;r&#39;).
        &#34;&#34;&#34;
        if mode == &#39;r&#39; or mode == &#39;w&#39;:
            mode = mode+&#39;b&#39;
        elif mode == &#39;a&#39;:
            mode = &#39;wb&#39;
        self._filehandle = builtins.open(filename,mode=mode,buffering=ONE_MB)
        self._hasindex = False
        self._index = {}
        self.mode = mode
        self.name = os.path.abspath(filename)
        self.messages = 0
        self.current_message = 0
        self.size = os.path.getsize(self.name)
        self.closed = self._filehandle.closed
        if &#39;r&#39; in self.mode: self._build_index()


    def __delete__(self, instance):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        self.close()
        del self._index
        

    def __enter__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        return self


    def __exit__(self, atype, value, traceback):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        self.close()


    def __iter__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        return self


    def __next__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if self.current_message &lt; self.messages:
            return self.read(1)[0]
        else:
            self.seek(0)
            raise StopIteration


    def __repr__(self):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        strings = []
        keys = self.__dict__.keys()
        for k in keys:
            if not k.startswith(&#39;_&#39;):
                strings.append(&#39;%s = %s\n&#39;%(k,self.__dict__[k]))
        return &#39;&#39;.join(strings)


    def __getitem__(self, key):
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        if isinstance(key,slice):
            if key.start is None and key.stop is None and key.step is None:
                beg = 1
                end = self.messages+1
                inc = 1
            else:
                beg, end, inc = key.indices(self.messages)
            return [self[i][0] for i in range(beg,end,inc)]
        elif isinstance(key,int):
            if key == 0: return None
            self._filehandle.seek(self._index[&#39;offset&#39;][key])
            return [Grib2Message(self._filehandle.read(self._index[&#39;size&#39;][key]),ref=self,num=self._index[&#39;messageNumber&#39;][key])]
        else:
            raise KeyError(&#39;Key must be an integer or slice&#39;)


    def _build_index(self):
        &#34;&#34;&#34;
        Perform indexing of GRIB2 Messages.
        &#34;&#34;&#34;
        # Initialize index dictionary
        self._index[&#39;offset&#39;] = [None]
        self._index[&#39;discipline&#39;] = [None]
        self._index[&#39;edition&#39;] = [None]
        self._index[&#39;size&#39;] = [None]
        self._index[&#39;submessageOffset&#39;] = [None]
        self._index[&#39;submessageBeginSection&#39;] = [None]
        self._index[&#39;isSubmessage&#39;] = [None]
        self._index[&#39;messageNumber&#39;] = [None]
        self._index[&#39;identificationSection&#39;] = [None]
        self._index[&#39;productDefinitionTemplateNumber&#39;] = [None]
        self._index[&#39;productDefinitionTemplate&#39;] = [None]
        self._index[&#39;varName&#39;] = [None]
        self._index[&#39;bitMap&#39;] = [None]

        # Iterate
        while True:
            try:
                # Read first 4 bytes and decode...looking for &#34;GRIB&#34;
                pos = self._filehandle.tell()
                header = struct.unpack(&#39;&gt;4s&#39;,self._filehandle.read(4))[0].decode()

                # Test header. Then get information from GRIB2 Section 0: the discipline
                # number, edition number (should always be 2), and GRIB2 message size.
                # Then iterate to check for submessages.
                if header == &#39;GRIB&#39;:
                    _issubmessage = False
                    _submsgoffset = 0
                    _submsgbegin = 0

                    # Read and unpack Section 0. Note that this is not done through
                    # the g2clib.
                    self._filehandle.seek(self._filehandle.tell()+2)
                    discipline = int(struct.unpack(&#39;&gt;B&#39;,self._filehandle.read(1))[0])
                    edition = int(struct.unpack(&#39;&gt;B&#39;,self._filehandle.read(1))[0])
                    assert edition == 2
                    size = struct.unpack(&#39;&gt;Q&#39;,self._filehandle.read(8))[0]

                    # Read and unpack Section 1
                    secsize = struct.unpack(&#39;&gt;i&#39;,self._filehandle.read(4))[0]
                    secnum = struct.unpack(&#39;&gt;B&#39;,self._filehandle.read(1))[0]
                    assert secnum == 1
                    self._filehandle.seek(self._filehandle.tell()-5)
                    _grbmsg = self._filehandle.read(secsize)
                    _grbpos = 0
                    _grbsec1,_grbpos = g2clib.unpack1(_grbmsg,_grbpos,np.empty)
                    _grbsec1 = _grbsec1.tolist()
                    
                    secrange = range(2,8)
                    while 1:
                        for num in secrange:
                            secsize = struct.unpack(&#39;&gt;i&#39;,self._filehandle.read(4))[0]
                            secnum = struct.unpack(&#39;&gt;B&#39;,self._filehandle.read(1))[0]
                            if secnum == num:
                                if secnum == 3:
                                    self._filehandle.seek(self._filehandle.tell()-5) 
                                    _grbmsg = self._filehandle.read(secsize)
                                    _grbpos = 0
                                    # Unpack Section 3
                                    _gds,_gdtn,_deflist,_grbpos = g2clib.unpack3(_grbmsg,_grbpos,np.empty)
                                elif secnum == 4:
                                    self._filehandle.seek(self._filehandle.tell()-5) 
                                    _grbmsg = self._filehandle.read(secsize)
                                    _grbpos = 0
                                    # Unpack Section 4
                                    _pdt,_pdtnum,_coordlist,_grbpos = g2clib.unpack4(_grbmsg,_grbpos,np.empty)
                                    _pdt = _pdt.tolist()
                                    _varinfo = tables.get_varname_from_table(discipline,_pdt[0],_pdt[1])
                                elif secnum == 6:
                                    self._filehandle.seek(self._filehandle.tell()-5) 
                                    _grbmsg = self._filehandle.read(secsize)
                                    _grbpos = 0
                                    # Unpack Section 6. Save bitmap
                                    _bmap,_bmapflag = g2clib.unpack6(_grbmsg,_gds[1],_grbpos,np.empty)
                                    if _bmapflag == 0:
                                        _bmap_save = copy.deepcopy(_bmap)
                                    elif _bmapflag == 254:
                                        _bmap = copy.deepcopy(_bmap_save)
                                else:
                                    self._filehandle.seek(self._filehandle.tell()+secsize-5)
                            else:
                                if num == 2 and secnum == 3:
                                    pass # Allow this.  Just means no Local Use Section.
                                else:
                                    _issubmessage = True
                                    _submsgoffset = (self._filehandle.tell()-5)-(self._index[&#39;offset&#39;][self.messages])
                                    _submsgbegin = secnum
                                self._filehandle.seek(self._filehandle.tell()-5)
                                continue
                        trailer = struct.unpack(&#39;&gt;4s&#39;,self._filehandle.read(4))[0].decode()
                        if trailer == &#39;7777&#39;:
                            self.messages += 1
                            self._index[&#39;offset&#39;].append(pos)
                            self._index[&#39;discipline&#39;].append(discipline)
                            self._index[&#39;edition&#39;].append(edition)
                            self._index[&#39;size&#39;].append(size)
                            self._index[&#39;messageNumber&#39;].append(self.messages)
                            self._index[&#39;isSubmessage&#39;].append(_issubmessage)
                            self._index[&#39;identificationSection&#39;].append(_grbsec1)
                            self._index[&#39;productDefinitionTemplateNumber&#39;].append([_pdtnum])
                            self._index[&#39;productDefinitionTemplate&#39;].append([_pdt])
                            self._index[&#39;varName&#39;].append(_varinfo[2])
                            self._index[&#39;bitMap&#39;].append(_bmap)
                            if _issubmessage:
                                self._index[&#39;submessageOffset&#39;].append(_submsgoffset)
                                self._index[&#39;submessageBeginSection&#39;].append(_submsgbegin)
                            else:
                                self._index[&#39;submessageOffset&#39;].append(0)
                                self._index[&#39;submessageBeginSection&#39;].append(_submsgbegin)
                            break
                        else:
                            self._filehandle.seek(self._filehandle.tell()-4)
                            self.messages += 1
                            self._index[&#39;offset&#39;].append(pos)
                            self._index[&#39;discipline&#39;].append(discipline)
                            self._index[&#39;edition&#39;].append(edition)
                            self._index[&#39;size&#39;].append(size)
                            self._index[&#39;messageNumber&#39;].append(self.messages)
                            self._index[&#39;isSubmessage&#39;].append(_issubmessage)
                            self._index[&#39;identificationSection&#39;].append(_grbsec1)
                            self._index[&#39;productDefinitionTemplateNumber&#39;].append([_pdtnum])
                            self._index[&#39;productDefinitionTemplate&#39;].append([_pdt])
                            self._index[&#39;varName&#39;].append(_varinfo[2])
                            self._index[&#39;bitMap&#39;].append(_bmap)
                            self._index[&#39;submessageOffset&#39;].append(_submsgoffset)
                            self._index[&#39;submessageBeginSection&#39;].append(_submsgbegin)
                            continue

            except(struct.error):
                self._filehandle.seek(0)
                break

        self._hasindex = True
                    

    def close(self):
        &#34;&#34;&#34;
        Close the file handle
        &#34;&#34;&#34;
        if not self._filehandle.closed:
            self._filehandle.close()
            self.closed = self._filehandle.closed


    def read(self, num=0):
        &#34;&#34;&#34;    
        Read num GRIB2 messages from the current position

        Parameters
        ----------

        **`num : int`**

        Number of GRIB2 Message to read.

        Returns
        -------

        **`list`**

        List of `grib2io.Grib2Message` instances.
        &#34;&#34;&#34;
        msgs = []
        if self.tell() &gt;= self.messages: return msgs
        if num &gt; 0:
            if num == 1:
                msgrange = [self.tell()+1]
            else:
                beg = self.tell()+1
                end = self.tell()+1+num if self.tell()+1+num &lt;= self.messages else self.messages
                msgrange = range(beg,end+1)
            for n in msgrange:
                self._filehandle.seek(self._index[&#39;offset&#39;][n])
                msgs.append(Grib2Message(self._filehandle.read(self._index[&#39;size&#39;][n]),ref=self,num=self._index[&#39;messageNumber&#39;][n]))
                self.current_message += 1 
        return msgs


    def rewind(self):
        &#34;&#34;&#34;
        Set the position of the file to zero in units of GRIB2 messages.
        &#34;&#34;&#34;
        self.seek(0)


    def seek(self, pos):
        &#34;&#34;&#34;
        Set the position within the file in units of GRIB2 messages.

        Parameters
        ----------

        **`pos : int`**

        GRIB2 Message number to set the read pointer to.
        &#34;&#34;&#34;
        if self._hasindex:
            if pos == 0:
                self._filehandle.seek(pos)
                self.current_message = pos
            elif pos &gt; 0:
                self._filehandle.seek(self._index[&#39;offset&#39;][pos-1])
                self.current_message = pos


    def tell(self):
        &#34;&#34;&#34;
        Returns the position of the file in units of GRIB2 Messages.
        &#34;&#34;&#34;
        return self.current_message</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="grib2io.open.__init__"><code class="name flex">
<span>def <span class="ident">__init__</span></span>(<span>self, filename, mode='r')</span>
</code></dt>
<dd>
<div class="desc"><p>Class Constructor</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>filename : str</code></strong></p>
<p>File name.</p>
<p><strong><code>mode : str, optional, default = 'r'</code></strong></p>
<p>File handle mode.
The default is open for reading ('r').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __init__(self, filename, mode=&#39;r&#39;):
    &#34;&#34;&#34;
    Class Constructor

    Parameters
    ----------

    **`filename : str`**

    File name.

    **`mode : str, optional, default = &#39;r&#39;`**

    File handle mode.  The default is open for reading (&#39;r&#39;).
    &#34;&#34;&#34;
    if mode == &#39;r&#39; or mode == &#39;w&#39;:
        mode = mode+&#39;b&#39;
    elif mode == &#39;a&#39;:
        mode = &#39;wb&#39;
    self._filehandle = builtins.open(filename,mode=mode,buffering=ONE_MB)
    self._hasindex = False
    self._index = {}
    self.mode = mode
    self.name = os.path.abspath(filename)
    self.messages = 0
    self.current_message = 0
    self.size = os.path.getsize(self.name)
    self.closed = self._filehandle.closed
    if &#39;r&#39; in self.mode: self._build_index()</code></pre>
</details>
</dd>
<dt id="grib2io.open.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the file handle</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    &#34;&#34;&#34;
    Close the file handle
    &#34;&#34;&#34;
    if not self._filehandle.closed:
        self._filehandle.close()
        self.closed = self._filehandle.closed</code></pre>
</details>
</dd>
<dt id="grib2io.open.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>self, num=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Read num GRIB2 messages from the current position</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>num : int</code></strong></p>
<p>Number of GRIB2 Message to read.</p>
<h2 id="returns">Returns</h2>
<p><strong><code>list</code></strong></p>
<p>List of <code><a title="grib2io.Grib2Message" href="#grib2io.Grib2Message">Grib2Message</a></code> instances.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(self, num=0):
    &#34;&#34;&#34;    
    Read num GRIB2 messages from the current position

    Parameters
    ----------

    **`num : int`**

    Number of GRIB2 Message to read.

    Returns
    -------

    **`list`**

    List of `grib2io.Grib2Message` instances.
    &#34;&#34;&#34;
    msgs = []
    if self.tell() &gt;= self.messages: return msgs
    if num &gt; 0:
        if num == 1:
            msgrange = [self.tell()+1]
        else:
            beg = self.tell()+1
            end = self.tell()+1+num if self.tell()+1+num &lt;= self.messages else self.messages
            msgrange = range(beg,end+1)
        for n in msgrange:
            self._filehandle.seek(self._index[&#39;offset&#39;][n])
            msgs.append(Grib2Message(self._filehandle.read(self._index[&#39;size&#39;][n]),ref=self,num=self._index[&#39;messageNumber&#39;][n]))
            self.current_message += 1 
    return msgs</code></pre>
</details>
</dd>
<dt id="grib2io.open.rewind"><code class="name flex">
<span>def <span class="ident">rewind</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position of the file to zero in units of GRIB2 messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewind(self):
    &#34;&#34;&#34;
    Set the position of the file to zero in units of GRIB2 messages.
    &#34;&#34;&#34;
    self.seek(0)</code></pre>
</details>
</dd>
<dt id="grib2io.open.seek"><code class="name flex">
<span>def <span class="ident">seek</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position within the file in units of GRIB2 messages.</p>
<h2 id="parameters">Parameters</h2>
<p><strong><code>pos : int</code></strong></p>
<p>GRIB2 Message number to set the read pointer to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def seek(self, pos):
    &#34;&#34;&#34;
    Set the position within the file in units of GRIB2 messages.

    Parameters
    ----------

    **`pos : int`**

    GRIB2 Message number to set the read pointer to.
    &#34;&#34;&#34;
    if self._hasindex:
        if pos == 0:
            self._filehandle.seek(pos)
            self.current_message = pos
        elif pos &gt; 0:
            self._filehandle.seek(self._index[&#39;offset&#39;][pos-1])
            self.current_message = pos</code></pre>
</details>
</dd>
<dt id="grib2io.open.tell"><code class="name flex">
<span>def <span class="ident">tell</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the position of the file in units of GRIB2 Messages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tell(self):
    &#34;&#34;&#34;
    Returns the position of the file in units of GRIB2 Messages.
    &#34;&#34;&#34;
    return self.current_message</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
</ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="grib2io.tables" href="tables/index.html">grib2io.tables</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="grib2io.Grib2Message" href="#grib2io.Grib2Message">Grib2Message</a></code></h4>
<ul class="">
<li><code><a title="grib2io.Grib2Message.__init__" href="#grib2io.Grib2Message.__init__">__init__</a></code></li>
<li><code><a title="grib2io.Grib2Message.data" href="#grib2io.Grib2Message.data">data</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="grib2io.open" href="#grib2io.open">open</a></code></h4>
<ul class="two-column">
<li><code><a title="grib2io.open.__init__" href="#grib2io.open.__init__">__init__</a></code></li>
<li><code><a title="grib2io.open.close" href="#grib2io.open.close">close</a></code></li>
<li><code><a title="grib2io.open.read" href="#grib2io.open.read">read</a></code></li>
<li><code><a title="grib2io.open.rewind" href="#grib2io.open.rewind">rewind</a></code></li>
<li><code><a title="grib2io.open.seek" href="#grib2io.open.seek">seek</a></code></li>
<li><code><a title="grib2io.open.tell" href="#grib2io.open.tell">tell</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>