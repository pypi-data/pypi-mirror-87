# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _gridpp
else:
    import _gridpp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _gridpp.delete_SwigPyIterator

    def value(self):
        return _gridpp.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _gridpp.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _gridpp.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _gridpp.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _gridpp.SwigPyIterator_equal(self, x)

    def copy(self):
        return _gridpp.SwigPyIterator_copy(self)

    def next(self):
        return _gridpp.SwigPyIterator_next(self)

    def __next__(self):
        return _gridpp.SwigPyIterator___next__(self)

    def previous(self):
        return _gridpp.SwigPyIterator_previous(self)

    def advance(self, n):
        return _gridpp.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _gridpp.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _gridpp.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _gridpp.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _gridpp.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _gridpp.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _gridpp.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _gridpp:
_gridpp.SwigPyIterator_swigregister(SwigPyIterator)

class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.IntVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.IntVector___bool__(self)

    def __len__(self):
        return _gridpp.IntVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.IntVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.IntVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.IntVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.IntVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.IntVector_pop(self)

    def append(self, x):
        return _gridpp.IntVector_append(self, x)

    def empty(self):
        return _gridpp.IntVector_empty(self)

    def size(self):
        return _gridpp.IntVector_size(self)

    def swap(self, v):
        return _gridpp.IntVector_swap(self, v)

    def begin(self):
        return _gridpp.IntVector_begin(self)

    def end(self):
        return _gridpp.IntVector_end(self)

    def rbegin(self):
        return _gridpp.IntVector_rbegin(self)

    def rend(self):
        return _gridpp.IntVector_rend(self)

    def clear(self):
        return _gridpp.IntVector_clear(self)

    def get_allocator(self):
        return _gridpp.IntVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.IntVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.IntVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.IntVector_swiginit(self, _gridpp.new_IntVector(*args))

    def push_back(self, x):
        return _gridpp.IntVector_push_back(self, x)

    def front(self):
        return _gridpp.IntVector_front(self)

    def back(self):
        return _gridpp.IntVector_back(self)

    def assign(self, n, x):
        return _gridpp.IntVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.IntVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.IntVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.IntVector_reserve(self, n)

    def capacity(self):
        return _gridpp.IntVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_IntVector

# Register IntVector in _gridpp:
_gridpp.IntVector_swigregister(IntVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector_pop(self)

    def append(self, x):
        return _gridpp.FloatVector_append(self, x)

    def empty(self):
        return _gridpp.FloatVector_empty(self)

    def size(self):
        return _gridpp.FloatVector_size(self)

    def swap(self, v):
        return _gridpp.FloatVector_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector_begin(self)

    def end(self):
        return _gridpp.FloatVector_end(self)

    def rbegin(self):
        return _gridpp.FloatVector_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector_rend(self)

    def clear(self):
        return _gridpp.FloatVector_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector_swiginit(self, _gridpp.new_FloatVector(*args))

    def push_back(self, x):
        return _gridpp.FloatVector_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector_front(self)

    def back(self):
        return _gridpp.FloatVector_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector

# Register FloatVector in _gridpp:
_gridpp.FloatVector_swigregister(FloatVector)

class FloatVector3(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector3_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector3___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector3___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector3___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector3___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector3___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector3___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector3___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector3___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector3___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector3_pop(self)

    def append(self, x):
        return _gridpp.FloatVector3_append(self, x)

    def empty(self):
        return _gridpp.FloatVector3_empty(self)

    def size(self):
        return _gridpp.FloatVector3_size(self)

    def swap(self, v):
        return _gridpp.FloatVector3_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector3_begin(self)

    def end(self):
        return _gridpp.FloatVector3_end(self)

    def rbegin(self):
        return _gridpp.FloatVector3_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector3_rend(self)

    def clear(self):
        return _gridpp.FloatVector3_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector3_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector3_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector3_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector3_swiginit(self, _gridpp.new_FloatVector3(*args))

    def push_back(self, x):
        return _gridpp.FloatVector3_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector3_front(self)

    def back(self):
        return _gridpp.FloatVector3_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector3_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector3_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector3_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector3_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector3_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector3

# Register FloatVector3 in _gridpp:
_gridpp.FloatVector3_swigregister(FloatVector3)

class IntVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.IntVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.IntVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.IntVector2___bool__(self)

    def __len__(self):
        return _gridpp.IntVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.IntVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.IntVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.IntVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.IntVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.IntVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.IntVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.IntVector2_pop(self)

    def append(self, x):
        return _gridpp.IntVector2_append(self, x)

    def empty(self):
        return _gridpp.IntVector2_empty(self)

    def size(self):
        return _gridpp.IntVector2_size(self)

    def swap(self, v):
        return _gridpp.IntVector2_swap(self, v)

    def begin(self):
        return _gridpp.IntVector2_begin(self)

    def end(self):
        return _gridpp.IntVector2_end(self)

    def rbegin(self):
        return _gridpp.IntVector2_rbegin(self)

    def rend(self):
        return _gridpp.IntVector2_rend(self)

    def clear(self):
        return _gridpp.IntVector2_clear(self)

    def get_allocator(self):
        return _gridpp.IntVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.IntVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.IntVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.IntVector2_swiginit(self, _gridpp.new_IntVector2(*args))

    def push_back(self, x):
        return _gridpp.IntVector2_push_back(self, x)

    def front(self):
        return _gridpp.IntVector2_front(self)

    def back(self):
        return _gridpp.IntVector2_back(self)

    def assign(self, n, x):
        return _gridpp.IntVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.IntVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.IntVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.IntVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.IntVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_IntVector2

# Register IntVector2 in _gridpp:
_gridpp.IntVector2_swigregister(IntVector2)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.DoubleVector___nonzero__(self)

    def __bool__(self):
        return _gridpp.DoubleVector___bool__(self)

    def __len__(self):
        return _gridpp.DoubleVector___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.DoubleVector___setitem__(self, *args)

    def pop(self):
        return _gridpp.DoubleVector_pop(self)

    def append(self, x):
        return _gridpp.DoubleVector_append(self, x)

    def empty(self):
        return _gridpp.DoubleVector_empty(self)

    def size(self):
        return _gridpp.DoubleVector_size(self)

    def swap(self, v):
        return _gridpp.DoubleVector_swap(self, v)

    def begin(self):
        return _gridpp.DoubleVector_begin(self)

    def end(self):
        return _gridpp.DoubleVector_end(self)

    def rbegin(self):
        return _gridpp.DoubleVector_rbegin(self)

    def rend(self):
        return _gridpp.DoubleVector_rend(self)

    def clear(self):
        return _gridpp.DoubleVector_clear(self)

    def get_allocator(self):
        return _gridpp.DoubleVector_get_allocator(self)

    def pop_back(self):
        return _gridpp.DoubleVector_pop_back(self)

    def erase(self, *args):
        return _gridpp.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _gridpp.DoubleVector_swiginit(self, _gridpp.new_DoubleVector(*args))

    def push_back(self, x):
        return _gridpp.DoubleVector_push_back(self, x)

    def front(self):
        return _gridpp.DoubleVector_front(self)

    def back(self):
        return _gridpp.DoubleVector_back(self)

    def assign(self, n, x):
        return _gridpp.DoubleVector_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.DoubleVector_resize(self, *args)

    def insert(self, *args):
        return _gridpp.DoubleVector_insert(self, *args)

    def reserve(self, n):
        return _gridpp.DoubleVector_reserve(self, n)

    def capacity(self):
        return _gridpp.DoubleVector_capacity(self)
    __swig_destroy__ = _gridpp.delete_DoubleVector

# Register DoubleVector in _gridpp:
_gridpp.DoubleVector_swigregister(DoubleVector)

class FloatVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.FloatVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.FloatVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.FloatVector2___bool__(self)

    def __len__(self):
        return _gridpp.FloatVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.FloatVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.FloatVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.FloatVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.FloatVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.FloatVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.FloatVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.FloatVector2_pop(self)

    def append(self, x):
        return _gridpp.FloatVector2_append(self, x)

    def empty(self):
        return _gridpp.FloatVector2_empty(self)

    def size(self):
        return _gridpp.FloatVector2_size(self)

    def swap(self, v):
        return _gridpp.FloatVector2_swap(self, v)

    def begin(self):
        return _gridpp.FloatVector2_begin(self)

    def end(self):
        return _gridpp.FloatVector2_end(self)

    def rbegin(self):
        return _gridpp.FloatVector2_rbegin(self)

    def rend(self):
        return _gridpp.FloatVector2_rend(self)

    def clear(self):
        return _gridpp.FloatVector2_clear(self)

    def get_allocator(self):
        return _gridpp.FloatVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.FloatVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.FloatVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.FloatVector2_swiginit(self, _gridpp.new_FloatVector2(*args))

    def push_back(self, x):
        return _gridpp.FloatVector2_push_back(self, x)

    def front(self):
        return _gridpp.FloatVector2_front(self)

    def back(self):
        return _gridpp.FloatVector2_back(self)

    def assign(self, n, x):
        return _gridpp.FloatVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.FloatVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.FloatVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.FloatVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.FloatVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_FloatVector2

# Register FloatVector2 in _gridpp:
_gridpp.FloatVector2_swigregister(FloatVector2)

class DoubleVector2(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _gridpp.DoubleVector2_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _gridpp.DoubleVector2___nonzero__(self)

    def __bool__(self):
        return _gridpp.DoubleVector2___bool__(self)

    def __len__(self):
        return _gridpp.DoubleVector2___len__(self)

    def __getslice__(self, i, j):
        return _gridpp.DoubleVector2___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _gridpp.DoubleVector2___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _gridpp.DoubleVector2___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _gridpp.DoubleVector2___delitem__(self, *args)

    def __getitem__(self, *args):
        return _gridpp.DoubleVector2___getitem__(self, *args)

    def __setitem__(self, *args):
        return _gridpp.DoubleVector2___setitem__(self, *args)

    def pop(self):
        return _gridpp.DoubleVector2_pop(self)

    def append(self, x):
        return _gridpp.DoubleVector2_append(self, x)

    def empty(self):
        return _gridpp.DoubleVector2_empty(self)

    def size(self):
        return _gridpp.DoubleVector2_size(self)

    def swap(self, v):
        return _gridpp.DoubleVector2_swap(self, v)

    def begin(self):
        return _gridpp.DoubleVector2_begin(self)

    def end(self):
        return _gridpp.DoubleVector2_end(self)

    def rbegin(self):
        return _gridpp.DoubleVector2_rbegin(self)

    def rend(self):
        return _gridpp.DoubleVector2_rend(self)

    def clear(self):
        return _gridpp.DoubleVector2_clear(self)

    def get_allocator(self):
        return _gridpp.DoubleVector2_get_allocator(self)

    def pop_back(self):
        return _gridpp.DoubleVector2_pop_back(self)

    def erase(self, *args):
        return _gridpp.DoubleVector2_erase(self, *args)

    def __init__(self, *args):
        _gridpp.DoubleVector2_swiginit(self, _gridpp.new_DoubleVector2(*args))

    def push_back(self, x):
        return _gridpp.DoubleVector2_push_back(self, x)

    def front(self):
        return _gridpp.DoubleVector2_front(self)

    def back(self):
        return _gridpp.DoubleVector2_back(self)

    def assign(self, n, x):
        return _gridpp.DoubleVector2_assign(self, n, x)

    def resize(self, *args):
        return _gridpp.DoubleVector2_resize(self, *args)

    def insert(self, *args):
        return _gridpp.DoubleVector2_insert(self, *args)

    def reserve(self, n):
        return _gridpp.DoubleVector2_reserve(self, n)

    def capacity(self):
        return _gridpp.DoubleVector2_capacity(self)
    __swig_destroy__ = _gridpp.delete_DoubleVector2

# Register DoubleVector2 in _gridpp:
_gridpp.DoubleVector2_swigregister(DoubleVector2)

GRIDPP_VERSION = _gridpp.GRIDPP_VERSION
__version__ = _gridpp.__version__
OneToOne = _gridpp.OneToOne
r""" Continue past the end-points using a slope of 1"""
MeanSlope = _gridpp.MeanSlope
r""" Continue past the end-points using the mean slope of the curve"""
NearestSlope = _gridpp.NearestSlope
r""" Continue past the end-points using the slope of the two lowermost or uppermost points in the curve"""
Zero = _gridpp.Zero
r""" Continue past the end-points using a slope of 0"""
Mean = _gridpp.Mean
r""" Mean of values"""
Min = _gridpp.Min
r""" Minimum of values"""
Median = _gridpp.Median
r""" Mean of values"""
Max = _gridpp.Max
r""" Maximum of values"""
Quantile = _gridpp.Quantile
r""" A quantile from values"""
Std = _gridpp.Std
r""" Standard deviation of values"""
Variance = _gridpp.Variance
r""" Population variance of values"""
Sum = _gridpp.Sum
r""" Sum of values"""
Unknown = _gridpp.Unknown
r""" Unknown statistic"""
Ets = _gridpp.Ets
r""" Equitable threat score"""
Ts = _gridpp.Ts
r""" Threat score"""
Kss = _gridpp.Kss
r""" Hannsen-Kuiper skill score"""
Pc = _gridpp.Pc
r""" Proportion correct"""
Bias = _gridpp.Bias
r""" Bias"""
Hss = _gridpp.Hss
r""" Heidke skill score"""
Qq = _gridpp.Qq
r""" Quantile mapping"""
Multiplicative = _gridpp.Multiplicative
r""" Multiplicative"""
Additive = _gridpp.Additive
r""" Additive"""
Geodetic = _gridpp.Geodetic
r""" Latitude and longitude"""
Cartesian = _gridpp.Cartesian
r""" X and Y"""

def optimal_interpolation(*args):
    r"""
    *Overload 1:*
    Optimal interpolation for a deterministic gridded field
    :type bgrid: :py:class:`Grid`
    :param bgrid: Grid of background field
    :type background: :py:class:`vec2`
    :param background: 2D field of background values
    :type points: :py:class:`Points`
    :param points: Points of observations
    :type pobs: :py:class:`vec`
    :param pobs: Vector of observations
    :type pratios: :py:class:`vec`
    :param pratios: Vector of ratio of observation error variance to background variance
    :type pbackground: :py:class:`vec`
    :param pbackground: Background with observation operator
    :type structure: :py:class:`StructureFunction`
    :param structure: Structure function
    :type max_points: int
    :param max_points: Maximum number of observations to use inside localization zone; Use 0 to disable

    |

    *Overload 2:*
     Optimal interpolation for a deterministic vector of points
    :type bpoints: :py:class:`Points`
    :param bpoints: Points of background field
    :type background: :py:class:`vec`
    :param background: 1D field of background values
    :type points: :py:class:`Points`
    :param points: Points of observations
    :type pobs: :py:class:`vec`
    :param pobs: Vector of observations
    :type pratios: :py:class:`vec`
    :param pratios: Vector of ratio of observation error variance to background variance
    :type pbackground: :py:class:`vec`
    :param pbackground: Background with observation operator
    :type structure: :py:class:`StructureFunction`
    :param structure: Structure function
    :type max_points: int
    :param max_points: Maximum number of observations to use inside localization zone; Use 0 to disable
    """
    return _gridpp.optimal_interpolation(*args)

def optimal_interpolation_transform(*args):
    return _gridpp.optimal_interpolation_transform(*args)

def optimal_interpolation_ensi(*args):
    return _gridpp.optimal_interpolation_ensi(*args)

def fill(igrid, input, points, radii, value, outside):
    r"""
     Fill in values inside or outside a set of circles
    :type input: :py:class:`vec2`
    :param input: Deterministic values with dimensions Y, X
    :type radii: :py:class:`vec`
    :param radii: Circle radii for each point
    :type value: float
    :param value: Fill in this value
    :type outside: boolean
    :param outside: if True, fill outside circles, if False, fill inside circles
    """
    return _gridpp.fill(igrid, input, points, radii, value, outside)

def neighbourhood(*args):
    r"""
    *Overload 1:*
    Spatial neighbourhood filter, computing a statistic for a sliding square window
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type statistic: int
    :param statistic: Statistic to compute

    |

    *Overload 2:*
     Spatial neighbourhood filter for an ensemble of fields
    :type input: :py:class:`vec3`
    :param input: 3D grid of values with dimensions (Y, X, E)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type statistic: int
    :param statistic: Statistic to compute
    """
    return _gridpp.neighbourhood(*args)

def neighbourhood_quantile(*args):
    r"""
    *Overload 1:*
     Computes a quantile in a sliding square neighbourhood
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints

    |

    *Overload 2:*
     Computes a quantile in a sliding square neighbourhood for an ensemble of fields
    :type input: :py:class:`vec3`
    :param input: 3D grid of values with dimensions (Y, X, E)
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    """
    return _gridpp.neighbourhood_quantile(*args)

def neighbourhood_quantile_fast(*args):
    r"""
    *Overload 1:*
     Fast and approximate neighbourhood quantile
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value

    |

    *Overload 2:*
     Fast and approximate neighbourhood quantile for ensemble of fields
    :type input: :py:class:`vec3`
    :param input: 3D grid of values with dimensions (Y, X, E)
    :type quantile: float
    :param quantile: Quantile to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value

    |

    *Overload 3:*
     Fast and approximate neighbourhood quantile, with spatially varying quantile
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type quantile: :py:class:`vec2`
    :param quantile: 2D grid quantiles to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value

    |

    *Overload 4:*
     Fast and approximate neighbourhood quantile for ensemble of fields, with spatially varying quantile
    :type input: :py:class:`vec3`
    :param input: 3D grid of values with dimensions (Y, X, E)
    :type quantile: :py:class:`vec2`
    :param quantile: 2D grid quantiles to compute (between 0 and 1)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :type thresholds: :py:class:`vec`
    :param thresholds: Vector of thresholds to use to approximate value
    """
    return _gridpp.neighbourhood_quantile_fast(*args)

def neighbourhood_brute_force(*args):
    r"""
    *Overload 1:*
     Spatial neighbourhood filter without any shortcuts. This is quite slow and is only useful for testing.
    :type input: :py:class:`vec2`
    :param input: 2D grid of values
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :param operation: one of min, mean, median, max

    |

    *Overload 2:*
     Spatial neighbourhood filter without any shortcuts. This is quite slow and is only useful for testing.
    :type input: :py:class:`vec3`
    :param input: 3D grid of values with dimensions (Y, X, E)
    :type halfwidth: int
    :param halfwidth: Filter halfwidth in number of gridpoints
    :param operation: one of min, mean, median, max
    """
    return _gridpp.neighbourhood_brute_force(*args)

def get_neighbourhood_thresholds(*args):
    r"""
    *Overload 1:*
     Calculate appropriate approximation thresholds for neighbourhood quantile
    :type input: :py:class:`vec2`
    :param input: 2D (Y, X) array of values
    :type num_thresholds: int
    :param num_thresholds: Number of thresholds

    |

    *Overload 2:*
     Calculate appropriate approximation thresholds for neighbourhood quantile based on an * ensemble
    :type input: :py:class:`vec3`
    :param input: 3D (Y, X, T) array of values
    :type num_thresholds: int
    :param num_thresholds: Number of thresholds
    """
    return _gridpp.get_neighbourhood_thresholds(*args)

def neighbourhood_ens(input, halfwidth, statistic):
    r"""
     Deprecated: Compute neighbourhood statistic on ensemble field
    Deprecated: Use neighbourhood() function
    """
    return _gridpp.neighbourhood_ens(input, halfwidth, statistic)

def neighbourhood_quantile_ens(input, quantile, halfwidth):
    r"""
     Deprecated: Compute neighbourhood quantiles on ensemble field
    Deprecated: Use neighbourhood_quantile() function
    """
    return _gridpp.neighbourhood_quantile_ens(input, quantile, halfwidth)

def neighbourhood_quantile_ens_fast(input, quantile, radius, thresholds):
    r"""
     Deprecated: Compute neighbourhood quantiles fast on ensemble field
    Deprecated: Use neighbourhood_quantile_fast() function
    """
    return _gridpp.neighbourhood_quantile_ens_fast(input, quantile, radius, thresholds)

def quantile_mapping_curve(*args):
    r"""
    Create quantile mapping calibration curve
     :type ref: :py:class:`vec`
     :param ref: Reference values (observations)
     :type fcst: :py:class:`vec`
     :param fcst: Forecast values
     :type quantiles: :py:class:`vec`
     :param quantiles: Vector of quantiles to extract. If empty, use all values.
     :rtype: :py:class:`vec2`
     :return: Calibration curve
    """
    return _gridpp.quantile_mapping_curve(*args)

def metric_optimizer_curve(ref, fcst, thresholds, metric):
    r"""
    Create calibration curve that optimizes a metric
    :type ref: :py:class:`vec`
    :param ref: Reference values (observations)
    :type fcst: :py:class:`vec`
    :param fcst: Forecast values
    :type thresholds: :py:class:`vec`
    :param thresholds: Thresholds for computing optimal values for
    :type metric: int
    :param metric: A Metric to optimize for
    :rtype: :py:class:`vec2`
    :return: Calibration curve
    """
    return _gridpp.metric_optimizer_curve(ref, fcst, thresholds, metric)

def apply_curve(*args):
    r"""
    *Overload 1:*
    Apply arbitrary calibration curve to 1D forecasts
    :type fcst: :py:class:`vec`
    :param fcst: 1D vector of forecast values
    :type curve: :py:class:`vec2`
    :param curve: Calibration curve
    :type policy_below: int
    :param policy_below: Extrapolation policy below curve
    :type policy_above: int
    :param policy_above: Extrapolation policy above curve
    :rtype: :py:class:`vec`
    :return: Calibrated forecasts

    |

    *Overload 2:*
    Apply arbitrary calibration curve to 2D forecasts
    :type fcst: :py:class:`vec2`
    :param fcst: 2D grid of forecast values
    :type curve: :py:class:`vec2`
    :param curve: Calibration curve
    :type policy_below: int
    :param policy_below: Extrapolation policy below curve
    :type policy_above: int
    :param policy_above: Extrapolation policy above curve
    :rtype: :py:class:`vec2`
    :return: Calibrated forecasts
    """
    return _gridpp.apply_curve(*args)

def monotonize_curve(curve):
    r"""
    Ensure calibration curve is monotonic, by removing points
    :type curve: :py:class:`vec2`
    :param curve: Calibration curve
    :rtype: :py:class:`vec2`
    :return: Monotonic calibration curve
    """
    return _gridpp.monotonize_curve(curve)

def get_optimal_threshold(ref, fcst, threshold, metric):
    return _gridpp.get_optimal_threshold(ref, fcst, threshold, metric)

def calc_score(*args):
    return _gridpp.calc_score(*args)

def correction(*args):
    return _gridpp.correction(*args)

def nearest(*args):
    return _gridpp.nearest(*args)

def bilinear(*args):
    r"""
    *Overload 1:*
     Bilinear downscaling grid to grid
    :type igrid: :py:class:`Grid`
    :param igrid: Input grid
    :type ogrid: :py:class:`Grid`
    :param ogrid: Output grid to downscale to
    :type ivalues: :py:class:`vec2`
    :param ivalues: 2D vector of values on the input grid
    :rtype: :py:class:`vec2`
    :return: Values on the output grid

    |

    *Overload 2:*
     Bilinear downscaling grid to points
    :type igrid: :py:class:`Grid`
    :param igrid: Input grid
    :param ogrid: Output points to downscale to
    :type ivalues: :py:class:`vec2`
    :param ivalues: 2D vector of values on the input grid
    :rtype: :py:class:`vec`
    :return: Values for the output points
    """
    return _gridpp.bilinear(*args)

def simple_gradient(*args):
    return _gridpp.simple_gradient(*args)

def smart(igrid, ogrid, ivalues, num, structure):
    r"""
     Smart neighbour downscaling grid to grid
    :type igrid: :py:class:`Grid`
    :param igrid: Input grid
    :type ogrid: :py:class:`Grid`
    :param ogrid: Output points to downscale to
    :type ivalues: :py:class:`vec2`
    :param ivalues: 2D vector of values on the input grid
    :type num: int
    :param num: Number of neighbours to average
    :type structure: :py:class:`StructureFunction`
    :param structure: Structure function for determining similarity
    :rtype: :py:class:`vec2`
    :return: Values for the output points
    """
    return _gridpp.smart(igrid, ogrid, ivalues, num, structure)

def count(*args):
    r"""
    *Overload 1:*
    For each point, counts the number of gridpoints within the radius
     :type grid: :py:class:`Grid`
     :param grid: Grid
     :type points: :py:class:`Points`
     :param points: Points
     :type radius: float
     :param radius: Radius [m]
     :rtype: :py:class:`vec`
     :return: Number of gridpoints

    |

    *Overload 2:*
     For each gridpoint, counts the number of points within the radius
     :type grid: :py:class:`Grid`
     :param grid: Grid
     :type points: :py:class:`Points`
     :param points: Points
     :type radius: float
     :param radius: Radius [m]
     :rtype: :py:class:`vec2`
     :return: Number of points
    """
    return _gridpp.count(*args)

def distance(*args):
    r"""
    *Overload 1:*
    For each point, calculates the distance to nearest gridpoint
    :type grid: :py:class:`Grid`
    :param grid: Grid
    :type points: :py:class:`Points`
    :param points: Points
    :type num: int
    :param num: Number of points
    :rtype: :py:class:`vec`
    :return: Distance [m] to nearest gridpoint for each point

    |

    *Overload 2:*
    For each output gridpoint, calculate the distance to nearest input gridpoint
    :param grid: Grid
    :type ogrid: :py:class:`Grid`
    :param ogrid: Output grid
    :type num: int
    :param num: Number of points
    :rtype: :py:class:`vec2`
    :return: Distance [m] to nearest gridpoint for each gridpoint

    |

    *Overload 3:*
    For each output gridpoint, calculate the distance to nearest input gridpoint
    :param grid: Grid
    :type ogrid: :py:class:`Grid`
    :param ogrid: Output grid
    :param num: Number of points
    :rtype: :py:class:`vec2`
    :return: Distance [m] to nearest gridpoint for each gridpoint

    |

    *Overload 4:*
    For each gridpoint, calculates the distance to nearest point
    :type points: :py:class:`Points`
    :param points: Points
    :type grid: :py:class:`Grid`
    :param grid: Grid
    :type num: int
    :param num: Number of points
    :rtype: :py:class:`vec2`
    :return: Distance [m] to nearest gridpoint for each point

    |

    *Overload 5:*
    For each gridpoint, calculates the distance to nearest point
    :type points: :py:class:`Points`
    :param points: Points
    :type grid: :py:class:`Grid`
    :param grid: Grid
    :param num: Number of points
    :rtype: :py:class:`vec2`
    :return: Distance [m] to nearest gridpoint for each point
    """
    return _gridpp.distance(*args)

def fill_missing(values):
    r"""
     Fill in missing values based on nearby values
    :type values: :py:class:`vec2`
    :param values: 2D array of values
    :rtype: :py:class:`vec2`
    :return: 2D array of values without any missing values
    """
    return _gridpp.fill_missing(values)

def gridding(grid, points, values, radius, min_num, statistic):
    r"""
     Aggregate points onto a grid. Writes MV where there are not enough observations
    :type grid: :py:class:`Grid`
    :param grid: Grid to aggregate to
    :type points: :py:class:`Points`
    :param points: Points with values
    :type values: :py:class:`vec`
    :param values: Values at points
    :type radius: float
    :param radius: Circle radius for aggregate points [m]
    :type min_num: int
    :param min_num: Minimum number of points in radius to create a value
    :type statistic: int
    :param statistic: Statistic to compute on points within radius
    """
    return _gridpp.gridding(grid, points, values, radius, min_num, statistic)

def dewpoint(*args):
    r"""
    *Overload 1:*
    Calculate dewpoint temperature from temperature and relative humidity
     :type temperature: float
     :param temperature: Temperature [K]
     :type relative_humidity: float
     :param relative_humidity: Relative humidity [1]
     :rtype: float
     :return: Dewpoint temperature [K]

    |

    *Overload 2:*
     Vector version of dewpoint calculation
     :type temperature: :py:class:`vec`
     :param temperature: Temperatures [K]
     :type relative_humidity: :py:class:`vec`
     :param relative_humidity: Relative humidities [1]
     :rtype: :py:class:`vec`
     :return: Dewpoint temperatures [K]
    """
    return _gridpp.dewpoint(*args)

def pressure(*args):
    r"""
    *Overload 1:*
    Calculate pressure at a new elevation
    :type ielev: float
    :param ielev: Elevation at start point
    :type oelev: float
    :param oelev: Elevation at new point
    :type ipressure: float
    :param ipressure: Pressure at start point
    :type itemperature: float
    :param itemperature: Temperature at start point
    :rtype: float
    :return: Pressure at new point

    |

    *Overload 2:*
    Calculate Vector version of pressure calculation
    :type ielev: :py:class:`vec`
    :param ielev: Elevations at start point
    :type oelev: :py:class:`vec`
    :param oelev: Elevations at new point
    :type ipressure: :py:class:`vec`
    :param ipressure: Pressures at start point
    :type itemperature: :py:class:`vec`
    :param itemperature: Temperatures at start point
    :rtype: :py:class:`vec`
    :return: Pressures at new points
    """
    return _gridpp.pressure(*args)

def qnh(*args):
    r"""
    *Overload 1:*
    Diagnose QNH from pressure and altitude
    :type pressure: float
    :param pressure: Pressure at point [pa]
    :type altitude: float
    :param altitude: Altitude of point [m]
    :rtype: float
    :return: QNH [pa]

    |

    *Overload 2:*
    Vector version of QNH calculation
    :type pressure: :py:class:`vec`
    :param pressure: Pressures at points [pa]
    :type altitude: :py:class:`vec`
    :param altitude: Altitudes of points [m]
    :rtype: :py:class:`vec`
    :return: QNH [pa]
    """
    return _gridpp.qnh(*args)

def relative_humidity(*args):
    r"""
    *Overload 1:*
    Calculate relative humidity from temperature and dewpoint temperature
    :type temperature: float
    :param temperature: Temperature [K]
    :type dewpoint: float
    :param dewpoint: Dewpoint temperature [K]
    :rtype: float
    :return: Relative humidity [1]

    |

    *Overload 2:*
    Vector version of relative humidity calculation
    :type temperature: :py:class:`vec`
    :param temperature: Temperatures [K]
    :type dewpoint: :py:class:`vec`
    :param dewpoint: Dewpoint temperatures [K]
    :rtype: :py:class:`vec`
    :return: Relative humidities [1]
    """
    return _gridpp.relative_humidity(*args)

def wetbulb(*args):
    r"""
    *Overload 1:*
    Calculate wetbulb temperature from temperature, pressure, and relative humidity
    :type temperature: float
    :param temperature: Temperature [K]
    :type pressure: float
    :param pressure: Air pressure [pa]
    :param Relative: humidity [1]
    :rtype: float
    :return: Wetbulb temperature [K]

    |

    *Overload 2:*
    Vector version of wetbulb calculation
    :type temperature: :py:class:`vec`
    :param temperature: Temperatures [K]
    :type pressure: :py:class:`vec`
    :param pressure: Air pressures [pa]
    :param Relative: humidities [1]
    :rtype: :py:class:`vec`
    :return: Wetbulb temperatures [K]
    """
    return _gridpp.wetbulb(*args)

def wind_speed(*args):
    r"""
    *Overload 1:*
    Diagnose wind speed from its components
    :type xwind: float
    :param xwind: X-component of wind [any unit]
    :type ywind: float
    :param ywind: Y-component of wind [any unit]
    :rtype: float
    :return: Wind speed [any unit]


    |

    *Overload 2:*
    Vector version of wind speed calculation
    :type xwind: :py:class:`vec`
    :param xwind: X-components of wind [any unit]
    :type ywind: :py:class:`vec`
    :param ywind: Y-components of wind [any unit]
    :rtype: :py:class:`vec`
    :return: Wind speeds [any unit]
    """
    return _gridpp.wind_speed(*args)

def wind_direction(*args):
    r"""
    *Overload 1:*
    Diagnose wind direction from its components. If both xwind and ywind are 0, then direction
    is 180
    :type xwind: float
    :param xwind: X-component of wind [any unit]
    :type ywind: float
    :param ywind: Y-component of wind [any unit]
    :rtype: float
    :return: Wind direction [degrees]


    |

    *Overload 2:*
    Vector version of wind direction calculation
    :type xwind: :py:class:`vec`
    :param xwind: X-components of wind [any unit]
    :type ywind: :py:class:`vec`
    :param ywind: Y-components of wind [any unit]
    :rtype: :py:class:`vec`
    :return: Wind direction [degrees]
    """
    return _gridpp.wind_direction(*args)

def set_omp_threads(num):
    r"""Set the number of OpenMP threads to use. Overwrides OMP_NUM_THREAD env variable."""
    return _gridpp.set_omp_threads(num)

def initialize_omp():
    r""" Sets the number of OpenMP threads to 1 if OMP_NUM_THREADS undefined"""
    return _gridpp.initialize_omp()

def get_statistic(name):
    r"""Convert name of a statistic enum"""
    return _gridpp.get_statistic(name)

def version():
    r"""
     The gridpp version
    :rtype: string
    :return: The gridpp version
    """
    return _gridpp.version()

def clock():
    return _gridpp.clock()

def debug(string):
    return _gridpp.debug(string)

def warning(string):
    return _gridpp.warning(string)

def error(string):
    return _gridpp.error(string)

def future_deprecation_warning(*args):
    return _gridpp.future_deprecation_warning(*args)

def is_valid(value):
    return _gridpp.is_valid(value)

def calc_statistic(*args):
    return _gridpp.calc_statistic(*args)

def calc_quantile(*args):
    return _gridpp.calc_quantile(*args)

def num_missing_values(iArray):
    return _gridpp.num_missing_values(iArray)

def get_lower_index(iX, iValues):
    r"""
    Find the index in a vector that is equal or just below a value
    :type iX: float
    :param iX: Lookup value
    :type iValues: std::vector< float,std::allocator< float > >
    :param iValues: Lookup vector. Must be sorted.
    :rtype: int
    :return: The index into iValues that is equal or just below iX
    """
    return _gridpp.get_lower_index(iX, iValues)

def get_upper_index(iX, iValues):
    r"""
    Find the index in a vector that is equal or just above a value
    :type iX: float
    :param iX: Lookup value
    :type iValues: std::vector< float,std::allocator< float > >
    :param iValues: Lookup vector. Must be sorted.
    :rtype: int
    :return: The index into iValues that is equal or just above iX
    """
    return _gridpp.get_upper_index(iX, iValues)

def interpolate(x, iX, iY):
    r"""
    Piecewise linear interpolation
    If x is outside the range of iX, then the min/max value of iY is used
    :type x: float
    :param x: Interpolation to this point
    :type iX: std::vector< float,std::allocator< float > >
    :param iX: Vector of x-axis values. Vector must be sorted.
    :type iY: std::vector< float,std::allocator< float > >
    :param iY: Vector of y-axis values corresponding to iX.
    :rtype: float
    :return: Y value corresponding to x
    """
    return _gridpp.interpolate(x, iX, iY)

def init_ivec2(Y, X, value):
    r""" Initialize a vector of size Y, X, with a given value"""
    return _gridpp.init_ivec2(Y, X, value)

def init_vec2(*args):
    return _gridpp.init_vec2(*args)

def init_ivec3(Y, X, E, value):
    r""" Initialize a vector of size Y, X, E, with a given value"""
    return _gridpp.init_ivec3(Y, X, E, value)

def init_vec3(*args):
    return _gridpp.init_vec3(*args)

def calc_even_quantiles(values, num):
    r"""
    Get reasonably spaced quantiles from a vector of values, ignoring duplicate values
    but including the first number after duplicated values. Include the lowest and highest
    values.
    :type values: :py:class:`vec`
    :param values: vector of values (unsorted, and no invalid values)
    :type num: int
    :param num: number of thresholds to get
    """
    return _gridpp.calc_even_quantiles(values, num)

def calc_gradient(grid, base, values, radius, min_num=2, min_range=0, default_gradient=0):
    r"""
    Computes gradients based on values in neighbourhood
    :type grid: :py:class:`Grid`
    :param grid: Grid
    :type base: :py:class:`vec2`
    :param base: Dependent variable. Missing values are not used.
    :type values: :py:class:`vec2`
    :param values: Independent variable. Missing values are not used.
    :type radius: int
    :param radius: Neighbourhood radius in number of gridpoints
    :param min_nim: Minimum number of points required to compute gradient
    :type min_range: float
    :param min_range: Minimum range of base to compute gradient
    :type default_gradient: float
    :param default_gradient: Use this gradient if minimum number is not met
    """
    return _gridpp.calc_gradient(grid, base, values, radius, min_num, min_range, default_gradient)

def compatible_size(*args):
    return _gridpp.compatible_size(*args)

def point_in_rectangle(A, B, C, D, m):
    r"""
     Checks if a point is located inside a rectangle formed by 4 points. The 4 points must be
    provided in an order that draws out a rectangle (either clockwise or counter-clockwise)
    :type A: :py:class:`Point`
    :param A:: A point in the rectangle
    :type B: :py:class:`Point`
    :param B:: A point in the rectangle
    :type C: :py:class:`Point`
    :param C:: A point in the rectangle
    :type D: :py:class:`Point`
    :param D:: A point in the rectangle
    :type m: :py:class:`Point`
    :param m:: The point to test if it is inside
    :rtype: boolean
    :return: True if the point is inside, False otherwise
    """
    return _gridpp.point_in_rectangle(A, B, C, D, m)

def test_array(v):
    r"""Special function whose presense is needed for SWIG"""
    return _gridpp.test_array(v)

def test_vec_input(input):
    r""" Testing function for 1D input vector"""
    return _gridpp.test_vec_input(input)

def test_ivec_input(input):
    r""" Testing function for 1D input vector"""
    return _gridpp.test_ivec_input(input)

def test_vec2_input(input):
    r""" Testing function for 2D input vector"""
    return _gridpp.test_vec2_input(input)

def test_vec3_input(input):
    r""" Testing function for 3D input vector"""
    return _gridpp.test_vec3_input(input)

def test_vec_output():
    r""" Testing function for 1D output vector"""
    return _gridpp.test_vec_output()

def test_ivec_output():
    return _gridpp.test_ivec_output()

def test_vec2_output():
    r""" Testing function for 2D output vector"""
    return _gridpp.test_vec2_output()

def test_ivec2_output():
    return _gridpp.test_ivec2_output()

def test_vec3_output():
    r""" Testing function for 3D output vector"""
    return _gridpp.test_vec3_output()

def test_ivec3_output():
    return _gridpp.test_ivec3_output()

def test_vec_argout():
    r""" Testing function for 1D vector treated as output"""
    return _gridpp.test_vec_argout()

def test_vec2_argout():
    r""" Testing function for 2D vector treated as output"""
    return _gridpp.test_vec2_argout()

def test_not_implemented_exception():
    return _gridpp.test_not_implemented_exception()
class Point(object):
    r"""Represents a single point in some coordinate system"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
         Constructor
        :type lat: float
        :param lat:: Latitude coordinate
        :type lon: float
        :param lon:: Longitude coordinate
        :type elev: float
        :param elev:: Elevation
        :type laf: float
        :param laf:: Land area fraction (between 0 and 1)
        :type type: int
        :param type:: Coordinate type for lat and lon
        """
        _gridpp.Point_swiginit(self, _gridpp.new_Point(*args))
    lat = property(_gridpp.Point_lat_get, _gridpp.Point_lat_set)
    lon = property(_gridpp.Point_lon_get, _gridpp.Point_lon_set)
    elev = property(_gridpp.Point_elev_get, _gridpp.Point_elev_set)
    laf = property(_gridpp.Point_laf_get, _gridpp.Point_laf_set)
    type = property(_gridpp.Point_type_get, _gridpp.Point_type_set)
    __swig_destroy__ = _gridpp.delete_Point

# Register Point in _gridpp:
_gridpp.Point_swigregister(Point)
cvar = _gridpp.cvar
MV = cvar.MV
MV_CML = cvar.MV_CML
pi = cvar.pi
radius_earth = cvar.radius_earth
swig_default_value = cvar.swig_default_value

class StructureFunction(object):
    r""" Covariance structure function"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def corr(self, p1, p2):
        r""" Correlation between two points"""
        return _gridpp.StructureFunction_corr(self, p1, p2)

    def corr_background(self, p1, p2):
        return _gridpp.StructureFunction_corr_background(self, p1, p2)

    def localization_distance(self):
        r"""
         Maximum distance for which an observation can have an impact (localization)
        :rtype: float
        :return: Distance [m]
        """
        return _gridpp.StructureFunction_localization_distance(self)

    def clone(self):
        return _gridpp.StructureFunction_clone(self)
    __swig_destroy__ = _gridpp.delete_StructureFunction

# Register StructureFunction in _gridpp:
_gridpp.StructureFunction_swigregister(StructureFunction)

class BarnesStructure(StructureFunction):
    r""" Simple structure function based on distance, elevation, and land area fraction"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
         Exponential structure function
        :type h: float
        :param h:: Horizontal decorrelation length >=0 [m]
        :type v: float
        :param v:: Vertical decorrelation length >=0 [m]. If 0, disable decorrelation.
        :type w: float
        :param w:: Land/sea decorrelation length >=0 [1]. If 0, disable decorrelation.
        :type hmax: float
        :param hmax:: Truncate horizontal correlation beyond this length [m]. If undefined, 3.64 * h.
        """
        _gridpp.BarnesStructure_swiginit(self, _gridpp.new_BarnesStructure(*args))

    def corr(self, p1, p2):
        return _gridpp.BarnesStructure_corr(self, p1, p2)

    def clone(self):
        return _gridpp.BarnesStructure_clone(self)
    __swig_destroy__ = _gridpp.delete_BarnesStructure

# Register BarnesStructure in _gridpp:
_gridpp.BarnesStructure_swigregister(BarnesStructure)

class CressmanStructure(StructureFunction):
    r""" Simple structure function based on distance, elevation, and land area fraction"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, h, v=0, w=0):
        _gridpp.CressmanStructure_swiginit(self, _gridpp.new_CressmanStructure(h, v, w))

    def corr(self, p1, p2):
        return _gridpp.CressmanStructure_corr(self, p1, p2)

    def clone(self):
        return _gridpp.CressmanStructure_clone(self)
    __swig_destroy__ = _gridpp.delete_CressmanStructure

# Register CressmanStructure in _gridpp:
_gridpp.CressmanStructure_swigregister(CressmanStructure)

class CrossValidation(StructureFunction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
         Structure function for performing cross validation experiments
        :type dist: float
        :param dist:: Force background-to-obs correlation to 0 for points within
              this distance [m]. If MV, disable this.
        """
        _gridpp.CrossValidation_swiginit(self, _gridpp.new_CrossValidation(*args))

    def corr(self, p1, p2):
        return _gridpp.CrossValidation_corr(self, p1, p2)

    def corr_background(self, p1, p2):
        return _gridpp.CrossValidation_corr_background(self, p1, p2)

    def clone(self):
        return _gridpp.CrossValidation_clone(self)
    __swig_destroy__ = _gridpp.delete_CrossValidation

# Register CrossValidation in _gridpp:
_gridpp.CrossValidation_swigregister(CrossValidation)

class Transform(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def forward(self, *args):
        return _gridpp.Transform_forward(self, *args)

    def backward(self, *args):
        return _gridpp.Transform_backward(self, *args)

    def __init__(self):
        _gridpp.Transform_swiginit(self, _gridpp.new_Transform())
    __swig_destroy__ = _gridpp.delete_Transform

# Register Transform in _gridpp:
_gridpp.Transform_swigregister(Transform)

class Identity(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def forward(self, *args):
        return _gridpp.Identity_forward(self, *args)

    def backward(self, *args):
        return _gridpp.Identity_backward(self, *args)

    def __init__(self):
        _gridpp.Identity_swiginit(self, _gridpp.new_Identity())
    __swig_destroy__ = _gridpp.delete_Identity

# Register Identity in _gridpp:
_gridpp.Identity_swigregister(Identity)

class Log(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def forward(self, *args):
        return _gridpp.Log_forward(self, *args)

    def backward(self, *args):
        return _gridpp.Log_backward(self, *args)

    def __init__(self):
        _gridpp.Log_swiginit(self, _gridpp.new_Log())
    __swig_destroy__ = _gridpp.delete_Log

# Register Log in _gridpp:
_gridpp.Log_swigregister(Log)

class BoxCox(Transform):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, threshold):
        _gridpp.BoxCox_swiginit(self, _gridpp.new_BoxCox(threshold))

    def forward(self, *args):
        return _gridpp.BoxCox_forward(self, *args)

    def backward(self, *args):
        return _gridpp.BoxCox_backward(self, *args)
    __swig_destroy__ = _gridpp.delete_BoxCox

# Register BoxCox in _gridpp:
_gridpp.BoxCox_swigregister(BoxCox)

class KDTree(object):
    r""" Helper class for Grid and Points"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.KDTree_swiginit(self, _gridpp.new_KDTree(*args))

    def get_nearest_neighbour(self, lat, lon):
        r"""
        Find single nearest points
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        """
        return _gridpp.KDTree_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        r"""
        Find all points with a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        """
        return _gridpp.KDTree_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius):
        r"""
        Find all points with a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        :type distances: :py:class:`vec`
        :param distances: Vector to store separation distances [m]
        """
        return _gridpp.KDTree_get_neighbours_with_distance(self, lat, lon, radius)

    def get_num_neighbours(self, lat, lon, radius):
        r"""
        Find the number of points within a radius
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type radius: float
        :param radius: Lookup radius [m]
        """
        return _gridpp.KDTree_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        r"""
        Find a set of nearest points
        :type lat: float
        :param lat: Latitude of lookup-point
        :type lon: float
        :param lon: Longitude of lookup-point
        :type num: int
        :param num: Number of points to find
        """
        return _gridpp.KDTree_get_closest_neighbours(self, lat, lon, num)

    def convert_coordinates(self, *args):
        r"""
        *Overload 1:*
        Convert lat/lons to 3D cartesian coordinates with the centre of the earth as the origin
        :type lats: :py:class:`vec`
        :param lats: vector of latitudes [deg]
        :type lons: :py:class:`vec`
        :param lons: vector of longitudes [deg]
        :type x_coords: :py:class:`vec`
        :param x_coords: vector of x-coordinates [m]
        :type y_coords: :py:class:`vec`
        :param y_coords: vector of y-coordinates [m]
        :type z_coords: :py:class:`vec`
        :param z_coords: vector of z-coordinates [m]


        |

        *Overload 2:*
        Same as above, but convert a single lat/lon to 3D cartesian coordinates
        :type lat: float
        :param lat: latitude [deg]
        :type lon: float
        :param lon: longitude [deg]
        :type x_coord: float
        :param x_coord: x-coordinate [m]
        :type y_coord: float
        :param y_coord: y-coordinate [m]
        :type z_coord: float
        :param z_coord: z-coordinate [m]
        """
        return _gridpp.KDTree_convert_coordinates(self, *args)

    @staticmethod
    def deg2rad(deg):
        return _gridpp.KDTree_deg2rad(deg)

    @staticmethod
    def rad2deg(deg):
        return _gridpp.KDTree_rad2deg(deg)

    @staticmethod
    def calc_distance(*args):
        return _gridpp.KDTree_calc_distance(*args)

    @staticmethod
    def calc_distance_fast(*args):
        return _gridpp.KDTree_calc_distance_fast(*args)

    def get_lats(self):
        return _gridpp.KDTree_get_lats(self)

    def get_lons(self):
        return _gridpp.KDTree_get_lons(self)

    def size(self):
        return _gridpp.KDTree_size(self)

    def get_coordinate_type(self):
        return _gridpp.KDTree_get_coordinate_type(self)
    __swig_destroy__ = _gridpp.delete_KDTree

# Register KDTree in _gridpp:
_gridpp.KDTree_swigregister(KDTree)

def KDTree_deg2rad(deg):
    return _gridpp.KDTree_deg2rad(deg)

def KDTree_rad2deg(deg):
    return _gridpp.KDTree_rad2deg(deg)

def KDTree_calc_distance(*args):
    return _gridpp.KDTree_calc_distance(*args)

def KDTree_calc_distance_fast(*args):
    return _gridpp.KDTree_calc_distance_fast(*args)

class Points(object):
    r""" Represents a vector of locations and their metadata"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _gridpp.Points_swiginit(self, _gridpp.new_Points(*args))

    def get_nearest_neighbour(self, lat, lon):
        return _gridpp.Points_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        return _gridpp.Points_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius):
        return _gridpp.Points_get_neighbours_with_distance(self, lat, lon, radius)

    def get_num_neighbours(self, lat, lon, radius):
        return _gridpp.Points_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        return _gridpp.Points_get_closest_neighbours(self, lat, lon, num)

    def get_lats(self):
        return _gridpp.Points_get_lats(self)

    def get_lons(self):
        return _gridpp.Points_get_lons(self)

    def get_elevs(self):
        return _gridpp.Points_get_elevs(self)

    def get_lafs(self):
        return _gridpp.Points_get_lafs(self)

    def size(self):
        return _gridpp.Points_size(self)

    def get_in_domain_indices(self, grid):
        return _gridpp.Points_get_in_domain_indices(self, grid)

    def get_in_domain(self, grid):
        return _gridpp.Points_get_in_domain(self, grid)

    def get_coordinate_type(self):
        return _gridpp.Points_get_coordinate_type(self)
    __swig_destroy__ = _gridpp.delete_Points

# Register Points in _gridpp:
_gridpp.Points_swigregister(Points)

class Grid(object):
    r""" Represents a 2D grid of locations and their metadata"""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        *Overload 1:*
        Initialize a new grid
        :type lats: :py:class:`vec2`
        :param lats:: 2D vector of latitudes [degrees]
        :type lons: :py:class:`vec2`
        :param lons:: 2D vector of longitudes [degrees]
        :type elevs: :py:class:`vec2`
        :param elevs:: 2D vector of elevations [m]
        :type lafs: :py:class:`vec2`
        :param lafs:: 2D vector of land area fractions [1]
        :type type: int
        :param type:: Coordinate type

        |

        *Overload 2:*
        Initialize a new grid
        :type lats: :py:class:`vec2`
        :param lats:: 2D vector of latitudes [degrees]
        :type lons: :py:class:`vec2`
        :param lons:: 2D vector of longitudes [degrees]
        :type elevs: :py:class:`vec2`
        :param elevs:: 2D vector of elevations [m]
        :type lafs: :py:class:`vec2`
        :param lafs:: 2D vector of land area fractions [1]
        :param type:: Coordinate type

        |

        *Overload 3:*
        Initialize a new grid
        :type lats: :py:class:`vec2`
        :param lats:: 2D vector of latitudes [degrees]
        :type lons: :py:class:`vec2`
        :param lons:: 2D vector of longitudes [degrees]
        :type elevs: :py:class:`vec2`
        :param elevs:: 2D vector of elevations [m]
        :param lafs:: 2D vector of land area fractions [1]
        :param type:: Coordinate type

        |

        *Overload 4:*
        Initialize a new grid
        :type lats: :py:class:`vec2`
        :param lats:: 2D vector of latitudes [degrees]
        :type lons: :py:class:`vec2`
        :param lons:: 2D vector of longitudes [degrees]
        :param elevs:: 2D vector of elevations [m]
        :param lafs:: 2D vector of land area fractions [1]
        :param type:: Coordinate type
        """
        _gridpp.Grid_swiginit(self, _gridpp.new_Grid(*args))

    def get_nearest_neighbour(self, lat, lon):
        return _gridpp.Grid_get_nearest_neighbour(self, lat, lon)

    def get_neighbours(self, lat, lon, radius):
        return _gridpp.Grid_get_neighbours(self, lat, lon, radius)

    def get_neighbours_with_distance(self, lat, lon, radius):
        return _gridpp.Grid_get_neighbours_with_distance(self, lat, lon, radius)

    def get_num_neighbours(self, lat, lon, radius):
        return _gridpp.Grid_get_num_neighbours(self, lat, lon, radius)

    def get_closest_neighbours(self, lat, lon, num):
        return _gridpp.Grid_get_closest_neighbours(self, lat, lon, num)

    def get_box(self, lat, lon):
        return _gridpp.Grid_get_box(self, lat, lon)

    def to_points(self):
        r""" Convert grid to a vector of points"""
        return _gridpp.Grid_to_points(self)

    def get_lats(self):
        return _gridpp.Grid_get_lats(self)

    def get_lons(self):
        return _gridpp.Grid_get_lons(self)

    def get_elevs(self):
        return _gridpp.Grid_get_elevs(self)

    def get_lafs(self):
        return _gridpp.Grid_get_lafs(self)

    def size(self):
        return _gridpp.Grid_size(self)

    def get_coordinate_type(self):
        return _gridpp.Grid_get_coordinate_type(self)
    __swig_destroy__ = _gridpp.delete_Grid

# Register Grid in _gridpp:
_gridpp.Grid_swigregister(Grid)

class not_implemented_exception(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _gridpp.not_implemented_exception_swiginit(self, _gridpp.new_not_implemented_exception())
    __swig_destroy__ = _gridpp.delete_not_implemented_exception

# Register not_implemented_exception in _gridpp:
_gridpp.not_implemented_exception_swigregister(not_implemented_exception)



