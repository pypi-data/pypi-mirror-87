# -*- coding: utf-8 -*-
# generate_man_pages.py - script to generate documents for commands
#
# Copyright (C) 2017 Red Hat Inc.
# Author(s): Chenxiong Qi <cqi@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

from __future__ import print_function

import argparse
import json
import logging
import os
import re
import sys

import six

logging.basicConfig(level=logging.CRITICAL)
logger = logging.getLogger('Generator')

join = os.path.join

PROJECT_ROOT = os.path.abspath(join(os.path.dirname(__file__), '..'))
sys.path.insert(0, PROJECT_ROOT)

DOC_DIR = join(PROJECT_ROOT, 'doc')
DOC_SOURCE_DIR = join(DOC_DIR, 'source')
COMMANDS_DOCS_DIR = join(DOC_SOURCE_DIR, 'commands')
MAN_PAGES_JSON_FILE = join(DOC_SOURCE_DIR, 'man_pages.json')

if not os.path.exists(COMMANDS_DOCS_DIR):
    os.mkdir(COMMANDS_DOCS_DIR)

command_option_template = '''\
.. option:: {name_metavar}

   {description}
'''

command_arguments_template = '''\
Arguments
---------

{arguments}
'''


class TemplateNotFound(Exception):
    """Custom document template file is not found"""


def read_template(name, template_dir=None):
    """Find and read template content

    :param str name: the template name. If a template file name is
        `cli.rst.tmpl`, `cli.rst` should be passed to this argument.
    :param str template_dir: a directory from where to find custom template
        file. If omitted, template file will be found from templates directory
        which is located at same place with this script.
    :return: content of the template file.
    :raises TemplateNotFound: if template file is not found.
    """
    search_dir = template_dir or join(DOC_SOURCE_DIR, 'templates')
    filename = join(search_dir, '{0}.tmpl'.format(name))
    if not os.path.exists(filename):
        raise TemplateNotFound()
    with open(filename, 'r') as f:
        return f.read()


def format_literal(s):
    """Format possible inline literal text

    For example, if string contains text --some-option, it will be formatted
    to ``--some-option``.
    """
    regex = '(--[a-z]+(-[a-z]+)+)'
    return re.sub(regex, r'``\1``', s)


def generate_man_pages_list_file(parser, cli_subparsers, app_manpage_subject):
    """Generate registered commands list for generating man pages

    The generated content will be written into a JSON file. Each command will
    be mapped to man page information format that sphinx requires, which is

    (source start file, name, description, authors, manual section)

    But, we don't write the forth column authors, that will be handled
    (inserted) by the piece of code inside `conf.py`.

    So, the final JSON file will contain data dumped from this structure

    [
        ('commands/{command name}', '{command name}, 'description', 1),
        ...
    ]
    """
    action_helps = dict((
        (action.dest, action.help)
        for action in cli_subparsers._get_subactions()
    ))
    man_pages_list = [
        [
            'commands/{0}'.format(parser_name),
            command_parser.prog.replace(' ', '-'),
            action_helps[parser_name],
            1
        ]
        for parser_name, command_parser in cli_subparsers.choices.items()
        if parser_name in action_helps
    ]

    # Add application manpage manually. For example, in a downstream client
    # tool built on top of rpkg, this is for running `man fedpkg`.
    man_pages_list += [
        [
            'commands/{0}'.format(parser.prog),
            parser.prog,
            app_manpage_subject,
            1
        ]
    ]

    logger.info('Write man_pages JSON file: %s',
                os.path.relpath(MAN_PAGES_JSON_FILE))
    with open(MAN_PAGES_JSON_FILE, 'w+') as f:
        json.dump(man_pages_list, f, indent=2)


def generate_command_rst_docs(cli_subparser, template_dir=None):
    """Write command document into source/commands/ directory

    Man pages and HTML pages will be generated by sphinx from this directory.

    Each document is formatted in reStructuredText.
    """
    for command_name, parser in [item for item in cli_subparser.choices.items()
                                 if item[1].add_help]:
        arguments_text = []
        options_text = []
        for action in parser._actions:
            if action.option_strings:
                # Optional arguments
                options_text.append(command_option_template.format(
                    name_metavar=' '.join(action.option_strings),
                    description=format_literal(action.help)))
            else:
                # Positional arguments
                arguments_text.append(command_option_template.format(
                    name_metavar=action.dest,
                    description=action.help,
                ))

        # We need 4 space indent for each line in usage in order to be rendered
        # in code block.
        # Meanwhile, the text "usage: " is not useful for rendering HTML and
        # man pages. So, remove it. And don't forget that besides adding
        # indent, we also have to remove 7 space characters from the second
        # line and rest.
        buf = six.moves.StringIO(parser.format_usage().strip())
        first_n_chars = len('usage: ')
        try:
            usage = ''.join([
                '    {0}'.format(line[first_n_chars:]) for line in buf
            ])
        finally:
            buf.close()

        if arguments_text:
            arguments = command_arguments_template.format(
                arguments=os.linesep.join(arguments_text))
        else:
            arguments = ''

        tmpl = read_template('command.rst', template_dir=template_dir)
        command_rst_content = tmpl.format(
            name=command_name,
            name_section_marker='=' * len(command_name),
            usage=usage,
            description=parser.description or '',
            arguments=arguments,
            options=os.linesep.join(options_text))

        filename = join(COMMANDS_DOCS_DIR, '{0}.rst'.format(command_name))
        logger.info('Write document: %s', os.path.relpath(filename))
        with open(filename, 'w+') as rst:
            rst.write(command_rst_content)


def generate_app_synopsis_global_options(parser, template_dir=None):
    """
    Generate text of synopsis and global options that will be filled into
    cli.rst and [app name].rst inside commands directory.
    """
    def _format_option(formatter, action):
        name_metavar = formatter._format_action_invocation(action)
        description = ' '.join(formatter._expand_help(action).split('\n'))
        return command_option_template.format(
            name_metavar=name_metavar, description=description)

    formatter = parser._get_formatter()
    options = [
        _format_option(formatter, action)
        for action in parser._get_optional_actions()
    ]

    tmpl = read_template('cli_synopsis_global_options.rst',
                         template_dir=template_dir)
    return tmpl.format(name=parser.prog, options='\n'.join(options))


def generate_cli_rst(parser, cli_subparsers, template_dir=None):
    """Generate cli.rst for generating HTML document"""
    commands_list = [
        '   commands/{0}'.format(parser_name)
        for parser_name, cmd_parser in cli_subparsers.choices.items()
        if cmd_parser.add_help
    ]
    synopsis_global_options = generate_app_synopsis_global_options(
        parser, template_dir=template_dir)

    tmpl = read_template('cli.rst', template_dir=template_dir)
    with open(join(DOC_SOURCE_DIR, 'cli.rst'), 'w+') as f:
        f.write(tmpl.format(
            synopsis_global_options=synopsis_global_options,
            commands_list='\n'.join(commands_list)))


def build_cli_parser():
    def validate_template_dir(value):
        if not os.path.exists(value):
            raise argparse.ArgumentTypeError(
                '{0} does not exists.'.format(value))
        if not os.path.isdir(value):
            raise argparse.ArgumentTypeError(
                '{0} is not a directory.'.format(value))
        return value

    parser = argparse.ArgumentParser(
        description='Generate commands RST documents in docs/source/commands'
                    ' for rendering HTML and man pages.')
    parser.add_argument(
        '--app-name',
        required=False,
        metavar='NAME',
        dest='app_name',
        default='sample-rpkg',
        help='Application name of the downstream client tool built on top of'
             ' rpkg. By default, for rpkg itself, sample-rpkg is used.')
    parser.add_argument(
        '-v', '--verbose',
        required=False,
        default=False,
        dest='verbose',
        action='store_true',
        help='Verbose output.')
    parser.add_argument(
        '--template-dir',
        required=False,
        metavar='DIR',
        type=validate_template_dir,
        default=join(DOC_DIR, 'templates'),
        help='From where to find custom document templates.')
    parser.add_argument(
        '--app-manpage-subject',
        required=False,
        metavar='SUBJECT',
        dest='app_manpage_subject',
        default='A utility to build RPM, container and module',
        help='The subject shown in sample rpkg executable manpage.'
    )
    return parser


if __name__ == '__main__':
    import pyrpkg.cli

    cli_parser = build_cli_parser()
    args = cli_parser.parse_args()
    if args.verbose:
        logger.level = logging.DEBUG

    client = pyrpkg.cli.cliClient(name=args.app_name, config=None)

    logger.info('Generate CLI RST for generating HTML document')
    generate_cli_rst(
        client.parser, client.subparsers, template_dir=args.template_dir)

    logger.info('Generate man_pages list from registered commands that will be'
                ' read in conf.py')
    generate_man_pages_list_file(
        client.parser, client.subparsers, args.app_manpage_subject)

    logger.info('Generate commands RST documents from registered commands into'
                ' source/commands/.')
    generate_command_rst_docs(
        client.subparsers, template_dir=args.template_dir)
