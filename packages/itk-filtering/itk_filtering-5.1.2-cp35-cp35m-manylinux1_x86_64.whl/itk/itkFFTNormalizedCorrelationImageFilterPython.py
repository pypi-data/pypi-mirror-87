# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKConvolutionPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkFFTNormalizedCorrelationImageFilterPython
else:
    import _itkFFTNormalizedCorrelationImageFilterPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkFFTNormalizedCorrelationImageFilterPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkFFTNormalizedCorrelationImageFilterPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkMaskedFFTNormalizedCorrelationImageFilterPython
import itk.itkImagePython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkFixedArrayPython
import itk.pyBasePython
import itk.itkMatrixPython
import itk.itkVectorPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.vnl_vector_refPython
import itk.itkPointPython
import itk.vnl_matrix_fixedPython
import itk.itkCovariantVectorPython
import itk.itkIndexPython
import itk.itkSizePython
import itk.itkOffsetPython
import itk.itkRGBAPixelPython
import itk.itkImageRegionPython
import itk.ITKCommonBasePython
import itk.itkRGBPixelPython
import itk.itkImageToImageFilterAPython
import itk.itkImageSourcePython
import itk.itkVectorImagePython
import itk.itkVariableLengthVectorPython
import itk.itkImageSourceCommonPython
import itk.itkImageToImageFilterCommonPython

def itkFFTNormalizedCorrelationImageFilterID2ID2_New():
    return itkFFTNormalizedCorrelationImageFilterID2ID2.New()

class itkFFTNormalizedCorrelationImageFilterID2ID2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2ID2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID2ID2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterID2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterID2ID2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterID2ID2)
itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2___New_orig__
itkFFTNormalizedCorrelationImageFilterID2ID2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2ID2_cast


def itkFFTNormalizedCorrelationImageFilterID2IF2_New():
    return itkFFTNormalizedCorrelationImageFilterID2IF2.New()

class itkFFTNormalizedCorrelationImageFilterID2IF2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID2IF2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID2IF2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterID2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterID2IF2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterID2IF2)
itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2___New_orig__
itkFFTNormalizedCorrelationImageFilterID2IF2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID2IF2_cast


def itkFFTNormalizedCorrelationImageFilterID3ID3_New():
    return itkFFTNormalizedCorrelationImageFilterID3ID3.New()

class itkFFTNormalizedCorrelationImageFilterID3ID3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3ID3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID3ID3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterID3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterID3ID3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterID3ID3)
itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3___New_orig__
itkFFTNormalizedCorrelationImageFilterID3ID3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3ID3_cast


def itkFFTNormalizedCorrelationImageFilterID3IF3_New():
    return itkFFTNormalizedCorrelationImageFilterID3IF3.New()

class itkFFTNormalizedCorrelationImageFilterID3IF3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterID3IF3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterID3IF3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterID3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterID3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterID3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterID3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterID3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterID3IF3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterID3IF3)
itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3___New_orig__
itkFFTNormalizedCorrelationImageFilterID3IF3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterID3IF3_cast


def itkFFTNormalizedCorrelationImageFilterIF2ID2_New():
    return itkFFTNormalizedCorrelationImageFilterIF2ID2.New()

class itkFFTNormalizedCorrelationImageFilterIF2ID2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2ID2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF2ID2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIF2ID2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIF2ID2)
itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2___New_orig__
itkFFTNormalizedCorrelationImageFilterIF2ID2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2ID2_cast


def itkFFTNormalizedCorrelationImageFilterIF2IF2_New():
    return itkFFTNormalizedCorrelationImageFilterIF2IF2.New()

class itkFFTNormalizedCorrelationImageFilterIF2IF2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF2IF2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF2IF2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIF2IF2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIF2IF2)
itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2___New_orig__
itkFFTNormalizedCorrelationImageFilterIF2IF2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF2IF2_cast


def itkFFTNormalizedCorrelationImageFilterIF3ID3_New():
    return itkFFTNormalizedCorrelationImageFilterIF3ID3.New()

class itkFFTNormalizedCorrelationImageFilterIF3ID3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3ID3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF3ID3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIF3ID3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIF3ID3)
itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3___New_orig__
itkFFTNormalizedCorrelationImageFilterIF3ID3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3ID3_cast


def itkFFTNormalizedCorrelationImageFilterIF3IF3_New():
    return itkFFTNormalizedCorrelationImageFilterIF3IF3.New()

class itkFFTNormalizedCorrelationImageFilterIF3IF3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIF3IF3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIF3IF3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIF3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIF3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIF3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIF3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIF3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIF3IF3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIF3IF3)
itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3___New_orig__
itkFFTNormalizedCorrelationImageFilterIF3IF3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIF3IF3_cast


def itkFFTNormalizedCorrelationImageFilterISS2ID2_New():
    return itkFFTNormalizedCorrelationImageFilterISS2ID2.New()

class itkFFTNormalizedCorrelationImageFilterISS2ID2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2ID2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS2ID2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterISS2ID2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterISS2ID2)
itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2___New_orig__
itkFFTNormalizedCorrelationImageFilterISS2ID2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2ID2_cast


def itkFFTNormalizedCorrelationImageFilterISS2IF2_New():
    return itkFFTNormalizedCorrelationImageFilterISS2IF2.New()

class itkFFTNormalizedCorrelationImageFilterISS2IF2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS2IF2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS2IF2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterISS2IF2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterISS2IF2)
itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2___New_orig__
itkFFTNormalizedCorrelationImageFilterISS2IF2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS2IF2_cast


def itkFFTNormalizedCorrelationImageFilterISS3ID3_New():
    return itkFFTNormalizedCorrelationImageFilterISS3ID3.New()

class itkFFTNormalizedCorrelationImageFilterISS3ID3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3ID3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS3ID3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterISS3ID3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterISS3ID3)
itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3___New_orig__
itkFFTNormalizedCorrelationImageFilterISS3ID3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3ID3_cast


def itkFFTNormalizedCorrelationImageFilterISS3IF3_New():
    return itkFFTNormalizedCorrelationImageFilterISS3IF3.New()

class itkFFTNormalizedCorrelationImageFilterISS3IF3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterISS3IF3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterISS3IF3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterISS3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterISS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterISS3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterISS3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterISS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterISS3IF3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterISS3IF3)
itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3___New_orig__
itkFFTNormalizedCorrelationImageFilterISS3IF3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterISS3IF3_cast


def itkFFTNormalizedCorrelationImageFilterIUC2ID2_New():
    return itkFFTNormalizedCorrelationImageFilterIUC2ID2.New()

class itkFFTNormalizedCorrelationImageFilterIUC2ID2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2ID2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC2ID2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUC2ID2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIUC2ID2)
itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2___New_orig__
itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2ID2_cast


def itkFFTNormalizedCorrelationImageFilterIUC2IF2_New():
    return itkFFTNormalizedCorrelationImageFilterIUC2IF2.New()

class itkFFTNormalizedCorrelationImageFilterIUC2IF2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC2IF2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC2IF2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUC2IF2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIUC2IF2)
itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2___New_orig__
itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC2IF2_cast


def itkFFTNormalizedCorrelationImageFilterIUC3ID3_New():
    return itkFFTNormalizedCorrelationImageFilterIUC3ID3.New()

class itkFFTNormalizedCorrelationImageFilterIUC3ID3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3ID3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC3ID3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUC3ID3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIUC3ID3)
itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3___New_orig__
itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3ID3_cast


def itkFFTNormalizedCorrelationImageFilterIUC3IF3_New():
    return itkFFTNormalizedCorrelationImageFilterIUC3IF3.New()

class itkFFTNormalizedCorrelationImageFilterIUC3IF3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUC3IF3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUC3IF3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUC3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUC3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUC3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUC3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUC3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUC3IF3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIUC3IF3)
itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3___New_orig__
itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUC3IF3_cast


def itkFFTNormalizedCorrelationImageFilterIUS2ID2_New():
    return itkFFTNormalizedCorrelationImageFilterIUS2ID2.New()

class itkFFTNormalizedCorrelationImageFilterIUS2ID2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2ID2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS2ID2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS2ID2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS2ID2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS2ID2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS2ID2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS2ID2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUS2ID2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_swigregister(itkFFTNormalizedCorrelationImageFilterIUS2ID2)
itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2___New_orig__
itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2ID2_cast


def itkFFTNormalizedCorrelationImageFilterIUS2IF2_New():
    return itkFFTNormalizedCorrelationImageFilterIUS2IF2.New()

class itkFFTNormalizedCorrelationImageFilterIUS2IF2(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS2IF2):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS2IF2
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS2IF2

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS2IF2 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS2IF2.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS2IF2.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS2IF2.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUS2IF2 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_swigregister(itkFFTNormalizedCorrelationImageFilterIUS2IF2)
itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2___New_orig__
itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS2IF2_cast


def itkFFTNormalizedCorrelationImageFilterIUS3ID3_New():
    return itkFFTNormalizedCorrelationImageFilterIUS3ID3.New()

class itkFFTNormalizedCorrelationImageFilterIUS3ID3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3ID3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS3ID3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS3ID3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS3ID3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS3ID3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS3ID3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS3ID3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUS3ID3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_swigregister(itkFFTNormalizedCorrelationImageFilterIUS3ID3)
itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3___New_orig__
itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3ID3_cast


def itkFFTNormalizedCorrelationImageFilterIUS3IF3_New():
    return itkFFTNormalizedCorrelationImageFilterIUS3IF3.New()

class itkFFTNormalizedCorrelationImageFilterIUS3IF3(itk.itkMaskedFFTNormalizedCorrelationImageFilterPython.itkMaskedFFTNormalizedCorrelationImageFilterIUS3IF3):
    r"""


    Calculate normalized cross correlation using FFTs.

    This filter calculates the normalized cross correlation (NCC) of two
    images using FFTs instead of spatial correlation. It is much faster
    than spatial correlation for reasonably large structuring elements.
    This filter is a subclass of the more general
    MaskedFFTNormalizedCorrelationImageFilter and operates by essentially
    setting the masks in that algorithm to images of ones. As described in
    detail in the references below, there is no computational overhead to
    utilizing the more general masked algorithm because the FFTs of the
    images of ones are still necessary for the computations.

    Inputs: Two images are required as inputs, fixedImage and movingImage.
    In the context of correlation, inputs are often defined as: "image"
    and "template". In this filter, the fixedImage plays the role of the
    image, and the movingImage plays the role of the template. However,
    this filter is capable of correlating any two images and is not
    restricted to small movingImages (templates).

    Optional parameters: The RequiredNumberOfOverlappingPixels enables the
    user to specify how many voxels of the two images must overlap; any
    location in the correlation map that results from fewer than this
    number of voxels will be set to zero. Larger values zero-out pixels on
    a larger border around the correlation image. Thus, larger values
    remove less stable computations but also limit the capture range. If
    RequiredNumberOfOverlappingPixels is set to 0, the default, no zeroing
    will take place.

    Image size: fixedImage and movingImage need not be the same size.
    Furthermore, whereas some algorithms require that the "template" be
    smaller than the "image" because of errors in the regions where the
    two are not fully overlapping, this filter has no such restriction.

    Image spacing: Since the computations are done in the pixel domain,
    all input images must have the same spacing.

    Outputs; The output is an image of RealPixelType that is the NCC of
    the two images and its values range from -1.0 to 1.0. The size of this
    NCC image is, by definition, size(fixedImage) + size(movingImage) - 1.

    Example filter usage:

    WARNING:  The pixel type of the output image must be of real type
    (float or double). ConceptChecking is used to enforce the output pixel
    type. You will get a compilation error if the pixel type of the output
    image is not float or double.  References: 1) D. Padfield. "Masked
    object registration in the Fourier domain." Transactions on Image
    Processing. 2) D. Padfield. "Masked FFT registration". In Proc.
    Computer Vision and Pattern Recognition, 2010.

    : Dirk Padfield, GE Global Research, padfield@research.ge.com 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__)
    Clone = _swig_new_instance_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_Clone)
    __swig_destroy__ = _itkFFTNormalizedCorrelationImageFilterPython.delete_itkFFTNormalizedCorrelationImageFilterIUS3IF3
    cast = _swig_new_static_method(_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast)

    def New(*args, **kargs):
        """New() -> itkFFTNormalizedCorrelationImageFilterIUS3IF3

        Create a new object of the class itkFFTNormalizedCorrelationImageFilterIUS3IF3 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkFFTNormalizedCorrelationImageFilterIUS3IF3.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkFFTNormalizedCorrelationImageFilterIUS3IF3.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkFFTNormalizedCorrelationImageFilterIUS3IF3.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkFFTNormalizedCorrelationImageFilterIUS3IF3 in _itkFFTNormalizedCorrelationImageFilterPython:
_itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_swigregister(itkFFTNormalizedCorrelationImageFilterIUS3IF3)
itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__ = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3___New_orig__
itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast = _itkFFTNormalizedCorrelationImageFilterPython.itkFFTNormalizedCorrelationImageFilterIUS3IF3_cast


import itkHelpers
@itkHelpers.accept_numpy_array_like_xarray
def fft_normalized_correlation_image_filter(*args, **kwargs):
    """Procedural interface for FFTNormalizedCorrelationImageFilter"""
    import itk
    instance = itk.FFTNormalizedCorrelationImageFilter.New(*args, **kwargs)
    return instance.__internal_call__()

def fft_normalized_correlation_image_filter_init_docstring():
    import itk
    import itkTemplate
    import itkHelpers
    if isinstance(itk.FFTNormalizedCorrelationImageFilter, itkTemplate.itkTemplate):
        filter_object = itk.FFTNormalizedCorrelationImageFilter.values()[0]
    else:
        filter_object = itk.FFTNormalizedCorrelationImageFilter

    fft_normalized_correlation_image_filter.__doc__ = filter_object.__doc__
    fft_normalized_correlation_image_filter.__doc__ += "\n Args are Input(s) to the filter.\n"
    fft_normalized_correlation_image_filter.__doc__ += "\n Available Keyword Arguments:\n"
    if isinstance(itk.FFTNormalizedCorrelationImageFilter, itkTemplate.itkTemplate):
        fft_normalized_correlation_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[0]
        fft_normalized_correlation_image_filter.__doc__ += "\n"
        fft_normalized_correlation_image_filter.__doc__ += itkHelpers.filter_args(filter_object)[1]
    else:
        fft_normalized_correlation_image_filter.__doc__ += "".join([
            "  " + itkHelpers.camel_to_snake_case(item[3:]) + "\n"
            for item in dir(filter_object)
            if item.startswith("Set")])



