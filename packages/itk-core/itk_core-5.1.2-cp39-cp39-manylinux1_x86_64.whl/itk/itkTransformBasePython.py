# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _ITKTransformPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkTransformBasePython
else:
    import _itkTransformBasePython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkTransformBasePython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkTransformBasePython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkDiffusionTensor3DPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkFixedArrayPython
import itk.pyBasePython
import itk.itkMatrixPython
import itk.vnl_matrixPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.itkCovariantVectorPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkVariableLengthVectorPython
import itk.itkOptimizerParametersPython
import itk.itkArrayPython
import itk.ITKCommonBasePython
import itk.itkArray2DPython
class listitkTransformBaseTemplateD_Pointer(object):
    r"""Proxy of C++ std::list< itkTransformBaseTemplateD_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___nonzero__)
    __bool__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___bool__)
    __len__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___len__)
    __getslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getslice__)
    __setslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setslice__)
    __delslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delslice__)
    __delitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___delitem__)
    __getitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___getitem__)
    __setitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer___setitem__)
    pop = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop)
    append = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_append)
    empty = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_empty)
    size = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_size)
    swap = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swap)
    begin = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_begin)
    end = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_end)
    rbegin = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rbegin)
    rend = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_rend)
    clear = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_clear)
    get_allocator = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_get_allocator)
    pop_back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_back)
    erase = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_erase)

    def __init__(self, *args):
        r"""
        __init__(listitkTransformBaseTemplateD_Pointer self) -> listitkTransformBaseTemplateD_Pointer
        __init__(listitkTransformBaseTemplateD_Pointer self, listitkTransformBaseTemplateD_Pointer other) -> listitkTransformBaseTemplateD_Pointer
        __init__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::size_type size) -> listitkTransformBaseTemplateD_Pointer
        __init__(listitkTransformBaseTemplateD_Pointer self, std::list< itkTransformBaseTemplateD_Pointer >::size_type size, std::list< itkTransformBaseTemplateD_Pointer >::value_type const & value) -> listitkTransformBaseTemplateD_Pointer
        """
        _itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swiginit(self, _itkTransformBasePython.new_listitkTransformBaseTemplateD_Pointer(*args))
    push_back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_back)
    front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_front)
    back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_back)
    assign = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_assign)
    resize = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_resize)
    insert = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_insert)
    pop_front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_pop_front)
    push_front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_push_front)
    reverse = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_reverse)
    __swig_destroy__ = _itkTransformBasePython.delete_listitkTransformBaseTemplateD_Pointer

# Register listitkTransformBaseTemplateD_Pointer in _itkTransformBasePython:
_itkTransformBasePython.listitkTransformBaseTemplateD_Pointer_swigregister(listitkTransformBaseTemplateD_Pointer)

class listitkTransformBaseTemplateF_Pointer(object):
    r"""Proxy of C++ std::list< itkTransformBaseTemplateF_Pointer > class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    iterator = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_iterator)
    def __iter__(self):
        return self.iterator()
    __nonzero__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___nonzero__)
    __bool__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___bool__)
    __len__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___len__)
    __getslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getslice__)
    __setslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setslice__)
    __delslice__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delslice__)
    __delitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___delitem__)
    __getitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___getitem__)
    __setitem__ = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer___setitem__)
    pop = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop)
    append = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_append)
    empty = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_empty)
    size = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_size)
    swap = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swap)
    begin = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_begin)
    end = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_end)
    rbegin = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rbegin)
    rend = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_rend)
    clear = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_clear)
    get_allocator = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_get_allocator)
    pop_back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_back)
    erase = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_erase)

    def __init__(self, *args):
        r"""
        __init__(listitkTransformBaseTemplateF_Pointer self) -> listitkTransformBaseTemplateF_Pointer
        __init__(listitkTransformBaseTemplateF_Pointer self, listitkTransformBaseTemplateF_Pointer other) -> listitkTransformBaseTemplateF_Pointer
        __init__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::size_type size) -> listitkTransformBaseTemplateF_Pointer
        __init__(listitkTransformBaseTemplateF_Pointer self, std::list< itkTransformBaseTemplateF_Pointer >::size_type size, std::list< itkTransformBaseTemplateF_Pointer >::value_type const & value) -> listitkTransformBaseTemplateF_Pointer
        """
        _itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swiginit(self, _itkTransformBasePython.new_listitkTransformBaseTemplateF_Pointer(*args))
    push_back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_back)
    front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_front)
    back = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_back)
    assign = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_assign)
    resize = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_resize)
    insert = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_insert)
    pop_front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_pop_front)
    push_front = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_push_front)
    reverse = _swig_new_instance_method(_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_reverse)
    __swig_destroy__ = _itkTransformBasePython.delete_listitkTransformBaseTemplateF_Pointer

# Register listitkTransformBaseTemplateF_Pointer in _itkTransformBasePython:
_itkTransformBasePython.listitkTransformBaseTemplateF_Pointer_swigregister(listitkTransformBaseTemplateF_Pointer)


def itkDataObjectDecoratorTD22_New():
    return itkDataObjectDecoratorTD22.New()

class itkDataObjectDecoratorTD22(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD22___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD22
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD22_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD22

        Create a new object of the class itkDataObjectDecoratorTD22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTD22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTD22 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTD22_swigregister(itkDataObjectDecoratorTD22)
itkDataObjectDecoratorTD22___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTD22___New_orig__
itkDataObjectDecoratorTD22_cast = _itkTransformBasePython.itkDataObjectDecoratorTD22_cast


def itkDataObjectDecoratorTD23_New():
    return itkDataObjectDecoratorTD23.New()

class itkDataObjectDecoratorTD23(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD23___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD23
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD23_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD23

        Create a new object of the class itkDataObjectDecoratorTD23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTD23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTD23 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTD23_swigregister(itkDataObjectDecoratorTD23)
itkDataObjectDecoratorTD23___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTD23___New_orig__
itkDataObjectDecoratorTD23_cast = _itkTransformBasePython.itkDataObjectDecoratorTD23_cast


def itkDataObjectDecoratorTD32_New():
    return itkDataObjectDecoratorTD32.New()

class itkDataObjectDecoratorTD32(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD32___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD32
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD32_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD32

        Create a new object of the class itkDataObjectDecoratorTD32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTD32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTD32 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTD32_swigregister(itkDataObjectDecoratorTD32)
itkDataObjectDecoratorTD32___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTD32___New_orig__
itkDataObjectDecoratorTD32_cast = _itkTransformBasePython.itkDataObjectDecoratorTD32_cast


def itkDataObjectDecoratorTD33_New():
    return itkDataObjectDecoratorTD33.New()

class itkDataObjectDecoratorTD33(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD33___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTD33
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTD33_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTD33

        Create a new object of the class itkDataObjectDecoratorTD33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTD33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTD33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTD33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTD33 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTD33_swigregister(itkDataObjectDecoratorTD33)
itkDataObjectDecoratorTD33___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTD33___New_orig__
itkDataObjectDecoratorTD33_cast = _itkTransformBasePython.itkDataObjectDecoratorTD33_cast


def itkDataObjectDecoratorTF22_New():
    return itkDataObjectDecoratorTF22.New()

class itkDataObjectDecoratorTF22(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF22___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF22
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF22_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF22

        Create a new object of the class itkDataObjectDecoratorTF22 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF22.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF22.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTF22.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTF22 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTF22_swigregister(itkDataObjectDecoratorTF22)
itkDataObjectDecoratorTF22___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTF22___New_orig__
itkDataObjectDecoratorTF22_cast = _itkTransformBasePython.itkDataObjectDecoratorTF22_cast


def itkDataObjectDecoratorTF23_New():
    return itkDataObjectDecoratorTF23.New()

class itkDataObjectDecoratorTF23(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF23___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF23
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF23_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF23

        Create a new object of the class itkDataObjectDecoratorTF23 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF23.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF23.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTF23.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTF23 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTF23_swigregister(itkDataObjectDecoratorTF23)
itkDataObjectDecoratorTF23___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTF23___New_orig__
itkDataObjectDecoratorTF23_cast = _itkTransformBasePython.itkDataObjectDecoratorTF23_cast


def itkDataObjectDecoratorTF32_New():
    return itkDataObjectDecoratorTF32.New()

class itkDataObjectDecoratorTF32(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF32___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF32
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF32_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF32

        Create a new object of the class itkDataObjectDecoratorTF32 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF32.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF32.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTF32.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTF32 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTF32_swigregister(itkDataObjectDecoratorTF32)
itkDataObjectDecoratorTF32___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTF32___New_orig__
itkDataObjectDecoratorTF32_cast = _itkTransformBasePython.itkDataObjectDecoratorTF32_cast


def itkDataObjectDecoratorTF33_New():
    return itkDataObjectDecoratorTF33.New()

class itkDataObjectDecoratorTF33(itk.ITKCommonBasePython.itkDataObject):
    r"""


    Decorates any subclass of itkObject with a DataObject API.

    DataObjectDecorator decorates an instance of a subclass of itkObject
    with a DataObject API. This allows any itkObject to be encapsulated
    into a DataObject that can be passed down the pipeline. To decorate
    simple types (float, int, std::vector) see SimpleDataObjectDecorator.

    The decorator provides two methods Set() and Get() to access the
    decorated object (referred internally as the component).

    Note that when an instance of DataObjectDecorator is created, the
    component is initialized with its default constructor (in this case a
    null pointer).

    DataObjectDecorator can decorate any subclass of itkObject. Two other
    decorators are provided. SimpleDataObjectDecorator can encapsulate
    simple types (float, int, std::vector). AutoPointerDataObjectDecorator
    will decorate any pointer type (for objects other than subclasses of
    itkObject) and manage the memory deallocating of the component.

    See:  SimpleDataObjectDecorator

    See:  AutoPointerDataObjectDecorator 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __New_orig__ = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF33___New_orig__)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_Clone)
    Set = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_Set)
    Get = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_Get)
    GetModifiable = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_GetModifiable)
    Graft = _swig_new_instance_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_Graft)
    __swig_destroy__ = _itkTransformBasePython.delete_itkDataObjectDecoratorTF33
    cast = _swig_new_static_method(_itkTransformBasePython.itkDataObjectDecoratorTF33_cast)

    def New(*args, **kargs):
        """New() -> itkDataObjectDecoratorTF33

        Create a new object of the class itkDataObjectDecoratorTF33 and set the input and the parameters if some
        named or non-named arguments are passed to that method.

        New() tries to assign all the non named parameters to the input of the new objects - the
        first non named parameter in the first input, etc.

        The named parameters are used by calling the method with the same name prefixed by 'Set'.

        Ex:

          itkDataObjectDecoratorTF33.New(reader, threshold=10)

        is (most of the time) equivalent to:

          obj = itkDataObjectDecoratorTF33.New()
          obj.SetInput(0, reader.GetOutput())
          obj.SetThreshold(10)
        """
        obj = itkDataObjectDecoratorTF33.__New_orig__()
        import itkTemplate
        itkTemplate.New(obj, *args, **kargs)
        return obj
    New = staticmethod(New)


# Register itkDataObjectDecoratorTF33 in _itkTransformBasePython:
_itkTransformBasePython.itkDataObjectDecoratorTF33_swigregister(itkDataObjectDecoratorTF33)
itkDataObjectDecoratorTF33___New_orig__ = _itkTransformBasePython.itkDataObjectDecoratorTF33___New_orig__
itkDataObjectDecoratorTF33_cast = _itkTransformBasePython.itkDataObjectDecoratorTF33_cast

class itkTransformBaseTemplateD(itk.ITKCommonBasePython.itkObject):
    r"""Proxy of C++ itkTransformBaseTemplateD class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetNumberOfParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetNumberOfParameters)
    GetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetParameters)
    GetInputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetInputSpaceDimension)
    GetOutputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetOutputSpaceDimension)
    SetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_SetParameters)
    SetParametersByValue = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_SetParametersByValue)
    SetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_SetFixedParameters)
    CopyInParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_CopyInParameters)
    CopyInFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_CopyInFixedParameters)
    GetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetFixedParameters)
    GetTransformTypeAsString = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetTransformTypeAsString)
    GetTransformCategory = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_GetTransformCategory)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateD
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformBaseTemplateD_cast)

# Register itkTransformBaseTemplateD in _itkTransformBasePython:
_itkTransformBasePython.itkTransformBaseTemplateD_swigregister(itkTransformBaseTemplateD)
itkTransformBaseTemplateD_cast = _itkTransformBasePython.itkTransformBaseTemplateD_cast

class itkTransformBaseTemplateD_ConstPointer(object):
    r"""Proxy of C++ itkTransformBaseTemplateD_ConstPointer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(itkTransformBaseTemplateD_ConstPointer self) -> itkTransformBaseTemplateD_ConstPointer
        __init__(itkTransformBaseTemplateD_ConstPointer self, itkTransformBaseTemplateD_ConstPointer p) -> itkTransformBaseTemplateD_ConstPointer
        __init__(itkTransformBaseTemplateD_ConstPointer self, itkTransformBaseTemplateD p) -> itkTransformBaseTemplateD_ConstPointer
        """
        _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateD_ConstPointer(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateD_ConstPointer
    __deref__ = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___deref__)
    __ref__ = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer___ref__)
    IsNotNull = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNotNull)
    IsNull = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_IsNull)
    GetPointer = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetPointer)
    Print = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Print)
    Swap = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Swap)
    GetNumberOfParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNumberOfParameters)
    GetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetParameters)
    GetInputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetInputSpaceDimension)
    GetOutputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetOutputSpaceDimension)
    GetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetFixedParameters)
    GetTransformTypeAsString = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformTypeAsString)
    GetTransformCategory = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTransformCategory)
    DebugOn = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOn)
    DebugOff = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_DebugOff)
    GetDebug = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetDebug)
    SetDebug = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_SetDebug)
    GetMTime = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMTime)
    GetTimeStamp = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetTimeStamp)
    Modified = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Modified)

    def AddObserver(self, *args) -> "unsigned long":
        r"""
        AddObserver(itkTransformBaseTemplateD_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        AddObserver(itkTransformBaseTemplateD_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        Allow people to
        add/remove/invoke observers (callbacks) to any ITK object. This is an
        implementation of the subject/observer design pattern. An observer is
        added by specifying an event to respond to and an itk::Command to
        execute. It returns an unsigned long tag which can be used later to
        remove the event or retrieve the command. The memory for the Command
        becomes the responsibility of this object, so don't pass the same
        instance of a command to two different objects 
        """

        import itk
        if len(args) == 3 and not issubclass(args[2].__class__, itk.Command) and callable(args[2]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[2] )
            args[2] = pycommand
            args = tuple(args)
        elif len(args) == 2 and not issubclass(args[1].__class__, itk.Command) and callable(args[1]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[1] )
            args[1] = pycommand
            args = tuple(args)


        return _itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_AddObserver(self, *args)

    InvokeEvent = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_InvokeEvent)
    HasObserver = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_HasObserver)
    GetMetaDataDictionary = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetMetaDataDictionary)
    GetObjectName = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetObjectName)
    CreateAnother = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_CreateAnother)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_Clone)
    GetNameOfClass = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetNameOfClass)
    GetReferenceCount = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_GetReferenceCount)

# Register itkTransformBaseTemplateD_ConstPointer in _itkTransformBasePython:
_itkTransformBasePython.itkTransformBaseTemplateD_ConstPointer_swigregister(itkTransformBaseTemplateD_ConstPointer)

class itkTransformBaseTemplateEnums(object):
    r"""Proxy of C++ itkTransformBaseTemplateEnums class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    TransformCategory_UnknownTransformCategory = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_UnknownTransformCategory
    
    TransformCategory_Linear = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_Linear
    
    TransformCategory_BSpline = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_BSpline
    
    TransformCategory_Spline = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_Spline
    
    TransformCategory_DisplacementField = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_DisplacementField
    
    TransformCategory_VelocityField = _itkTransformBasePython.itkTransformBaseTemplateEnums_TransformCategory_VelocityField
    

    def __init__(self, *args):
        r"""
        __init__(itkTransformBaseTemplateEnums self) -> itkTransformBaseTemplateEnums
        __init__(itkTransformBaseTemplateEnums self, itkTransformBaseTemplateEnums arg0) -> itkTransformBaseTemplateEnums
        """
        _itkTransformBasePython.itkTransformBaseTemplateEnums_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateEnums(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateEnums

# Register itkTransformBaseTemplateEnums in _itkTransformBasePython:
_itkTransformBasePython.itkTransformBaseTemplateEnums_swigregister(itkTransformBaseTemplateEnums)

class itkTransformBaseTemplateF(itk.ITKCommonBasePython.itkObject):
    r"""Proxy of C++ itkTransformBaseTemplateF class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    GetNumberOfParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetNumberOfParameters)
    GetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetParameters)
    GetInputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetInputSpaceDimension)
    GetOutputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetOutputSpaceDimension)
    SetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_SetParameters)
    SetParametersByValue = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_SetParametersByValue)
    SetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_SetFixedParameters)
    CopyInParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_CopyInParameters)
    CopyInFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_CopyInFixedParameters)
    GetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetFixedParameters)
    GetTransformTypeAsString = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetTransformTypeAsString)
    GetTransformCategory = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_GetTransformCategory)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateF
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformBaseTemplateF_cast)

# Register itkTransformBaseTemplateF in _itkTransformBasePython:
_itkTransformBasePython.itkTransformBaseTemplateF_swigregister(itkTransformBaseTemplateF)
itkTransformBaseTemplateF_cast = _itkTransformBasePython.itkTransformBaseTemplateF_cast

class itkTransformBaseTemplateF_ConstPointer(object):
    r"""Proxy of C++ itkTransformBaseTemplateF_ConstPointer class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        r"""
        __init__(itkTransformBaseTemplateF_ConstPointer self) -> itkTransformBaseTemplateF_ConstPointer
        __init__(itkTransformBaseTemplateF_ConstPointer self, itkTransformBaseTemplateF_ConstPointer p) -> itkTransformBaseTemplateF_ConstPointer
        __init__(itkTransformBaseTemplateF_ConstPointer self, itkTransformBaseTemplateF p) -> itkTransformBaseTemplateF_ConstPointer
        """
        _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_swiginit(self, _itkTransformBasePython.new_itkTransformBaseTemplateF_ConstPointer(*args))
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformBaseTemplateF_ConstPointer
    __deref__ = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___deref__)
    __ref__ = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer___ref__)
    IsNotNull = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNotNull)
    IsNull = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_IsNull)
    GetPointer = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetPointer)
    Print = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Print)
    Swap = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Swap)
    GetNumberOfParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNumberOfParameters)
    GetParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetParameters)
    GetInputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetInputSpaceDimension)
    GetOutputSpaceDimension = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetOutputSpaceDimension)
    GetFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetFixedParameters)
    GetTransformTypeAsString = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformTypeAsString)
    GetTransformCategory = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTransformCategory)
    DebugOn = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOn)
    DebugOff = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_DebugOff)
    GetDebug = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetDebug)
    SetDebug = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_SetDebug)
    GetMTime = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMTime)
    GetTimeStamp = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetTimeStamp)
    Modified = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Modified)

    def AddObserver(self, *args) -> "unsigned long":
        r"""
        AddObserver(itkTransformBaseTemplateF_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        AddObserver(itkTransformBaseTemplateF_ConstPointer self, itkEventObject event, itkCommand arg1) -> unsigned long
        Allow people to
        add/remove/invoke observers (callbacks) to any ITK object. This is an
        implementation of the subject/observer design pattern. An observer is
        added by specifying an event to respond to and an itk::Command to
        execute. It returns an unsigned long tag which can be used later to
        remove the event or retrieve the command. The memory for the Command
        becomes the responsibility of this object, so don't pass the same
        instance of a command to two different objects 
        """

        import itk
        if len(args) == 3 and not issubclass(args[2].__class__, itk.Command) and callable(args[2]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[2] )
            args[2] = pycommand
            args = tuple(args)
        elif len(args) == 2 and not issubclass(args[1].__class__, itk.Command) and callable(args[1]):
            args = list(args)
            pycommand = itk.PyCommand.New()
            pycommand.SetCommandCallable( args[1] )
            args[1] = pycommand
            args = tuple(args)


        return _itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_AddObserver(self, *args)

    InvokeEvent = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_InvokeEvent)
    HasObserver = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_HasObserver)
    GetMetaDataDictionary = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetMetaDataDictionary)
    GetObjectName = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetObjectName)
    CreateAnother = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_CreateAnother)
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_Clone)
    GetNameOfClass = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetNameOfClass)
    GetReferenceCount = _swig_new_instance_method(_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_GetReferenceCount)

# Register itkTransformBaseTemplateF_ConstPointer in _itkTransformBasePython:
_itkTransformBasePython.itkTransformBaseTemplateF_ConstPointer_swigregister(itkTransformBaseTemplateF_ConstPointer)

class itkTransformD2(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD2_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD2
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD2_cast)

# Register itkTransformD2 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD2_swigregister(itkTransformD2)
itkTransformD2_cast = _itkTransformBasePython.itkTransformD2_cast

class itkTransformD22(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD22_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD22
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD22_cast)

# Register itkTransformD22 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD22_swigregister(itkTransformD22)
itkTransformD22_cast = _itkTransformBasePython.itkTransformD22_cast

class itkTransformD23(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD23_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD23
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD23_cast)

# Register itkTransformD23 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD23_swigregister(itkTransformD23)
itkTransformD23_cast = _itkTransformBasePython.itkTransformD23_cast

class itkTransformD3(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD3_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD3
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD3_cast)

# Register itkTransformD3 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD3_swigregister(itkTransformD3)
itkTransformD3_cast = _itkTransformBasePython.itkTransformD3_cast

class itkTransformD32(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD32_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD32
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD32_cast)

# Register itkTransformD32 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD32_swigregister(itkTransformD32)
itkTransformD32_cast = _itkTransformBasePython.itkTransformD32_cast

class itkTransformD33(itkTransformBaseTemplateD):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformD33_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformD33
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformD33_cast)

# Register itkTransformD33 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformD33_swigregister(itkTransformD33)
itkTransformD33_cast = _itkTransformBasePython.itkTransformD33_cast

class itkTransformF2(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF2_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF2
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF2_cast)

# Register itkTransformF2 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF2_swigregister(itkTransformF2)
itkTransformF2_cast = _itkTransformBasePython.itkTransformF2_cast

class itkTransformF22(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF22_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF22
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF22_cast)

# Register itkTransformF22 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF22_swigregister(itkTransformF22)
itkTransformF22_cast = _itkTransformBasePython.itkTransformF22_cast

class itkTransformF23(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF23_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF23
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF23_cast)

# Register itkTransformF23 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF23_swigregister(itkTransformF23)
itkTransformF23_cast = _itkTransformBasePython.itkTransformF23_cast

class itkTransformF3(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF3_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF3
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF3_cast)

# Register itkTransformF3 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF3_swigregister(itkTransformF3)
itkTransformF3_cast = _itkTransformBasePython.itkTransformF3_cast

class itkTransformF32(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF32_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF32
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF32_cast)

# Register itkTransformF32 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF32_swigregister(itkTransformF32)
itkTransformF32_cast = _itkTransformBasePython.itkTransformF32_cast

class itkTransformF33(itkTransformBaseTemplateF):
    r"""


    Transform points and vectors from an input space to an output space.

    This abstract class defines the generic interface for a geometric
    transformation from one space to another. The class provides methods
    for mapping points, vectors and covariant vectors from the input space
    to the output space.

    Given that transformations are not necessarily invertible, this basic
    class does not provide the methods for back transformation. Back
    transform methods are implemented in derived classes where
    appropriate.

    Registration Framework Support Typically a Transform class has several
    methods for setting its parameters. For use in the registration
    framework, the parameters must also be represented by an array of
    doubles to allow communication with generic optimizers. The Array of
    transformation parameters is set using the SetParameters() method.
    Another requirement of the registration framework is the computation
    of the transform Jacobian. In general, an ImageToImageMetric requires
    the knowledge of the Jacobian in order to compute the metric
    derivatives. The Jacobian is a matrix whose element are the partial
    derivatives of the output point with respect to the array of
    parameters that defines the transform.

    Subclasses must provide implementations for:  virtual OutputPointType
    TransformPoint(const InputPointType  &) const  virtual
    OutputVectorType TransformVector(const InputVectorType &) const
    virtual OutputVnlVectorType TransformVector(const InputVnlVectorType
    &) const  virtual OutputCovariantVectorType
    TransformCovariantVector(const InputCovariantVectorType &) const
    virtual void SetParameters(const ParametersType &)  virtual void
    SetFixedParameters(const FixedParametersType &)  virtual void
    ComputeJacobianWithRespectToParameters( const InputPointType &,
    JacobianType &) const  virtual void
    ComputeJacobianWithRespectToPosition( const InputPointType & x,
    JacobianPositionType &jacobian ) const;

    Since TranformVector and TransformCovariantVector have multiple
    overloaded methods from the base class, subclasses must specify:
    using Superclass::TransformVector;  using
    Superclass::TransformCovariantVector; 
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    Clone = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_Clone)
    TransformPoint = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_TransformPoint)
    TransformVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_TransformVector)
    TransformCovariantVector = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_TransformCovariantVector)
    TransformDiffusionTensor3D = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_TransformDiffusionTensor3D)
    TransformSymmetricSecondRankTensor = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_TransformSymmetricSecondRankTensor)
    UpdateTransformParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_UpdateTransformParameters)
    GetNumberOfLocalParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_GetNumberOfLocalParameters)
    GetNumberOfFixedParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_GetNumberOfFixedParameters)
    GetInverse = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_GetInverse)
    GetInverseTransform = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_GetInverseTransform)
    IsLinear = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_IsLinear)
    ComputeJacobianWithRespectToParameters = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParameters)
    ComputeJacobianWithRespectToParametersCachedTemporaries = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToParametersCachedTemporaries)
    ComputeJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_ComputeJacobianWithRespectToPosition)
    ComputeInverseJacobianWithRespectToPosition = _swig_new_instance_method(_itkTransformBasePython.itkTransformF33_ComputeInverseJacobianWithRespectToPosition)
    __swig_destroy__ = _itkTransformBasePython.delete_itkTransformF33
    cast = _swig_new_static_method(_itkTransformBasePython.itkTransformF33_cast)

# Register itkTransformF33 in _itkTransformBasePython:
_itkTransformBasePython.itkTransformF33_swigregister(itkTransformF33)
itkTransformF33_cast = _itkTransformBasePython.itkTransformF33_cast



